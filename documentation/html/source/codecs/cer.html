
<html>
    <head>
        <!-- Standard -->
        <title>codecs.cer</title>
        <meta charset="utf-8">
        <meta name="author" content="Jonathan M. Wilbur jonathan@wilbur.space">
        <meta name="description" content="ASN.1 Codecs, as specified in ITU X.690, including BER, DER, and PER">
        <meta name="keywords" content="codecs.cer,asn1,asn.1,x690,x.690,ber,cer,der,per,basic encoding rules,codec,dlang,d">
        <meta name="theme-color" content="#FFFFFF">

        <!-- Google -->
        <meta name="application-url" content="https://github.com/JonathanWilbur/asn1-d">
        <meta name="audience" content="grownup">
        <meta itemprop="name" content="codecs.cer - ASN.1 D Library">
        <meta itemprop="description" content="ASN.1 Codecs, as specified in ITU X.690, including BER, DER, and PER">

        <!-- Apple -->
        <meta name="apple-mobile-web-app-title" content="codecs.cer">
        <meta name="apple-mobile-web-app-status-bar-style" content="white">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-touch-fullscreen" content="yes">
        <meta name="format-detection" content="telephone=yes">

        <!-- Microsoft -->
        <meta name="msapplication-tooltip" content="codecs.cer - ASN.1 D Library">
        <meta name="msapplication-TileColor" content="#FFFFFF">

        <!-- Miscellaneous -->
        <meta name="designer" content="Jonathan M. Wilbur jonathan@wilbur.space">
        <meta name="mobile-web-app-capable" content="yes">
        <meta name="version" content="1.0.0">
        <meta name="copyright" content="Copyright 2018 (C) Jonathan M. Wilbur.">
        <meta name="language" content="English">

        <!-- Facebook -->
        <meta property="og:type" content="website">
        <meta property="og:locale" content="en_US">
        <meta property="og:url" content="https://github.com/JonathanWilbur/asn1-d">
        <meta property="og:title" content="codecs.cer - ASN.1 D Library">
        <meta property="og:description" content="ASN.1 Codecs, as specified in ITU X.690, including BER, DER, and PER">
        <meta property="og:site_name" content="GitHub">

        <!-- Twitter -->
        <meta name="twitter:card" content="website">
        <meta name="twitter:url" content="https://github.com/JonathanWilbur/asn1-d">
        <meta name="twitter:title" content="codecs.cer - ASN.1 D Library">
        <meta name="twitter:description" content="ASN.1 Codecs, as specified in ITU X.690, including BER, DER, and PER">

        <!-- Application -->
        <style type="text/css">
body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    color: #661515;
    background-image: linear-gradient(to right, #FFFFEE 0%, #FFCCBB 100%);
    margin: 20px;
}

a {
    color: #AA0000;
	font-weight: 500;
	-webkit-transition: color 0.2s;
    transition: color 0.2s;
    text-decoration-style: none;
}

a:hover {
	color: #FF2222;
}

a::before,a::after {
	font-weight: 100;
	font-size: 110%;
	line-height: 1;
	opacity: 0;
	-webkit-transition: opacity 0.2s, -webkit-transform 0.2s;
	transition: opacity 0.2s, transform 0.2s;
}

a::before {
	left: -0.1em;
	content: '[';
	-webkit-transform: translateX(-100%);
	transform: translateX(-100%);
}

a::after {
	right: -0.1em;
	content: ']';
	-webkit-transform: translateX(100%);
	transform: translateX(100%);
}

a:hover::before,a:hover::after {
	opacity: 1;
	-webkit-transform: translateX(0);
	transform: translateX(0);
}

code, .mono {
    font-family: Courier New, Courier, monospace;
}

.d.inline {
    display: inline-block;
}

.d.block .declaration {
    display: block;
    padding: 10px;
    margin: 10px;
}

.declaration {
    background-color: #FFFFEE;
    border-radius: 5px;
    padding: 10px;
    margin: 10px;
}

#summary, .description {
    margin: 5px;
    padding: 5px;
}

.module-info {
	margin-bottom: 100px;
}

.member {
	font-weight: bold;
}
        </style>
    </head>
    <body>
        <div id="header">
            <h1>codecs.cer</h1>
            <h2>ASN.1 Codecs, as specified in ITU X.690, including BER, DER, and PER</h2>
        </div>
        <div id="content">
            <section class="module-info"><section id="summary">Canonical Encoding Rules (CER) is a standard for encoding ASN.1 data.
    CER is often used for cryptgraphically-signed data, such as X.509
    certificates, because CER's defining feature is that there is only one way
    to encode each data type, which means that two encodings of the same data
    could not have different cryptographic signatures. For this reason, CER
    is generally regarded as the most secure encoding standard for ASN.1.
    Like Basic Encoding Rules (BER), Canonical Encoding Rules (CER), and
    Packed Encoding Rules (PER), Canonical Encoding Rules (CER) is a
    specification created by the
    <a href="http://www.itu.int/en/pages/default.aspx">International Telecommunications Union</a>,
    and specified in <a href="http://www.itu.int/rec/T-REC-X.690/en">X.690 - ASN.1 encoding rules</a>
</section>
<div class="ddoc_authors">
	<h4>Authors</h4>
	<p class="para">
		<ul>        <li><span class="person">
    <a href="http://jonathan.wilbur.space">Jonathan M. Wilbur</a>
    <span>&lt;<a href="mailto:jonathan@wilbur.space">jonathan@wilbur.space</a>&gt;</span>
</span></li>
    </ul>

	</p>
</div>
<div class="ddoc_license">
	<h4>License</h4>
	<p class="para">
		<a href="https://mit-license.org/">MIT License</a>

	</p>
</div>
<div class="ddoc_standards">
	<h4>Standards</h4>
	<p class="para">
		<ul>        <li><a href="https://www.itu.int/rec/T-REC-X.680/en">X.680 - Abstract Syntax Notation One (ASN.1)</a></li>
        <li><a href="http://www.itu.int/rec/T-REC-X.690/en">X.690 - ASN.1 encoding rules</a></li>
    </ul>

	</p>
</div><div class="ddoc_see_also">
	<h4>See Also</h4>
	<p class="para">
		<ul>        <li><a href="https://en.wikipedia.org/wiki/Abstract_Syntax_Notation_One">The Wikipedia Page on ASN.1</a></li>
        <li><a href="https://en.wikipedia.org/wiki/X.690">The Wikipedia Page on X.690</a></li>
        <li><a href="https://www.strozhevsky.com/free_docs/asn1_in_simple_words.pdf">ASN.1 By Simple Words</a></li>
        <li><a href="http://www.oss.com/asn1/resources/books-whitepapers-pubs/dubuisson-asn1-book.PDF">ASN.1: Communication Between Heterogeneous Systems</a></li>
    </ul>
	</p>
</div>
</section>
<section class="module-members">
    <ul class="ddoc_members">
	<li class="ddoc_member"><a href="#cerOID" id="cerOID"><code class="member">cerOID</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="cerOID"></span>alias <code class="code">cerOID</code> = canonicalEncodingRulesObjectIdentifier;

    </code>
</section>
<div>
</div>
</li><li class="ddoc_member"><a href="#cerObjectID" id="cerObjectID"><code class="member">cerObjectID</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="cerObjectID"></span>alias <code class="code">cerObjectID</code> = canonicalEncodingRulesObjectIdentifier;

    </code>
</section>
<div>
</div>
</li><li class="ddoc_member"><a href="#cerObjectIdentifier" id="cerObjectIdentifier"><code class="member">cerObjectIdentifier</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="cerObjectIdentifier"></span>alias <code class="code">cerObjectIdentifier</code> = canonicalEncodingRulesObjectIdentifier;

    </code>
</section>
<div>
</div>
</li><li class="ddoc_member"><a href="#canonicalEncodingRulesObjectIdentifier" id="canonicalEncodingRulesObjectIdentifier"><code class="member">canonicalEncodingRulesObjectIdentifier</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="canonicalEncodingRulesObjectIdentifier"></span>immutable OID <code class="code">canonicalEncodingRulesObjectIdentifier</code>;

    </code>
</section>
<div><section class="module-info"><section id="summary">The object identifier assigned to the Canonical Encoding Rules (CER), per the
    <a href="http://www.itu.int/en/pages/default.aspx">        International Telecommunications Union</a>'s,
    <a href="http://www.itu.int/rec/T-REC-X.690/en">X.690 - ASN.1 encoding rules</a>
</section>
<div class="description"><span class="mono">{joint-iso-itu-t asn1(1) ber-derived(2) canonical-encoding(0)} </span></div>
</section>
</div>
</li><li class="ddoc_member"><a href="#CERElement" id="CERElement"><code class="member">CERElement</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CERElement"></span>alias <code class="code">CERElement</code> = CanonicalEncodingRulesElement;

    </code>
</section>
<div>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement" id="CanonicalEncodingRulesElement"><code class="member">CanonicalEncodingRulesElement</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement"></span>class <code class="code">CanonicalEncodingRulesElement</code>: <span class="ddoc_psuper_symbol">codec.ASN1Element!(<code class="code">CanonicalEncodingRulesElement</code>).AbstractSyntaxNotation1Element</span>, <span class="ddoc_psuper_symbol">interfaces.Byteable</span>;

    </code>
</section>
<div><section class="module-info"><section id="summary">The unit of encoding and decoding for Canonical Encoding Rules (CER).
</section>
<div class="description">    There are three parts to an element encoded according to the Canonical
    Encoding Rules (CER):
<br><br>
    <ul>        <li>A Type Tag, which specifies what data type is encoded</li>
        <li>A Length Tag, which specifies how many subsequent bytes encode the data</li>
        <li>The Encoded Value</li>
    </ul>
<br><br>
    They appear in the binary encoding in that order, and as such, the encoding
    scheme is sometimes described as "TLV," which stands for Type-Length-Value.
<br><br>
    This class provides a properties for getting and setting bit fields of
    the type tag, but most of it is functionality for encoding data per
    the specification.
<br><br>
    As an example, this is what encoding a simple INTEGER looks like:
<br><br>
<pre><code class="d block">CERElement cv = new CERElement();
cv.tagNumber = 0x02u; <span class="comment">// "2" means this is an INTEGER
</span>cv.integer = 1433; <span class="comment">// Now the data is encoded.
</span>transmit(cast(ubyte[]) cv); <span class="comment">// transmit() is a made-up function.
</span></code></pre>
<br><br>
    And this is what decoding looks like:
<br><br>
<pre><code class="d block">ubyte[] data = receive(); <span class="comment">// receive() is a made-up function.
</span>CERElement cv2 = new CERElement(data);

long x;
if (cv.tagNumber == 0x02u) <span class="comment">// it is an INTEGER
</span>{
    x = cv.integer;
}
<span class="comment">// Now x is 1433!
</span></code></pre>
</div>
</section>
<ul class="ddoc_members">
	<li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.tagClass" id="CanonicalEncodingRulesElement.tagClass"><code class="member">tagClass</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.tagClass"></span>ASN1TagClass <code class="code">tagClass</code>;

    </code>
</section>
<div>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.construction" id="CanonicalEncodingRulesElement.construction"><code class="member">construction</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.construction"></span>ASN1Construction <code class="code">construction</code>;

    </code>
</section>
<div>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.tagNumber" id="CanonicalEncodingRulesElement.tagNumber"><code class="member">tagNumber</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.tagNumber"></span>size_t <code class="code">tagNumber</code>;

    </code>
</section>
<div>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.length" id="CanonicalEncodingRulesElement.length"><code class="member">length</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.length"></span>final const nothrow @property @safe size_t <code class="code">length</code>();

    </code>
</section>
<div><section class="module-info"><section id="summary">The <code class="code">length</code> of the value in octets</section>
</section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.value" id="CanonicalEncodingRulesElement.value"><code class="member">value</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.value"></span>ubyte[] <code class="code">value</code>;

    </code>
</section>
<div><section class="module-info"><section id="summary">The octets of the encoded <code class="code">value</code>.</section>
</section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.endOfContent" id="CanonicalEncodingRulesElement.endOfContent"><code class="member">endOfContent</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.endOfContent"></span>const @property @safe void <code class="code">endOfContent</code>();

    </code>
</section>
<div><section class="module-info"><section id="summary">"Decodes" an <span class="mono">END OF CONTENT</span>, by which I mean: returns nothing, but
        throws exceptions if the element is not correct.
</section>
<div class="ddoc_throws">
	<h4>Throws</h4>
	<p class="para">
		<ul>            <li><code class="d inline">ASN1ConstructionException</code> if the element is marked as "constructed"</li>
            <li><code class="d inline">ASN1ValueSizeException</code> if there are any content octets</li>
        </ul>
	</p>
</div></section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.boolean" id="CanonicalEncodingRulesElement.boolean"><code class="member">boolean</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.boolean"></span>const @property @safe bool <code class="code">boolean</code>();

    </code>
</section>
<div><section class="module-info"><section id="summary">Decodes a <code class="d inline">bool</code>.
</section>
<div class="description">A <code class="d inline">0xFF</code> byte will be interpreted as <span class="mono">TRUE</span>. A zero byte
        (<code class="d inline">0x00</code>) will be interpreted as <span class="mono">FALSE</span>. Any other value,
        or any length other than 1 byte will throw an exception.

</div>
<div class="ddoc_throws">
	<h4>Throws</h4>
	<p class="para">
		<ul>            <li><code class="d inline">ASN1ConstructionException</code>
                if the encoded value is not primitively-constructed</li>
            <li><code class="d inline">ASN1ValueSizeException</code>
                if the encoded value is not exactly 1 byte in size</li>
            <li><code class="d inline">ASN1ValueException</code>
                if the encoded value is not either 0xFF or 0x00</li>
        </ul>
	</p>
</div></section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.boolean" id="CanonicalEncodingRulesElement.boolean"><code class="member">boolean</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.boolean.2"></span>nothrow @property @safe void <code class="code">boolean</code>(in bool <code class="code">value</code>);

    </code>
</section>
<div><section class="module-info"><section id="summary">Encodes a <code class="d inline">bool</code></section>
<div class="ddoc_examples">
	<h4>Examples</h4>
	<p class="para">
		<pre><code class="d block">CERElement cv = new CERElement();
cv.value = [ 0xFFu ];
assert(cv.boolean == true);
cv.value = [ 0x00u ];
assert(cv.boolean == false);
cv.value = [ 0x01u, 0x00u ];
assertThrown!ASN1ValueSizeException(cv.boolean);
cv.value = [];
assertThrown!ASN1ValueSizeException(cv.boolean);
cv.value = [ 0x01u ];
assertThrown!ASN1ValueException(cv.boolean);
</code></pre>

	</p>
</div></section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.integer" id="CanonicalEncodingRulesElement.integer"><code class="member">integer</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.integer"></span>const @property @system T <code class="code">integer</code>(T)() if (isIntegral!T &amp;&amp; isSigned!T);

    </code>
</section>
<div><section class="module-info"><section id="summary">Decodes a signed <code class="code">integer</code>.
</section>
<div class="ddoc_throws">
	<h4>Throws</h4>
	<p class="para">
		<ul>            <li><code class="d inline">ASN1ConstructionException</code>
                if the encoded value is not primitively-constructed</li>
            <li><code class="d inline">ASN1ValueSizeException</code>
                if the value is too big to decode to a signed integral type,
                or if the value is zero bytes</li>
            <li><code class="d inline">ASN1ValuePaddingException</code>
                if there are padding bytes</li>
        </ul>
	</p>
</div></section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.integer" id="CanonicalEncodingRulesElement.integer"><code class="member">integer</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.integer.2"></span>nothrow @property @system void <code class="code">integer</code>(T)(in T <code class="code">value</code>) if (isIntegral!T &amp;&amp; isSigned!T);

    </code>
</section>
<div><section class="module-info"><section id="summary">Encodes a signed integral type</section>
</section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.bitString" id="CanonicalEncodingRulesElement.bitString"><code class="member">bitString</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.bitString"></span>const @property @system bool[] <code class="code">bitString</code>();

    </code>
</section>
<div><section class="module-info"><section id="summary">Decodes an array of <code class="d inline">bool</code>s representing a string of bits.
</section>
<div class="ddoc_returns">
	<h4>Return Value</h4>
	<p class="para">
		an array of <code class="d inline">bool</code>s, where each <code class="d inline">bool</code> represents a bit
            in the encoded bit string


	</p>
</div>
<div class="ddoc_throws">
	<h4>Throws</h4>
	<p class="para">
		<ul>            <li><code class="d inline">ASN1ValueSizeException</code>
                if the any primitive contains 0 bytes</li>
            <li><code class="d inline">ASN1ValueException</code>
                if the first byte has a value greater
                than seven, or if the first byte indicates the presence of
                padding bits when no subsequent bytes exist, or if any primitive
                but the last in a constructed BIT STRING uses padding bits, or
                if any of the padding bits are set</li>
            <li><code class="d inline">ASN1RecursionException</code>
                if using constructed form and the element
                is constructed of too many nested constructed elements</li>
            <li><code class="d inline">ASN1TagClassException</code>
                if any nested primitives do not share the
                same tag class as their outer constructed element</li>
            <li><code class="d inline">ASN1TagNumberException</code>
                if any nested primitives do not share the
                same tag number as their outer constructed element</li>
        </ul>
	</p>
</div></section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.bitString" id="CanonicalEncodingRulesElement.bitString"><code class="member">bitString</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.bitString.2"></span>@property @system void <code class="code">bitString</code>(in bool[] <code class="code">value</code>);

    </code>
</section>
<div><section class="module-info"><section id="summary">Encodes an array of <code class="d inline">bool</code>s representing a string of bits.</section>
</section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.octetString" id="CanonicalEncodingRulesElement.octetString"><code class="member">octetString</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.octetString"></span>const @property @system ubyte[] <code class="code">octetString</code>();

    </code>
</section>
<div><section class="module-info"><section id="summary">Decodes an <span class="mono">OCTET STRING</span> into an unsigned byte array.
</section>
<div class="ddoc_throws">
	<h4>Throws</h4>
	<p class="para">
		<ul>            <li><code class="d inline">ASN1RecursionException</code>
                if using constructed form and the element
                is constructed of too many nested constructed elements</li>
            <li><code class="d inline">ASN1TagClassException</code>
                if any nested primitives do not share the
                same tag class as their outer constructed element</li>
            <li><code class="d inline">ASN1TagNumberException</code>
                if any nested primitives do not share the
                same tag number as their outer constructed element</li>
        </ul>
	</p>
</div></section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.octetString" id="CanonicalEncodingRulesElement.octetString"><code class="member">octetString</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.octetString.2"></span>@property @system void <code class="code">octetString</code>(in ubyte[] <code class="code">value</code>);

    </code>
</section>
<div><section class="module-info"><section id="summary">Encodes an <span class="mono">OCTET STRING</span> from an unsigned byte (<code class="d inline">ubyte</code>) array.</section>
</section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.nill" id="CanonicalEncodingRulesElement.nill"><code class="member">nill</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.nill"></span>const @property @safe void <code class="code">nill</code>();

    </code>
</section>
<div><section class="module-info"><section id="summary">"Decodes" a <code class="d inline"><code class="code">null</code></code>, by which I mean: returns nothing, but
        throws exceptions if the element is not correct.
</section>
<div class="ddoc_section">
	<p class="para">
		<span class="ddoc_section_h">Note:</span>
I had to name this method <code class="d inline"><code class="code">nill</code></code>, because <code class="d inline"><code class="code">null</code></code> is a keyword in D.


	</p>
</div>
<div class="ddoc_throws">
	<h4>Throws</h4>
	<p class="para">
		<ul>            <li><code class="d inline">ASN1ConstructionException</code> if the element is marked as "constructed"</li>
            <li><code class="d inline">ASN1ValueSizeException</code> if there are any content octets</li>
        </ul>
	</p>
</div></section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.objectIdentifier" id="CanonicalEncodingRulesElement.objectIdentifier"><code class="member">objectIdentifier</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.objectIdentifier"></span>const @property @system OID <code class="code">objectIdentifier</code>();

    </code>
</section>
<div><section class="module-info"><section id="summary">Decodes an <span class="mono">OBJECT IDENTIFIER</span>.
        See <span class="mono">source/types/universal/objectidentifier.d</span> for information about
        the <code class="d inline">ObjectIdentifier</code> class (aliased as <code class="d inline">OID</code>).
</section>
<div class="ddoc_throws">
	<h4>Throws</h4>
	<p class="para">
		<ul>            <li><code class="d inline">ASN1ConstructionException</code> if the element is marked as "constructed"</li>
            <li><code class="d inline">ASN1ValueSizeException</code> if there are no value bytes</li>
            <li><code class="d inline">ASN1ValuePaddingException</code> if a single OID number is encoded with
                "leading zero bytes" (<code class="d inline">0x80u</code>)</li>
            <li><code class="d inline">ASN1ValueOverflowException</code> if a single OID number is too big to
                decode to a <code class="d inline">size_t</code></li>
            <li><code class="d inline">ASN1TruncationException</code> if a single OID number is "cut off"</li>
        </ul>


	</p>
</div><div class="ddoc_standards">
	<h4>Standards</h4>
	<p class="para">
		<ul>            <li><a href="http://www.itu.int/rec/T-REC-X.660-201107-I/en">X.660</a></li>
        </ul>
	</p>
</div></section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.objectIdentifier" id="CanonicalEncodingRulesElement.objectIdentifier"><code class="member">objectIdentifier</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.objectIdentifier.2"></span>@property @system void <code class="code">objectIdentifier</code>(in OID <code class="code">value</code>);

    </code>
</section>
<div><section class="module-info"><section id="summary">Encodes an <span class="mono">OBJECT IDENTIFIER</span>.
        See <span class="mono">source/types/universal/objectidentifier.d</span> for information about
        the <code class="d inline">ObjectIdentifier</code> class (aliased as ).
</section>
<div class="ddoc_standards">
	<h4>Standards</h4>
	<p class="para">
		<ul>            <li><a href="http://www.itu.int/rec/T-REC-X.660-201107-I/en">X.660</a></li>
        </ul>
	</p>
</div></section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.objectDescriptor" id="CanonicalEncodingRulesElement.objectDescriptor"><code class="member">objectDescriptor</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.objectDescriptor"></span>const @property @system string <code class="code">objectDescriptor</code>();

    </code>
</section>
<div><section class="module-info"><section id="summary">Decodes an <code class="d inline">ObjectDescriptor</code>, which is a string consisting of only
        graphical characters. In fact, <code class="d inline">ObjectDescriptor</code> is actually implicitly
        just a <span class="mono">GraphicString</span>! The formal specification for an <code class="d inline">ObjectDescriptor</code>
        is:
</section>
<div class="description"><span class="mono">ObjectDescriptor ::= [UNIVERSAL 7] IMPLICIT GraphicString</span>
<br><br>
        <span class="mono">GraphicString</span> is just a string containing only characters between
        and including <code class="d inline">0x20</code> and <code class="d inline">0x7E</code>, therefore ObjectDescriptor is just
        <code class="d inline">0x20</code> and <code class="d inline">0x7E</code>.

</div>
<div class="ddoc_throws">
	<h4>Throws</h4>
	<p class="para">
		<ul>            <li><code class="d inline">ASN1ValueCharactersException</code>
                if the encoded value contains any character outside of
                <code class="d inline">0x20</code> to <code class="d inline">0x7E</code>, which means any control characters or <span class="mono">DELETE</span></li>
            <li><code class="d inline">ASN1RecursionException</code>
                if using constructed form and the element
                is constructed of too many nested constructed elements</li>
            <li><code class="d inline">ASN1TagClassException</code>
                if any nested primitives do not share the
                same tag class as their outer constructed element</li>
            <li><code class="d inline">ASN1TagNumberException</code>
                if any nested primitives do not share the
                same tag number as their outer constructed element</li>
        </ul>


	</p>
</div><div class="ddoc_section">
	<p class="para">
		<span class="ddoc_section_h">Citations:</span>
<ul>            <li>Dubuisson, Olivier. “Basic Encoding Rules (BER).”
                <i>ASN.1: Communication between Heterogeneous Systems</i>,
                Morgan Kaufmann, 2001, pp. 175-178.</li>
            <li><a href="https://en.wikipedia.org/wiki/ISO/IEC_2022">The Wikipedia Page on ISO 2022</a></li>
            <li><a href="https://www.iso.org/standard/22747.html">ISO 2022</a></li>
        </ul>
	</p>
</div>
</section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.objectDescriptor" id="CanonicalEncodingRulesElement.objectDescriptor"><code class="member">objectDescriptor</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.objectDescriptor.2"></span>@property @system void <code class="code">objectDescriptor</code>(in string <code class="code">value</code>);

    </code>
</section>
<div><section class="module-info"><section id="summary">Encodes an <code class="d inline">ObjectDescriptor</code>, which is a string consisting of only
        graphical characters. In fact, <code class="d inline">ObjectDescriptor</code> is actually implicitly
        just a <span class="mono">GraphicString</span>! The formal specification for an <code class="d inline">ObjectDescriptor</code>
        is:
</section>
<div class="description"><span class="mono">ObjectDescriptor ::= [UNIVERSAL 7] IMPLICIT GraphicString</span>
<br><br>
        <span class="mono">GraphicString</span> is just a string containing only characters between
        and including <code class="d inline">0x20</code> and <code class="d inline">0x7E</code>, therefore ObjectDescriptor is just
        <code class="d inline">0x20</code> and <code class="d inline">0x7E</code>.

</div>
<div class="ddoc_throws">
	<h4>Throws</h4>
	<p class="para">
		<ul>            <li><code class="d inline">ASN1ValueCharactersException</code>
                if the string <code class="code">value</code> contains any character outside of
                <code class="d inline">0x20</code> to <code class="d inline">0x7E</code>, which means any control characters or <span class="mono">DELETE</span></li>
        </ul>


	</p>
</div><div class="ddoc_section">
	<p class="para">
		<span class="ddoc_section_h">Citations:</span>
<ul>            <li>Dubuisson, Olivier. “Basic Encoding Rules (BER).”
                <i>ASN.1: Communication between Heterogeneous Systems</i>,
                Morgan Kaufmann, 2001, pp. 175-178.</li>
            <li><a href="https://en.wikipedia.org/wiki/ISO/IEC_2022">The Wikipedia Page on ISO 2022</a></li>
            <li><a href="https://www.iso.org/standard/22747.html">ISO 2022</a></li>
        </ul>
	</p>
</div>
</section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.external" id="CanonicalEncodingRulesElement.external"><code class="member">external</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.external"></span>deprecated const @property @system External <code class="code">external</code>();

    </code>
</section>
<div><section class="module-info"><section id="summary">Decodes an <span class="mono">EXTERNAL</span>.
</section>
<div class="description">According to the
        <a href="http://www.itu.int/en/pages/default.aspx">International Telecommunications Union</a>'s
        <a href="https://www.itu.int/rec/T-REC-X.680/en">X.680 - Abstract Syntax Notation One (ASN.1)</a>,
        the abstract definition for an <span class="mono">EXTERNAL</span>, after removing the comments in the
        specification, is as follows:
<br><br>
        <pre>            EXTERNAL ::= [UNIVERSAL 8] SEQUENCE {
                identification CHOICE {
                    syntaxes SEQUENCE {
                        abstract OBJECT IDENTIFIER,
                        transfer OBJECT IDENTIFIER },
                    syntax OBJECT IDENTIFIER,
                    presentation-context-id INTEGER,
                    context-negotiation SEQUENCE {
                        presentation-context-id INTEGER,
                        transfer-syntax OBJECT IDENTIFIER },
                    transfer-syntax OBJECT IDENTIFIER,
                    fixed NULL },
                data-value-descriptor ObjectDescriptor OPTIONAL,
                data-value OCTET STRING }
                    ( WITH COMPONENTS {
                        ... ,
                        identification ( WITH COMPONENTS {
                            ... ,
                            syntaxes ABSENT,
                            transfer-syntax ABSENT,
                            fixed ABSENT } ) } )
        </pre>
<br><br>
        Note that the abstract syntax resembles that of <span class="mono">EMBEDDED PDV</span> and
        <span class="mono">CharacterString</span>, except with a <span class="mono">WITH COMPONENTS</span> constraint that removes some
        of our choices of <span class="mono">identification</span>.
        As can be seen on page 303 of Olivier Dubuisson's
        <i><a href="http://www.oss.com/asn1/resources/books-whitepapers-pubs/dubuisson-asn1-book.PDF">            ASN.1: Communication Between Heterogeneous Systems</a></i>,
        after applying the <span class="mono">WITH COMPONENTS</span> constraint, our reduced syntax becomes:
<br><br>
        <pre>            EXTERNAL ::= [UNIVERSAL 8] IMPLICIT SEQUENCE {
                identification CHOICE {
                    syntax OBJECT IDENTIFIER,
                    presentation-context-id INTEGER,
                    context-negotiation SEQUENCE {
                        presentation-context-id INTEGER,
                        transfer-syntax OBJECT IDENTIFIER } },
                data-value-descriptor ObjectDescriptor OPTIONAL,
                data-value OCTET STRING }
        </pre>
<br><br>
        But, according to the
        <a href="http://www.itu.int/en/pages/default.aspx">International Telecommunications Union</a>'s
        <a href="http://www.itu.int/rec/T-REC-X.690/en">X.690 - ASN.1 encoding rules</a>,
        section 8.18, when encoded using Basic Encoding Rules (BER), is encoded as
        follows, for compatibility reasons:
<br><br>
        <pre>            EXTERNAL ::= [UNIVERSAL 8] IMPLICIT SEQUENCE {
                direct-reference  OBJECT IDENTIFIER OPTIONAL,
                indirect-reference  INTEGER OPTIONAL,
                data-value-descriptor  ObjectDescriptor  OPTIONAL,
                encoding  CHOICE {
                    single-ASN1-type  [0] ANY,
                    octet-aligned     [1] IMPLICIT OCTET STRING,
                    arbitrary         [2] IMPLICIT BIT STRING } }
        </pre>
<br><br>
        The definition above is the pre-1994 definition of <span class="mono">EXTERNAL</span>. The <span class="mono">syntax</span>
        field of the post-1994 definition maps to the <span class="mono">direct-reference</span> field of
        the pre-1994 definition. The <span class="mono">presentation-context-id</span> field of the post-1994
        definition maps to the <span class="mono">indirect-reference</span> field of the pre-1994 definition.
        If <span class="mono">context-negotiation</span> is used, per the abstract syntax, then the
        <span class="mono">presentation-context-id</span> field of the <span class="mono">context-negotiation</span> <span class="mono">SEQUENCE</span> in the
        post-1994 definition maps to the <span class="mono">indirect-reference</span> field of the pre-1994
        definition, and the <span class="mono">transfer-syntax</span> field of the <span class="mono">context-negotiation</span>
        <span class="mono">SEQUENCE</span> maps to the <span class="mono">direct-reference</span> field of the pre-1994 definition.
<br><br>
        The following additional constraints are applied to the abstract syntax
        when using Canonical Encoding Rules or Distinguished Encoding Rules,
        which are also defined in the
        <a href="http://www.itu.int/en/pages/default.aspx">        International Telecommunications Union</a>'s
        <a href="http://www.itu.int/rec/T-REC-X.690/en">X.690 - ASN.1 encoding rules</a>:
<br><br>
        <pre>            EXTERNAL ( WITH COMPONENTS {
                ... ,
                identification ( WITH COMPONENTS {
                    ... ,
                    presentation-context-id ABSENT,
                    context-negotiation ABSENT } ) } )
        </pre>
<br><br>
        The stated purpose of the constraints shown above is to restrict the use of
        the <span class="mono">presentation-context-id</span>, either by itself or within the
        <span class="mono">context-negotiation</span>, which makes the following the effective abstract
        syntax of <span class="mono">EXTERNAL</span> when using Canonical Encoding Rules or
        Distinguished Encoding Rules:
<br><br>
        <pre>            EXTERNAL ::= [UNIVERSAL 8] SEQUENCE {
                identification CHOICE {
                    syntaxes SEQUENCE {
                        abstract OBJECT IDENTIFIER,
                        transfer OBJECT IDENTIFIER },
                    syntax OBJECT IDENTIFIER,
                    presentation-context-id INTEGER,
                    context-negotiation SEQUENCE {
                        presentation-context-id INTEGER,
                        transfer-syntax OBJECT IDENTIFIER },
                    transfer-syntax OBJECT IDENTIFIER,
                    fixed NULL },
                data-value-descriptor ObjectDescriptor OPTIONAL,
                data-value OCTET STRING }
                    ( WITH COMPONENTS {
                        ... ,
                        identification ( WITH COMPONENTS {
                            ... ,
                            syntaxes ABSENT,
                            presentation-context-id ABSENT,
                            context-negotiation ABSENT,
                            transfer-syntax ABSENT,
                            fixed ABSENT } ) } )
        </pre>
<br><br>
        With the constraints applied, the abstract syntax for <span class="mono">EXTERNAL</span>s encoded
        using Canonical Encoding Rules or Distinguished Encoding Rules becomes:
<br><br>
        <pre>            EXTERNAL ::= [UNIVERSAL 8] SEQUENCE {
                identification CHOICE {
                    syntax OBJECT IDENTIFIER },
                data-value-descriptor ObjectDescriptor OPTIONAL,
                data-value OCTET STRING }
        </pre>
<br><br>
        Upon removing the <span class="mono">CHOICE</span> tag (since you have no choice but to use syntax
        at this point), the encoding definition when using
        Canonical Encoding Rules or Distinguished Encoding Rules:
<br><br>
        <pre>            EXTERNAL ::= [UNIVERSAL 8] SEQUENCE {
                syntax OBJECT IDENTIFIER,
                data-value-descriptor ObjectDescriptor OPTIONAL,
                data-value OCTET STRING }
        </pre>

</div>
<div class="ddoc_returns">
	<h4>Return Value</h4>
	<p class="para">
		an instance of <code class="d inline">types.universal.<code class="code">external</code>.External</code>


	</p>
</div>
<div class="ddoc_throws">
	<h4>Throws</h4>
	<p class="para">
		<ul>            <li><code class="d inline">ASN1ValueException</code>
                if the SEQUENCE does not contain two to four elements</li>
            <li><code class="d inline">ASN1RecursionException</code>
                if using constructed form and the element
                is constructed of too many nested constructed elements</li>
            <li><code class="d inline">ASN1TagClassException</code>
                if any nested primitives do not have the correct tag class</li>
            <li><code class="d inline">ASN1ConstructionException</code>
                if any element has the wrong construction</li>
            <li><code class="d inline">ASN1TagNumberException</code>
                if any nested primitives do not have the correct tag number</li>
            <li><code class="d inline">ASN1ValueCharactersException</code>
                if a data-value-descriptor is supplied with invalid characters</li>
        </ul>
	</p>
</div></section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.external" id="CanonicalEncodingRulesElement.external"><code class="member">external</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.external.2"></span>deprecated @property @system void <code class="code">external</code>(in External <code class="code">value</code>);

    </code>
</section>
<div><section class="module-info"><section id="summary">Encodes an <span class="mono">EXTERNAL</span>.
</section>
<div class="description">According to the
        <a href="http://www.itu.int/en/pages/default.aspx">International Telecommunications Union</a>'s
        <a href="https://www.itu.int/rec/T-REC-X.680/en">X.680 - Abstract Syntax Notation One (ASN.1)</a>,
        the abstract definition for an <span class="mono">EXTERNAL</span>, after removing the comments in the
        specification, is as follows:
<br><br>
        <pre>            EXTERNAL ::= [UNIVERSAL 8] SEQUENCE {
                identification CHOICE {
                    syntaxes SEQUENCE {
                        abstract OBJECT IDENTIFIER,
                        transfer OBJECT IDENTIFIER },
                    syntax OBJECT IDENTIFIER,
                    presentation-context-id INTEGER,
                    context-negotiation SEQUENCE {
                        presentation-context-id INTEGER,
                        transfer-syntax OBJECT IDENTIFIER },
                    transfer-syntax OBJECT IDENTIFIER,
                    fixed NULL },
                data-<code class="code">value</code>-descriptor ObjectDescriptor OPTIONAL,
                data-<code class="code">value</code> OCTET STRING }
                    ( WITH COMPONENTS {
                        ... ,
                        identification ( WITH COMPONENTS {
                            ... ,
                            syntaxes ABSENT,
                            transfer-syntax ABSENT,
                            fixed ABSENT } ) } )
        </pre>
<br><br>
        Note that the abstract syntax resembles that of <span class="mono">EMBEDDED PDV</span> and
        <span class="mono">CharacterString</span>, except with a <span class="mono">WITH COMPONENTS</span> constraint that removes some
        of our choices of <span class="mono">identification</span>.
        As can be seen on page 303 of Olivier Dubuisson's
        <i><a href="http://www.oss.com/asn1/resources/books-whitepapers-pubs/dubuisson-asn1-book.PDF">            ASN.1: Communication Between Heterogeneous Systems</a></i>,
        after applying the <span class="mono">WITH COMPONENTS</span> constraint, our reduced syntax becomes:
<br><br>
        <pre>            EXTERNAL ::= [UNIVERSAL 8] IMPLICIT SEQUENCE {
                identification CHOICE {
                    syntax OBJECT IDENTIFIER,
                    presentation-context-id INTEGER,
                    context-negotiation SEQUENCE {
                        presentation-context-id INTEGER,
                        transfer-syntax OBJECT IDENTIFIER } },
                data-<code class="code">value</code>-descriptor ObjectDescriptor OPTIONAL,
                data-<code class="code">value</code> OCTET STRING }
        </pre>
<br><br>
        But, according to the
        <a href="http://www.itu.int/en/pages/default.aspx">International Telecommunications Union</a>'s
        <a href="http://www.itu.int/rec/T-REC-X.690/en">X.690 - ASN.1 encoding rules</a>,
        section 8.18, when encoded using Basic Encoding Rules (BER), is encoded as
        follows, for compatibility reasons:
<br><br>
        <pre>            EXTERNAL ::= [UNIVERSAL 8] IMPLICIT SEQUENCE {
                direct-reference  OBJECT IDENTIFIER OPTIONAL,
                indirect-reference  INTEGER OPTIONAL,
                data-<code class="code">value</code>-descriptor  ObjectDescriptor  OPTIONAL,
                encoding  CHOICE {
                    single-ASN1-type  [0] ANY,
                    octet-aligned     [1] IMPLICIT OCTET STRING,
                    arbitrary         [2] IMPLICIT BIT STRING } }
        </pre>
<br><br>
        The definition above is the pre-1994 definition of <span class="mono">EXTERNAL</span>. The <span class="mono">syntax</span>
        field of the post-1994 definition maps to the <span class="mono">direct-reference</span> field of
        the pre-1994 definition. The <span class="mono">presentation-context-id</span> field of the post-1994
        definition maps to the <span class="mono">indirect-reference</span> field of the pre-1994 definition.
        If <span class="mono">context-negotiation</span> is used, per the abstract syntax, then the
        <span class="mono">presentation-context-id</span> field of the <span class="mono">context-negotiation</span> <span class="mono">SEQUENCE</span> in the
        post-1994 definition maps to the <span class="mono">indirect-reference</span> field of the pre-1994
        definition, and the <span class="mono">transfer-syntax</span> field of the <span class="mono">context-negotiation</span>
        <span class="mono">SEQUENCE</span> maps to the <span class="mono">direct-reference</span> field of the pre-1994 definition.
<br><br>
        The following additional constraints are applied to the abstract syntax
        when using Canonical Encoding Rules or Distinguished Encoding Rules,
        which are also defined in the
        <a href="http://www.itu.int/en/pages/default.aspx">        International Telecommunications Union</a>'s
        <a href="http://www.itu.int/rec/T-REC-X.690/en">X.690 - ASN.1 encoding rules</a>:
<br><br>
        <pre>            EXTERNAL ( WITH COMPONENTS {
                ... ,
                identification ( WITH COMPONENTS {
                    ... ,
                    presentation-context-id ABSENT,
                    context-negotiation ABSENT } ) } )
        </pre>
<br><br>
        The stated purpose of the constraints shown above is to restrict the use of
        the <span class="mono">presentation-context-id</span>, either by itself or within the
        <span class="mono">context-negotiation</span>, which makes the following the effective abstract
        syntax of <span class="mono">EXTERNAL</span> when using Canonical Encoding Rules or
        Distinguished Encoding Rules:
<br><br>
        <pre>            EXTERNAL ::= [UNIVERSAL 8] SEQUENCE {
                identification CHOICE {
                    syntaxes SEQUENCE {
                        abstract OBJECT IDENTIFIER,
                        transfer OBJECT IDENTIFIER },
                    syntax OBJECT IDENTIFIER,
                    presentation-context-id INTEGER,
                    context-negotiation SEQUENCE {
                        presentation-context-id INTEGER,
                        transfer-syntax OBJECT IDENTIFIER },
                    transfer-syntax OBJECT IDENTIFIER,
                    fixed NULL },
                data-<code class="code">value</code>-descriptor ObjectDescriptor OPTIONAL,
                data-<code class="code">value</code> OCTET STRING }
                    ( WITH COMPONENTS {
                        ... ,
                        identification ( WITH COMPONENTS {
                            ... ,
                            syntaxes ABSENT,
                            presentation-context-id ABSENT,
                            context-negotiation ABSENT,
                            transfer-syntax ABSENT,
                            fixed ABSENT } ) } )
        </pre>
<br><br>
        With the constraints applied, the abstract syntax for <span class="mono">EXTERNAL</span>s encoded
        using Canonical Encoding Rules or Distinguished Encoding Rules becomes:
<br><br>
        <pre>            EXTERNAL ::= [UNIVERSAL 8] SEQUENCE {
                identification CHOICE {
                    syntax OBJECT IDENTIFIER },
                data-<code class="code">value</code>-descriptor ObjectDescriptor OPTIONAL,
                data-<code class="code">value</code> OCTET STRING }
        </pre>
<br><br>
        Upon removing the <span class="mono">CHOICE</span> tag (since you have no choice but to use syntax
        at this point), the encoding definition when using
        Canonical Encoding Rules or Distinguished Encoding Rules:
<br><br>
        <pre>            EXTERNAL ::= [UNIVERSAL 8] SEQUENCE {
                syntax OBJECT IDENTIFIER,
                data-<code class="code">value</code>-descriptor ObjectDescriptor OPTIONAL,
                data-<code class="code">value</code> OCTET STRING }
        </pre>

</div>
<div class="ddoc_returns">
	<h4>Return Value</h4>
	<p class="para">
		an instance of <code class="d inline">types.universal.<code class="code">external</code>.External</code>


	</p>
</div>
<div class="ddoc_throws">
	<h4>Throws</h4>
	<p class="para">
		<ul>            <li><code class="d inline">ASN1ValueException</code>
                if something other than <code class="d inline">syntax</code> is used for <span class="mono">identification</span></li>
            <li><code class="d inline">ASN1ValueCharactersException</code>
                if a data-<code class="code">value</code>-descriptor is supplied with invalid characters</li>
        </ul>
	</p>
</div></section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.realNumber" id="CanonicalEncodingRulesElement.realNumber"><code class="member">realNumber</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.realNumber"></span>const @property @system T <code class="code">realNumber</code>(T)() if (isFloatingPoint!T);

    </code>
</section>
<div><section class="module-info"><section id="summary">Decodes a floating-point type.
</section>
<div class="description">For the encoded REAL, a value of 0x40 means "positive infinity,"
        a value of 0x41 means "negative infinity." An empty value means
        exactly zero. A value whose first byte starts with two cleared bits
        encodes the real as a string of characters, where the latter nybble
        takes on values of 0x1, 0x2, or 0x3 to indicate that the string
        representation conforms to
        <a href="https://www.iso.org/standard/12285.html">ISO 6093</a>
        Numeric Representation 1, 2, or 3 respectively.
<br><br>
        If the first bit is set, then the first byte is an "information block"
        that describes the binary encoding of the REAL on the subsequent bytes.
        If bit 6 is set, the value is negative; if clear, the value is
        positive. Bits 4 and 5 determine the base, with a value of 0 indicating
        a base of 2, a value of 1 indicating a base of 8, and a value of 2
        indicating a base of 16. Bits 2 and 3 indicates that the value should
        be scaled by 1, 2, 4, or 8 for values of 1, 2, 3, or 4 respectively.
        Bits 0 and 1 determine how the exponent is encoded, with 0 indicating
        that the exponent is encoded as a signed byte on the second byte of
        the value, with 1 indicating that the exponent is encoded as a signed
        short on the subsequent two bytes, with 2 indicating that the exponent
        is encoded as a three-byte signed integer on the subsequent three
        bytes, and with 4 indicating that the subsequent byte encodes the
        unsigned length of the exponent on the following bytes. The remaining
        bytes encode an unsigned integer, N, such that mantissa is equal to
        sign * N * 2^scale.
<br><br>
        Note that this method assumes that your machine uses IEEE 754 floating
        point format.
<br><br>
        If you attempt to decode a REAL that is too big to fit into the selected
        floating point type, the value of the real will quietly set to zero. This
        cannot happen if the transmitted value is in base-2, but it can happen if
        the transmitted value is in base-8 or base-16.

</div>
<div class="ddoc_throws">
	<h4>Throws</h4>
	<p class="para">
		ConvException = if character-encoding cannot be converted to
                the selected floating-point type, T.
            ConvOverflowException = if the character-encoding encodes a
                number that is too big for the selected floating-point
                type to express.
            ASN1ValueSizeException = if the binary-encoding contains fewer
                bytes than the information byte purports.
            ASN1ValueSizeException = if the binary-encoded mantissa is too
                big to be expressed by an unsigned long integer.
            ASN1ValueException = if both bits indicating the base in the
                information byte of a binary-encoded REAL's information byte
                are set, which would indicate an invalid base.
	</p>
</div></section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.realNumber" id="CanonicalEncodingRulesElement.realNumber"><code class="member">realNumber</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.realNumber.2"></span>@property @system void <code class="code">realNumber</code>(T)(in T <code class="code">value</code>) if (isFloatingPoint!T);

    </code>
</section>
<div><section class="module-info"><section id="summary">Encodes a floating-point type.
</section>
<div class="description">For the encoded REAL, a <code class="code">value</code> of 0x40 means "positive infinity,"
        a <code class="code">value</code> of 0x41 means "negative infinity." An empty <code class="code">value</code> means
        exactly zero. A <code class="code">value</code> whose first byte starts with two cleared bits
        encodes the real as a string of characters, where the latter nybble
        takes on values of 0x1, 0x2, or 0x3 to indicate that the string
        representation conforms to
        <a href="">ISO 6093</a> Numeric Representation 1, 2, or 3 respectively.
<br><br>
        If the first bit is set, then the first byte is an "information block"
        that describes the binary encoding of the REAL on the subsequent bytes.
        If bit 6 is set, the <code class="code">value</code> is negative; if clear, the <code class="code">value</code> is
        positive. Bits 4 and 5 determine the base, with a <code class="code">value</code> of 0 indicating
        a base of 2, a <code class="code">value</code> of 1 indicating a base of 8, and a <code class="code">value</code> of 2
        indicating a base of 16. Bits 2 and 3 indicates that the <code class="code">value</code> should
        be scaled by 1, 2, 4, or 8 for values of 1, 2, 3, or 4 respectively.
        Bits 0 and 1 determine how the exponent is encoded, with 0 indicating
        that the exponent is encoded as a signed byte on the second byte of
        the <code class="code">value</code>, with 1 indicating that the exponent is encoded as a signed
        short on the subsequent two bytes, with 2 indicating that the exponent
        is encoded as a three-byte signed integer on the subsequent three
        bytes, and with 4 indicating that the subsequent byte encodes the
        unsigned length of the exponent on the following bytes. The remaining
        bytes encode an unsigned integer, N, such that mantissa is equal to
        sign * N * 2^scale.
<br><br>
        Note that this method assumes that your machine uses IEEE 754 floating
        point format.

</div>
<div class="ddoc_throws">
	<h4>Throws</h4>
	<p class="para">
		ASN1ValueException = if an attempt to encode NaN is made.
            ASN1ValueSizeException = if an attempt to encode would result
                in an arithmetic underflow of a signed short.
            ASN1ValueSizeException = if an attempt to encode would result
                in an arithmetic overflow of a signed short.
	</p>
</div></section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.enumerated" id="CanonicalEncodingRulesElement.enumerated"><code class="member">enumerated</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.enumerated"></span>const @property @system T <code class="code">enumerated</code>(T)() if (isIntegral!T &amp;&amp; isSigned!T);

    </code>
</section>
<div><section class="module-info"><section id="summary">Decodes an integer from an ENUMERATED type. In CER, an ENUMERATED
        type is encoded the exact same way that an INTEGER is.
</section>
<div class="ddoc_returns">
	<h4>Return Value</h4>
	<p class="para">
		any chosen signed integral type

	</p>
</div>
<div class="ddoc_throws">
	<h4>Throws</h4>
	<p class="para">
		ASN1ValueSizeException = if the value is too big to decode
                to a signed integral type.
	</p>
</div></section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.enumerated" id="CanonicalEncodingRulesElement.enumerated"><code class="member">enumerated</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.enumerated.2"></span>nothrow @property @system void <code class="code">enumerated</code>(T)(in T <code class="code">value</code>);

    </code>
</section>
<div><section class="module-info"><section id="summary">Encodes an ENUMERATED type from an integer. In CER, an ENUMERATED
        type is encoded the exact same way that an INTEGER is.</section>
</section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.embeddedPresentationDataValue" id="CanonicalEncodingRulesElement.embeddedPresentationDataValue"><code class="member">embeddedPresentationDataValue</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.embeddedPresentationDataValue"></span>const @property @system EmbeddedPDV <code class="code">embeddedPresentationDataValue</code>();

    </code>
</section>
<div><section class="module-info"><section id="summary">Decodes an EMBEDDED PDV, which is a constructed data type, defined in
            the <a href="https://www.itu.int">                International Telecommunications Union</a>'s
            <a href="https://www.itu.int/rec/T-REC-X.680/en">X.680</a>.
</section>
<div class="description">The specification defines EMBEDDED PDV as:
<br><br>
        <span class="mono">            EmbeddedPDV ::= [UNIVERSAL 11] IMPLICIT SEQUENCE {
                identification CHOICE {
                    syntaxes SEQUENCE {
                        abstract OBJECT IDENTIFIER,
                        transfer OBJECT IDENTIFIER },
                    syntax OBJECT IDENTIFIER,
                    presentation-context-id INTEGER,
                    context-negotiation SEQUENCE {
                        presentation-context-id INTEGER,
                        transfer-syntax OBJECT IDENTIFIER },
                    transfer-syntax OBJECT IDENTIFIER,
                    fixed NULL },
                data-value-descriptor ObjectDescriptor OPTIONAL,
                data-value OCTET STRING }
            (WITH COMPONENTS { ... , data-value-descriptor ABSENT })
        </span>
<br><br>
        This assumes AUTOMATIC TAGS, so all of the identification choices
        will be context-specific and numbered from 0 to 5.
<br><br>
        In Canonical Encoding Rules (CER), the identification CHOICE cannot be
        presentation-context-id, nor context-negotiation. Also, the elements
        must appear in the exact order of the specification. With these
        constraints in mind, the specification effectively becomes:
<br><br>
        <span class="mono">            EmbeddedPDV ::= [UNIVERSAL 11] IMPLICIT SEQUENCE {
                identification [0] CHOICE {
                    syntaxes [0] SEQUENCE {
                        abstract [0] OBJECT IDENTIFIER,
                        transfer [1] OBJECT IDENTIFIER },
                    syntax [1] OBJECT IDENTIFIER,
                    transfer-syntax [4] OBJECT IDENTIFIER,
                    fixed [5] NULL },
                data-value [2] OCTET STRING }
        </span>

</div>
<div class="ddoc_throws">
	<h4>Throws</h4>
	<p class="para">
		ASN1SizeException = if encoded EmbeddedPDV has too few or too many
                elements, or if syntaxes or context-negotiation element has
                too few or too many elements.
            ASN1ValueSizeException = if encoded INTEGER is too large to decode.
            ASN1ValueException = if encoded ObjectDescriptor contains
                invalid characters.
            ASN1InvalidIndexException = if encoded value selects a choice for
                identification or uses an unspecified index for an element in
                syntaxes or context-negotiation, or if an unspecified element
                of EMBEDDED PDV itself is referenced by an out-of-range
                context-specific index. (See <code class="code">ASN1InvalidIndexException</code>.)
	</p>
</div></section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.embeddedPresentationDataValue" id="CanonicalEncodingRulesElement.embeddedPresentationDataValue"><code class="member">embeddedPresentationDataValue</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.embeddedPresentationDataValue.2"></span>@property @system void <code class="code">embeddedPresentationDataValue</code>(in EmbeddedPDV <code class="code">value</code>);

    </code>
</section>
<div><section class="module-info"><section id="summary">Encodes an EMBEDDED PDV, which is a constructed data type, defined in
            the <a href="https://www.itu.int">                International Telecommunications Union</a>'s
            <a href="https://www.itu.int/rec/T-REC-X.680/en">X.680</a>.
</section>
<div class="description">The specification defines EMBEDDED PDV as:
<br><br>
        <span class="mono">            EmbeddedPDV ::= [UNIVERSAL 11] IMPLICIT SEQUENCE {
                identification CHOICE {
                    syntaxes SEQUENCE {
                        abstract OBJECT IDENTIFIER,
                        transfer OBJECT IDENTIFIER },
                    syntax OBJECT IDENTIFIER,
                    presentation-context-id INTEGER,
                    context-negotiation SEQUENCE {
                        presentation-context-id INTEGER,
                        transfer-syntax OBJECT IDENTIFIER },
                    transfer-syntax OBJECT IDENTIFIER,
                    fixed NULL },
                data-<code class="code">value</code>-descriptor ObjectDescriptor OPTIONAL,
                data-<code class="code">value</code> OCTET STRING }
            (WITH COMPONENTS { ... , data-<code class="code">value</code>-descriptor ABSENT })
        </span>
<br><br>
        This assumes AUTOMATIC TAGS, so all of the identification choices
        will be context-specific and numbered from 0 to 5.
<br><br>
        In Canonical Encoding Rules (CER), the identification CHOICE cannot be
        presentation-context-id, nor context-negotiation. Also, the elements
        must appear in the exact order of the specification. With these
        constraints in mind, the specification effectively becomes:
<br><br>
        <span class="mono">            EmbeddedPDV ::= [UNIVERSAL 11] IMPLICIT SEQUENCE {
                identification [0] CHOICE {
                    syntaxes [0] SEQUENCE {
                        abstract [0] OBJECT IDENTIFIER,
                        transfer [1] OBJECT IDENTIFIER },
                    syntax [1] OBJECT IDENTIFIER,
                    transfer-syntax [4] OBJECT IDENTIFIER,
                    fixed [5] NULL },
                data-<code class="code">value</code> [2] OCTET STRING }
        </span>
<br><br>
        If the supplied identification for the EmbeddedPDV is a
        presentation-context-id or a context-negotiation, no exception will be
        thrown; the identification will be set to fixed silently.
<br><br>
        This assumes AUTOMATIC TAGS, so all of the identification choices
        will be context-specific and numbered from 0 to 5.

</div>
<div class="ddoc_throws">
	<h4>Throws</h4>
	<p class="para">
		ASN1ValueException = if encoded ObjectDescriptor contains
                invalid characters.
	</p>
</div></section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.unicodeTransformationFormat8String" id="CanonicalEncodingRulesElement.unicodeTransformationFormat8String"><code class="member">unicodeTransformationFormat8String</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.unicodeTransformationFormat8String"></span>const @property @system string <code class="code">unicodeTransformationFormat8String</code>();

    </code>
</section>
<div><section class="module-info"><section id="summary">Decodes the value to UTF-8 characters.
</section>
<div class="ddoc_throws">
	<h4>Throws</h4>
	<p class="para">
		UTF8Exception if it does not decode correctly.
	</p>
</div></section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.unicodeTransformationFormat8String" id="CanonicalEncodingRulesElement.unicodeTransformationFormat8String"><code class="member">unicodeTransformationFormat8String</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.unicodeTransformationFormat8String.2"></span>@property @system void <code class="code">unicodeTransformationFormat8String</code>(in string <code class="code">value</code>);

    </code>
</section>
<div><section class="module-info"><section id="summary">Encodes a UTF-8 string to bytes. No checks are performed.</section>
</section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.relativeObjectIdentifier" id="CanonicalEncodingRulesElement.relativeObjectIdentifier"><code class="member">relativeObjectIdentifier</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.relativeObjectIdentifier"></span>const @property @system OIDNode[] <code class="code">relativeObjectIdentifier</code>();

    </code>
</section>
<div><section class="module-info"><section id="summary">Decodes a RELATIVE OBJECT IDENTIFIER.
        See source/types/universal/objectidentifier.d for information about
        the ObjectIdentifier class (aliased as "OID").
</section>
<div class="description">The RELATIVE OBJECT IDENTIFIER's numbers are encoded in base-128
        on the least significant 7 bits of each byte. For these bytes, the most
        significant bit is set if the next byte continues the encoding of the
        current OID number. In other words, the bytes encoding each number
        always end with a byte whose most significant bit is cleared.

</div>
<div class="ddoc_standards">
	<h4>Standards</h4>
	<p class="para">
		<a href="http://www.itu.int/rec/T-REC-X.660-201107-I/en">X.660</a>
	</p>
</div></section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.relativeObjectIdentifier" id="CanonicalEncodingRulesElement.relativeObjectIdentifier"><code class="member">relativeObjectIdentifier</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.relativeObjectIdentifier.2"></span>nothrow @property @system void <code class="code">relativeObjectIdentifier</code>(in OIDNode[] <code class="code">value</code>);

    </code>
</section>
<div><section class="module-info"><section id="summary">Encodes a RELATIVE OBJECT IDENTIFIER.
        See source/types/universal/objectidentifier.d for information about
        the ObjectIdentifier class (aliased as "OID").
</section>
<div class="description">The RELATIVE OBJECT IDENTIFIER's numbers are encoded in base-128
        on the least significant 7 bits of each byte. For these bytes, the most
        significant bit is set if the next byte continues the encoding of the
        current OID number. In other words, the bytes encoding each number
        always end with a byte whose most significant bit is cleared.

</div>
<div class="ddoc_standards">
	<h4>Standards</h4>
	<p class="para">
		<a href="http://www.itu.int/rec/T-REC-X.660-201107-I/en">X.660</a>
	</p>
</div></section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.sequence" id="CanonicalEncodingRulesElement.sequence"><code class="member">sequence</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.sequence"></span>const @property @system CERElement[] <code class="code">sequence</code>();

    </code>
</section>
<div><section class="module-info"><section id="summary">Decodes a <code class="code">sequence</code> of CERElements.
</section>
<div class="ddoc_returns">
	<h4>Return Value</h4>
	<p class="para">
		an array of CERElements.

	</p>
</div>
<div class="ddoc_throws">
	<h4>Throws</h4>
	<p class="para">
		ASN1ValueSizeException = if long definite-length is too big to be
                decoded to an unsigned integral type.
            ASN1ValueSizeException = if there are fewer value bytes than
                indicated by the length tag.
	</p>
</div></section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.sequence" id="CanonicalEncodingRulesElement.sequence"><code class="member">sequence</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.sequence.2"></span>@property @system void <code class="code">sequence</code>(in CERElement[] <code class="code">value</code>);

    </code>
</section>
<div><section class="module-info"><section id="summary">Encodes a <code class="code">sequence</code> of CERElements.</section>
</section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.set" id="CanonicalEncodingRulesElement.set"><code class="member">set</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.set"></span>const @property @system CERElement[] <code class="code">set</code>();

    </code>
</section>
<div><section class="module-info"><section id="summary">Decodes a <code class="code">set</code> of CERElements.
</section>
<div class="ddoc_returns">
	<h4>Return Value</h4>
	<p class="para">
		an array of CERElements.

	</p>
</div>
<div class="ddoc_throws">
	<h4>Throws</h4>
	<p class="para">
		ASN1ValueSizeException = if long definite-length is too big to be
                decoded to an unsigned integral type.
            ASN1ValueSizeException = if there are fewer value bytes than
                indicated by the length tag.
	</p>
</div></section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.set" id="CanonicalEncodingRulesElement.set"><code class="member">set</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.set.2"></span>@property @system void <code class="code">set</code>(in CERElement[] <code class="code">value</code>);

    </code>
</section>
<div><section class="module-info"><section id="summary">Encodes a <code class="code">set</code> of CERElements.</section>
</section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.numericString" id="CanonicalEncodingRulesElement.numericString"><code class="member">numericString</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.numericString"></span>const @property @system string <code class="code">numericString</code>();

    </code>
</section>
<div><section class="module-info"><section id="summary">Decodes a string, where the characters of the string are limited to
        0 - 9 and space.
</section>
<div class="ddoc_returns">
	<h4>Return Value</h4>
	<p class="para">
		a string.

	</p>
</div>
<div class="ddoc_throws">
	<h4>Throws</h4>
	<p class="para">
		ASN1ValueException = if any character other than 0-9 or
                space is encoded.
	</p>
</div></section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.numericString" id="CanonicalEncodingRulesElement.numericString"><code class="member">numericString</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.numericString.2"></span>@property @system void <code class="code">numericString</code>(in string <code class="code">value</code>);

    </code>
</section>
<div><section class="module-info"><section id="summary">Encodes a string, where the characters of the string are limited to
        0 - 9 and space.
</section>
<div class="ddoc_throws">
	<h4>Throws</h4>
	<p class="para">
		ASN1ValueException = if any character other than 0-9 or
                space is supplied.
	</p>
</div></section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.printableString" id="CanonicalEncodingRulesElement.printableString"><code class="member">printableString</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.printableString"></span>const @property @system string <code class="code">printableString</code>();

    </code>
</section>
<div><section class="module-info"><section id="summary">Decodes a string that will only contain characters a-z, A-Z, 0-9,
        space, apostrophe, parentheses, comma, minus, plus, period,
        forward slash, colon, equals, and question mark.
</section>
<div class="ddoc_returns">
	<h4>Return Value</h4>
	<p class="para">
		a string.

	</p>
</div>
<div class="ddoc_throws">
	<h4>Throws</h4>
	<p class="para">
		ASN1ValueException = if any character other than a-z, A-Z,
                0-9, space, apostrophe, parentheses, comma, minus, plus,
                period, forward slash, colon, equals, or question mark are
                encoded.
	</p>
</div></section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.printableString" id="CanonicalEncodingRulesElement.printableString"><code class="member">printableString</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.printableString.2"></span>@property @system void <code class="code">printableString</code>(in string <code class="code">value</code>);

    </code>
</section>
<div><section class="module-info"><section id="summary">Encodes a string that may only contain characters a-z, A-Z, 0-9,
        space, apostrophe, parentheses, comma, minus, plus, period,
        forward slash, colon, equals, and question mark.
</section>
<div class="ddoc_throws">
	<h4>Throws</h4>
	<p class="para">
		ASN1ValueException = if any character other than a-z, A-Z,
                0-9, space, apostrophe, parentheses, comma, minus, plus,
                period, forward slash, colon, equals, or question mark are
                supplied.
	</p>
</div></section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.teletexString" id="CanonicalEncodingRulesElement.teletexString"><code class="member">teletexString</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.teletexString"></span>const @property @system ubyte[] <code class="code">teletexString</code>();

    </code>
</section>
<div><section class="module-info"><section id="summary">Literally just returns the value bytes.
</section>
<div class="ddoc_returns">
	<h4>Return Value</h4>
	<p class="para">
		an unsigned byte array, where each byte is a T.61 character.
	</p>
</div>
</section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.teletexString" id="CanonicalEncodingRulesElement.teletexString"><code class="member">teletexString</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.teletexString.2"></span>@property @system void <code class="code">teletexString</code>(in ubyte[] <code class="code">value</code>);

    </code>
</section>
<div><section class="module-info"><section id="summary">Literally just sets the <code class="code">value</code> bytes.</section>
</section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.videotexString" id="CanonicalEncodingRulesElement.videotexString"><code class="member">videotexString</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.videotexString"></span>const @property @system ubyte[] <code class="code">videotexString</code>();

    </code>
</section>
<div><section class="module-info"><section id="summary">Literally just returns the value bytes.
</section>
<div class="ddoc_returns">
	<h4>Return Value</h4>
	<p class="para">
		an unsigned byte array.
	</p>
</div>
</section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.videotexString" id="CanonicalEncodingRulesElement.videotexString"><code class="member">videotexString</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.videotexString.2"></span>@property @system void <code class="code">videotexString</code>(in ubyte[] <code class="code">value</code>);

    </code>
</section>
<div><section class="module-info"><section id="summary">Literally just sets the <code class="code">value</code> bytes.</section>
</section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.internationalAlphabetNumber5String" id="CanonicalEncodingRulesElement.internationalAlphabetNumber5String"><code class="member">internationalAlphabetNumber5String</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.internationalAlphabetNumber5String"></span>const @property @system string <code class="code">internationalAlphabetNumber5String</code>();

    </code>
</section>
<div><section class="module-info"><section id="summary">Decodes a string that only contains ASCII characters.
</section>
<div class="description">IA5String differs from ASCII ever so slightly: IA5 is international,
        leaving 10 characters up to be locale-specific:
<br><br>
        <table>            <tr><th>Byte</th> <th>ASCII Character</th></tr>
            <tr><td>0x40</td> <td>@</td></tr>
            <tr><td>0x5B</td> <td>[</td></tr>
            <tr><td>0x5C</td> <td>\</td></tr>
            <tr><td>0x5D</td> <td>]</td></tr>
            <tr><td>0x5E</td> <td>^</td></tr>
            <tr><td>0x60</td> <td>`</td></tr>
            <tr><td>0x7B</td> <td>{</td></tr>
            <tr><td>0x7C</td> <td>/</td></tr>
            <tr><td>0x7D</td> <td>}</td></tr>
            <tr><td>0x7E</td> <td>~</td></tr>
        </table>

</div>
<div class="ddoc_returns">
	<h4>Return Value</h4>
	<p class="para">
		a string.

	</p>
</div>
<div class="ddoc_throws">
	<h4>Throws</h4>
	<p class="para">
		ASN1ValueException = if any enecoded character is not ASCII.
	</p>
</div></section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.internationalAlphabetNumber5String" id="CanonicalEncodingRulesElement.internationalAlphabetNumber5String"><code class="member">internationalAlphabetNumber5String</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.internationalAlphabetNumber5String.2"></span>@property @system void <code class="code">internationalAlphabetNumber5String</code>(in string <code class="code">value</code>);

    </code>
</section>
<div><section class="module-info"><section id="summary">Encodes a string that may only contain ASCII characters.
</section>
<div class="description">IA5String differs from ASCII ever so slightly: IA5 is international,
        leaving 10 characters up to be locale-specific:
<br><br>
        <table>            <tr><th>Byte</th> <th>ASCII Character</th></tr>
            <tr><td>0x40</td> <td>@</td></tr>
            <tr><td>0x5B</td> <td>[</td></tr>
            <tr><td>0x5C</td> <td>\</td></tr>
            <tr><td>0x5D</td> <td>]</td></tr>
            <tr><td>0x5E</td> <td>^</td></tr>
            <tr><td>0x60</td> <td>`</td></tr>
            <tr><td>0x7B</td> <td>{</td></tr>
            <tr><td>0x7C</td> <td>/</td></tr>
            <tr><td>0x7D</td> <td>}</td></tr>
            <tr><td>0x7E</td> <td>~</td></tr>
        </table>

</div>
<div class="ddoc_throws">
	<h4>Throws</h4>
	<p class="para">
		ASN1ValueException = if any enecoded character is not ASCII.
	</p>
</div></section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.coordinatedUniversalTime" id="CanonicalEncodingRulesElement.coordinatedUniversalTime"><code class="member">coordinatedUniversalTime</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.coordinatedUniversalTime"></span>const @property @system DateTime <code class="code">coordinatedUniversalTime</code>();

    </code>
</section>
<div><section class="module-info"><section id="summary">Decodes a DateTime.
</section>
<div class="description">The encoded value is just the ASCII character representation of
        the UTC-formatted timestamp.
<br><br>
        When using Canonical Encoding Rules (CER), only the YYMMDDhhmmssZ
        format is acceptable for encoding UTCTime.
<br><br>
        A UTCTime does not support milliseconds, unlike GeneralizedTime.
<br><br>
        If the first digit of the two-digit year is 7, 6, 5, 4, 3, 2, 1, or 0,
        meaning that the date refers to the first 80 years of the century, this
        assumes we are talking about the 21st century and prepend '20' when
        creating the ISO Date String. Otherwise, it assumes we are talking
        about the 20th century, and prepend '19' when creating the string.

</div>
<div class="ddoc_see_also">
	<h4>See Also</h4>
	<p class="para">
		<a href="https://www.obj-sys.com/asn1tutorial/node15.html">UTCTime</a>


	</p>
</div>
<div class="ddoc_throws">
	<h4>Throws</h4>
	<p class="para">
		DateTimeException = if string cannot be decoded to a DateTime
	</p>
</div></section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.coordinatedUniversalTime" id="CanonicalEncodingRulesElement.coordinatedUniversalTime"><code class="member">coordinatedUniversalTime</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.coordinatedUniversalTime.2"></span>@property @system void <code class="code">coordinatedUniversalTime</code>(in DateTime <code class="code">value</code>);

    </code>
</section>
<div><section class="module-info"><section id="summary">Encodes a DateTime.
</section>
<div class="description">The encoded <code class="code">value</code> is just the ASCII character representation of
        the UTC-formatted timestamp.
<br><br>
        When using Canonical Encoding Rules (CER), only the YYMMDDhhmmssZ
        format is acceptable for encoding UTCTime.

</div>
<div class="ddoc_see_also">
	<h4>See Also</h4>
	<p class="para">
		<a href="https://www.obj-sys.com/asn1tutorial/node15.html">UTCTime</a>
	</p>
</div>
</section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.generalizedTime" id="CanonicalEncodingRulesElement.generalizedTime"><code class="member">generalizedTime</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.generalizedTime"></span>const @property @system DateTime <code class="code">generalizedTime</code>();

    </code>
</section>
<div><section class="module-info"><section id="summary">Decodes a DateTime.
</section>
<div class="description">The CER-encoded value is just the ASCII character representation of
        the <a href="https://www.iso.org/iso-8601-date-and-time-format.html">        ISO 8601</a>-formatted timestamp.
<br><br>
        An ISO-8601 Timestamp looks like:
        <ul>            <li>19851106210627.3</li>
            <li>19851106210627.3Z</li>
            <li>19851106210627.3-0500</li>
        </ul>
<br><br>
        But when using Canonical Encoding Rules (CER), only timestamps with
        no trailing periods ('.'), or post-period trailing zeroes are acceptable,
        and all timestamps must end with a 'Z', indicating UTC time.

</div>
<div class="ddoc_throws">
	<h4>Throws</h4>
	<p class="para">
		DateTimeException = if string cannot be decoded to a DateTime
	</p>
</div></section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.generalizedTime" id="CanonicalEncodingRulesElement.generalizedTime"><code class="member">generalizedTime</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.generalizedTime.2"></span>@property @system void <code class="code">generalizedTime</code>(in DateTime <code class="code">value</code>);

    </code>
</section>
<div><section class="module-info"><section id="summary">Encodes a DateTime.
</section>
<div class="description">The CER-encoded <code class="code">value</code> is just the ASCII character representation of
        the <a href="https://www.iso.org/iso-8601-date-and-time-format.html">        ISO 8601</a>-formatted timestamp.
<br><br>
        An ISO-8601 Timestamp looks like:
        <ul>            <li>19851106210627.3</li>
            <li>19851106210627.3Z</li>
            <li>19851106210627.3-0500</li>
        </ul>
<br><br>
        But when using Canonical Encoding Rules (CER), only timestamps with
        no trailing periods ('.'), or post-period trailing zeroes are acceptable,
        and all timestamps must end with a 'Z', indicating UTC time.</div>
</section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.graphicString" id="CanonicalEncodingRulesElement.graphicString"><code class="member">graphicString</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.graphicString"></span>const @property @system string <code class="code">graphicString</code>();

    </code>
</section>
<div><section class="module-info"><section id="summary">Decodes an ASCII string that contains only characters between and
        including 0x20 and 0x75.
</section>
<div class="description">Deprecated, according to page 182 of the Dubuisson book.

</div>
<div class="ddoc_section">
	<p class="para">
		<span class="ddoc_section_h">Citations:</span>
Dubuisson, Olivier. “Character String Types.” ASN.1:
                Communication between Heterogeneous Systems, Morgan
                Kaufmann, 2001, pp. 175-178.
            <a href="https://en.wikipedia.org/wiki/ISO/IEC_2022">                The Wikipedia Page on ISO 2022</a>
            <a href="https://www.iso.org/standard/22747.html">ISO 2022</a>


	</p>
</div>
<div class="ddoc_returns">
	<h4>Return Value</h4>
	<p class="para">
		a string.

	</p>
</div>
<div class="ddoc_throws">
	<h4>Throws</h4>
	<p class="para">
		ASN1ValueException = if any non-graphical character
                (including space) is encoded.
	</p>
</div></section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.graphicString" id="CanonicalEncodingRulesElement.graphicString"><code class="member">graphicString</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.graphicString.2"></span>@property @system void <code class="code">graphicString</code>(in string <code class="code">value</code>);

    </code>
</section>
<div><section class="module-info"><section id="summary">Encodes an ASCII string that may contain only characters between and
        including 0x20 and 0x75.
</section>
<div class="description">Deprecated, according to page 182 of the Dubuisson book.

</div>
<div class="ddoc_section">
	<p class="para">
		<span class="ddoc_section_h">Citations:</span>
Dubuisson, Olivier. “Character String Types.” ASN.1:
                Communication between Heterogeneous Systems, Morgan
                Kaufmann, 2001, pp. 175-178.
            <a href="https://en.wikipedia.org/wiki/ISO/IEC_2022">                The Wikipedia Page on ISO 2022</a>
            <a href="https://www.iso.org/standard/22747.html">ISO 2022</a>


	</p>
</div>
<div class="ddoc_throws">
	<h4>Throws</h4>
	<p class="para">
		ASN1ValueException = if any non-graphical character
                (including space) is supplied.
	</p>
</div></section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.visibleString" id="CanonicalEncodingRulesElement.visibleString"><code class="member">visibleString</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.visibleString"></span>const @property @system string <code class="code">visibleString</code>();

    </code>
</section>
<div><section class="module-info"><section id="summary">Decodes a string that only contains characters between and including
        0x20 and 0x7E. (Honestly, I don't know how this differs from
        GraphicalString.)
</section>
<div class="ddoc_returns">
	<h4>Return Value</h4>
	<p class="para">
		a string.

	</p>
</div>
<div class="ddoc_throws">
	<h4>Throws</h4>
	<p class="para">
		ASN1ValueException = if any non-graphical character
                (including space) is encoded.
	</p>
</div></section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.visibleString" id="CanonicalEncodingRulesElement.visibleString"><code class="member">visibleString</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.visibleString.2"></span>@property @system void <code class="code">visibleString</code>(in string <code class="code">value</code>);

    </code>
</section>
<div><section class="module-info"><section id="summary">Encodes a string that only contains characters between and including
        0x20 and 0x7E. (Honestly, I don't know how this differs from
        GraphicalString.)
</section>
<div class="ddoc_throws">
	<h4>Throws</h4>
	<p class="para">
		ASN1ValueException = if any non-graphical character
                (including space) is supplied.
	</p>
</div></section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.generalString" id="CanonicalEncodingRulesElement.generalString"><code class="member">generalString</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.generalString"></span>const @property @system string <code class="code">generalString</code>();

    </code>
</section>
<div><section class="module-info"><section id="summary">Decodes a string containing only ASCII characters.
</section>
<div class="description">Deprecated, according to page 182 of the Dubuisson book.

</div>
<div class="ddoc_returns">
	<h4>Return Value</h4>
	<p class="para">
		a string.

	</p>
</div>
<div class="ddoc_throws">
	<h4>Throws</h4>
	<p class="para">
		ASN1ValueException = if any enecoded character is not ASCII.


	</p>
</div><div class="ddoc_section">
	<p class="para">
		<span class="ddoc_section_h">Citations:</span>
Dubuisson, Olivier. “Canonical Encoding Rules (CER).” ASN.1:
            Communication between Heterogeneous Systems, Morgan Kaufmann,
            2001, p. 182.
	</p>
</div>
</section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.generalString" id="CanonicalEncodingRulesElement.generalString"><code class="member">generalString</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.generalString.2"></span>@property @system void <code class="code">generalString</code>(in string <code class="code">value</code>);

    </code>
</section>
<div><section class="module-info"><section id="summary">Encodes a string containing only ASCII characters.
</section>
<div class="description">Deprecated, according to page 182 of the Dubuisson book.

</div>
<div class="ddoc_throws">
	<h4>Throws</h4>
	<p class="para">
		ASN1ValueException = if any enecoded character is not ASCII.


	</p>
</div><div class="ddoc_section">
	<p class="para">
		<span class="ddoc_section_h">Citations:</span>
Dubuisson, Olivier. “Canonical Encoding Rules (CER).” ASN.1:
            Communication between Heterogeneous Systems, Morgan Kaufmann,
            2001, p. 182.
	</p>
</div>
</section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.universalString" id="CanonicalEncodingRulesElement.universalString"><code class="member">universalString</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.universalString"></span>const @property @system dstring <code class="code">universalString</code>();

    </code>
</section>
<div><section class="module-info"><section id="summary">Decodes a dstring of UTF-32 characters.
</section>
<div class="ddoc_returns">
	<h4>Return Value</h4>
	<p class="para">
		a string of UTF-32 characters.

	</p>
</div>
<div class="ddoc_throws">
	<h4>Throws</h4>
	<p class="para">
		ASN1ValueException = if the encoded bytes is not evenly
                divisible by four.
	</p>
</div></section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.universalString" id="CanonicalEncodingRulesElement.universalString"><code class="member">universalString</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.universalString.2"></span>@property @system void <code class="code">universalString</code>(in dstring <code class="code">value</code>);

    </code>
</section>
<div><section class="module-info"><section id="summary">Encodes a dstring of UTF-32 characters.</section>
</section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.characterString" id="CanonicalEncodingRulesElement.characterString"><code class="member">characterString</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.characterString"></span>const @property @system CharacterString <code class="code">characterString</code>();

    </code>
</section>
<div><section class="module-info"><section id="summary">Decodes a CHARACTER STRING, which is a constructed data type, defined
        in the <a href="https://www.itu.int">                International Telecommunications Union</a>'s
            <a href="https://www.itu.int/rec/T-REC-X.680/en">X.680</a>.
</section>
<div class="description">The specification defines CHARACTER as:
<br><br>
        <span class="mono">            CHARACTER STRING ::= [UNIVERSAL 29] SEQUENCE {
                identification CHOICE {
                    syntaxes SEQUENCE {
                        abstract OBJECT IDENTIFIER,
                        transfer OBJECT IDENTIFIER },
                    syntax OBJECT IDENTIFIER,
                    presentation-context-id INTEGER,
                    context-negotiation SEQUENCE {
                        presentation-context-id INTEGER,
                        transfer-syntax OBJECT IDENTIFIER },
                    transfer-syntax OBJECT IDENTIFIER,
                    fixed NULL },
                string-value OCTET STRING }
        </span>
<br><br>
        This assumes AUTOMATIC TAGS, so all of the identification choices
        will be context-specific and numbered from 0 to 5.

</div>
<div class="ddoc_returns">
	<h4>Return Value</h4>
	<p class="para">
		an instance of types.universal.CharacterString.

	</p>
</div>
<div class="ddoc_throws">
	<h4>Throws</h4>
	<p class="para">
		ASN1SizeException = if encoded CharacterString has too few or too many
                elements, or if syntaxes or context-negotiation element has
                too few or too many elements.
            ASN1ValueSizeException = if encoded INTEGER is too large to decode.
            ASN1InvalidIndexException = if encoded value selects a choice for
                identification or uses an unspecified index for an element in
                syntaxes or context-negotiation, or if an unspecified element
                of CharacterString itself is referenced by an out-of-range
                context-specific index. (See <code class="code">ASN1InvalidIndexException</code>.)
	</p>
</div></section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.characterString" id="CanonicalEncodingRulesElement.characterString"><code class="member">characterString</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.characterString.2"></span>@property @system void <code class="code">characterString</code>(in CharacterString <code class="code">value</code>);

    </code>
</section>
<div><section class="module-info"><section id="summary">Encodes a CHARACTER STRING, which is a constructed data type, defined
        in the <a href="https://www.itu.int">                International Telecommunications Union</a>'s
            <a href="https://www.itu.int/rec/T-REC-X.680/en">X.680</a>.
</section>
<div class="description">The specification defines CHARACTER as:
<br><br>
        <span class="mono">            CHARACTER STRING ::= [UNIVERSAL 29] SEQUENCE {
                identification CHOICE {
                    syntaxes SEQUENCE {
                        abstract OBJECT IDENTIFIER,
                        transfer OBJECT IDENTIFIER },
                    syntax OBJECT IDENTIFIER,
                    presentation-context-id INTEGER,
                    context-negotiation SEQUENCE {
                        presentation-context-id INTEGER,
                        transfer-syntax OBJECT IDENTIFIER },
                    transfer-syntax OBJECT IDENTIFIER,
                    fixed NULL },
                string-<code class="code">value</code> OCTET STRING }
        </span>
<br><br>
        This assumes AUTOMATIC TAGS, so all of the identification choices
        will be context-specific and numbered from 0 to 5.</div>
</section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.basicMultilingualPlaneString" id="CanonicalEncodingRulesElement.basicMultilingualPlaneString"><code class="member">basicMultilingualPlaneString</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.basicMultilingualPlaneString"></span>const @property @system wstring <code class="code">basicMultilingualPlaneString</code>();

    </code>
</section>
<div><section class="module-info"><section id="summary">Decodes a wstring of UTF-16 characters.
</section>
<div class="ddoc_returns">
	<h4>Return Value</h4>
	<p class="para">
		an immutable array of UTF-16 characters.

	</p>
</div>
<div class="ddoc_throws">
	<h4>Throws</h4>
	<p class="para">
		ASN1ValueException = if the encoded bytes is not evenly
                divisible by two.
	</p>
</div></section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.basicMultilingualPlaneString" id="CanonicalEncodingRulesElement.basicMultilingualPlaneString"><code class="member">basicMultilingualPlaneString</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.basicMultilingualPlaneString.2"></span>@property @system void <code class="code">basicMultilingualPlaneString</code>(in wstring <code class="code">value</code>);

    </code>
</section>
<div><section class="module-info"><section id="summary">Encodes a wstring of UTF-16 characters.</section>
</section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.this" id="CanonicalEncodingRulesElement.this"><code class="member">this</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.this"></span>nothrow @nogc @safe this();

    </code>
</section>
<div><section class="module-info"><section id="summary">Creates an EndOfContent CER Value.</section>
</section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.this" id="CanonicalEncodingRulesElement.this"><code class="member">this</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.this.2"></span>@system this(ref ubyte[] <code class="code">bytes</code>);

    </code>
</section>
<div><section class="module-info"><section id="summary">Creates a CERElement from the supplied <code class="code">bytes</code>, inferring that the first
        byte is the type tag. The supplied ubyte[] array is "chomped" by
        reference, so the original array will grow shorter as CERElements are
        generated.
</section>
<div class="ddoc_throws">
	<h4>Throws</h4>
	<p class="para">
		ASN1ValueSizeException = if the <code class="code">bytes</code> supplied are fewer than
                two (one or zero, in other words), such that no valid CERElement
                can be decoded, or if the length is encoded in indefinite
                form, but the END OF CONTENT octets (two consecutive <code class="code">null</code>
                octets) cannot be found, or if the value is encoded in fewer
                octets than indicated by the length byte.
            ASN1LengthException = if the length byte is set to 0xFF,
                which is reserved.
            ASN1ValueSizeException = if the length cannot be represented by
                the largest unsigned integer.


	</p>
</div><div class="ddoc_section">
	<p class="para">
		<span class="ddoc_section_h">Example:</span>
<pre><code class="d block"><span class="comment">// Decoding looks like:
</span>CERElement[] result;
while (bytes.length &gt; 0)
    result ~= new CERElement(bytes);

<span class="comment">// Encoding looks like:
</span>ubyte[] result;
foreach (cv; bervalues)
{
    result ~= cast(ubyte[]) cv;
}
</code></pre>

	</p>
</div>
</section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.this" id="CanonicalEncodingRulesElement.this"><code class="member">this</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.this.3"></span>@system this(ref size_t <code class="code">bytesRead</code>, in ubyte[] <code class="code">bytes</code>);

    </code>
</section>
<div><section class="module-info"><section id="summary">Creates a CERElement from the supplied <code class="code">bytes</code>, inferring that the first
        byte is the type tag. The supplied ubyte[] array is read, starting
        from the index specified by <code class="d inline"><code class="code">bytesRead</code></code>, and increments
        <code class="d inline"><code class="code">bytesRead</code></code> by the number of <code class="code">bytes</code> read.
</section>
<div class="ddoc_throws">
	<h4>Throws</h4>
	<p class="para">
		ASN1ValueSizeException = if the <code class="code">bytes</code> supplied are fewer than
                two (one or zero, in other words), such that no valid CERElement
                can be decoded, or if the length is encoded in indefinite
                form, but the END OF CONTENT octets (two consecutive <code class="code">null</code>
                octets) cannot be found, or if the value is encoded in fewer
                octets than indicated by the length byte.
            ASN1LengthException = if the length byte is set to 0xFF,
                which is reserved.
            ASN1ValueSizeException = if the length cannot be represented by
                the largest unsigned integer.


	</p>
</div><div class="ddoc_section">
	<p class="para">
		<span class="ddoc_section_h">Example:</span>
<pre><code class="d block"><span class="comment">// Decoding looks like:
</span>CERElement[] result;
size_t i = 0u;
while (i &lt; bytes.length)
    result ~= new CERElement(i, bytes);

<span class="comment">// Encoding looks like:
</span>ubyte[] result;
foreach (cv; bervalues)
{
    result ~= cast(ubyte[]) cv;
}
</code></pre>

	</p>
</div>
</section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.toBytes" id="CanonicalEncodingRulesElement.toBytes"><code class="member">toBytes</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.toBytes"></span>const nothrow @property @system ubyte[] <code class="code">toBytes</code>();

    </code>
</section>
<div><section class="module-info"><section id="summary">This differs from <code class="code">this.value</code> in that
        <code class="code">this.value</code> only returns the value octets, whereas
        <code class="code">this.<code class="code">toBytes</code></code> returns the type tag, length tag / octets,
        and the value octets, all concatenated.
</section>
<div class="description">This is the exact same as <code class="code">this.opCast!(ubyte[])()</code>.

</div>
<div class="ddoc_returns">
	<h4>Return Value</h4>
	<p class="para">
		type tag, length tag, and value, all concatenated as a ubyte array.
	</p>
</div>
</section>
</div>
</li><li class="ddoc_member"><a href="#CanonicalEncodingRulesElement.opCast" id="CanonicalEncodingRulesElement.opCast"><code class="member">opCast</code></a>
<section class="declaration">
    <code>
        <span class="ddoc_anchor" id="CanonicalEncodingRulesElement.opCast"></span>nothrow @system ubyte[] <code class="code">opCast</code>(T = ubyte[])();

    </code>
</section>
<div><section class="module-info"><section id="summary">This differs from <code class="code">this.value</code> in that
        <code class="code">this.value</code> only returns the value octets, whereas
        <code class="code">this.toBytes</code> returns the type tag, length tag / octets,
        and the value octets, all concatenated.
</section>
<div class="description">This is the exact same as <code class="code">this.toBytes()</code>.

</div>
<div class="ddoc_returns">
	<h4>Return Value</h4>
	<p class="para">
		type tag, length tag, and value, all concatenated as a ubyte array.
	</p>
</div>
</section>
</div>
</li>
</ul>
</div>
</li>
</ul>
</section>

        </div>
        <div id="footer">
            <span id="timestamp">Tue Jan  9 21:10:22 2018
</span>
        </div>
    </body>
</html>
