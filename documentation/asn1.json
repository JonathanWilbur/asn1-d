[
 {
  "name" : "asn1",
  "kind" : "module",
  "file" : "./source/asn1.d",
  "comment" : "    Abstract Syntax Notation 1 is a high-level syntax specification created\n    by the $(LINK2 http://www.itu.int/en/pages/default.aspx,\n    International Telecommunications Union) in\n    $(LINK2 https://www.itu.int/rec/T-REC-X.680/en,\n    X.680 - Abstract Syntax Notation One (ASN.1)), that\n    abstractly defines data structures and protocol data units used by\n    programs and protocols. It defines an extensible system of data types,\n    modules, and data structures.\n\n    While described abstractly by ASN.1, the specified protocol data units\n    and data structures can be encoded via various encoding schemes, such as\n    the Basic Encoding Rules (BER), which are defined in the\n    $(LINK2 http://www.itu.int/en/pages/default.aspx,\n    International Telecommunications Union)'s\n    $(LINK2 http://www.itu.int/rec/T-REC-X.690/en, X.690 - ASN.1 encoding rules).\n    These encoding schemes uniformly relay data between systems that\n    can differ in endianness, bit-width, byte-size, operating system,\n    machine architecture, and so on.\n\n    The encoding schemata that inherit from ASN.1 are used widely in protocols\n    such as TLS, LDAP, SNMP, RDP, and many more.\n\n    Author:\n        $(LINK2 http://jonathan.wilbur.space, Jonathan M. Wilbur)\n            $(LINK2 mailto:jonathan@wilbur.space, jonathan@wilbur.space)\n    License: $(LINK2 https://mit-license.org/, MIT License)\n    Standards:\n        $(LINK2 https://www.itu.int/rec/T-REC-X.680/en, X.680 - Abstract Syntax Notation One (ASN.1))\n    See_Also:\n        $(LINK2 https://en.wikipedia.org/wiki/Abstract_Syntax_Notation_One, The Wikipedia Page on ASN.1)\n        $(LINK2 https://www.strozhevsky.com/free_docs/asn1_in_simple_words.pdf, ASN.1 By Simple Words)\n        $(LINK2 http://www.oss.com/asn1/resources/books-whitepapers-pubs/dubuisson-asn1-book.PDF, ASN.1: Communication Between Heterogeneous Systems)\n",
  "members" : [
   {
    "name" : "ASN1Exception",
    "kind" : "alias",
    "comment" : "\n",
    "line" : 63,
    "char" : 8,
    "deco" : "C4asn132AbstractSyntaxNotation1Exception"
   },
   {
    "name" : "AbstractSyntaxNotation1Exception",
    "kind" : "class",
    "comment" : "A Generic Exception from which all other ASN.1 Exceptions will inherit.\n",
    "line" : 65,
    "char" : 1,
    "base" : "object.Exception",
    "members" : [
     {
      "name" : "std.exception",
      "kind" : "import",
      "line" : 67,
      "char" : 20,
      "protection" : "private",
      "selective" : [
       "basicExceptionCtors"
      ]
     },
     {
      "name" : "basicExceptionCtors!()",
      "kind" : "mixin",
      "line" : 68,
      "char" : 5
     }
    ]
   },
   {
    "name" : "ASN1TagClass",
    "kind" : "alias",
    "comment" : "\n",
    "line" : 72,
    "char" : 8,
    "deco" : "E4asn131AbstractSyntaxNotation1TagClass"
   },
   {
    "name" : "AbstractSyntaxNotation1TagClass",
    "kind" : "enum",
    "comment" : "\n",
    "line" : 75,
    "char" : 1,
    "baseDeco" : "h",
    "members" : [
     {
      "name" : "universal",
      "kind" : "enum member",
      "value" : "cast(ubyte)0u",
      "line" : 77,
      "char" : 5
     },
     {
      "name" : "application",
      "kind" : "enum member",
      "value" : "cast(ubyte)64u",
      "line" : 78,
      "char" : 5
     },
     {
      "name" : "contextSpecific",
      "kind" : "enum member",
      "value" : "cast(ubyte)128u",
      "line" : 79,
      "char" : 5
     },
     {
      "name" : "privatelyDefined",
      "kind" : "enum member",
      "value" : "cast(ubyte)192u",
      "line" : 80,
      "char" : 5
     }
    ]
   },
   {
    "name" : "ASN1Construction",
    "kind" : "alias",
    "comment" : "\n",
    "line" : 84,
    "char" : 8,
    "deco" : "E4asn135AbstractSyntaxNotation1Construction"
   },
   {
    "name" : "AbstractSyntaxNotation1Construction",
    "kind" : "enum",
    "comment" : "\n",
    "line" : 87,
    "char" : 1,
    "baseDeco" : "h",
    "members" : [
     {
      "name" : "primitive",
      "kind" : "enum member",
      "value" : "cast(ubyte)0u",
      "line" : 89,
      "char" : 5
     },
     {
      "name" : "constructed",
      "kind" : "enum member",
      "value" : "cast(ubyte)32u",
      "line" : 90,
      "char" : 5
     }
    ]
   },
   {
    "name" : "ASN1UniversalType",
    "kind" : "alias",
    "comment" : "\n",
    "line" : 94,
    "char" : 8,
    "deco" : "E4asn136AbstractSyntaxNotation1UniversalType"
   },
   {
    "name" : "AbstractSyntaxNotation1UniversalType",
    "kind" : "enum",
    "comment" : "    The data types, as well as their permitted construction and numeric\n    identifiers, according to the\n    $(LINK2 http://www.itu.int/en/pages/default.aspx,\n    International Telecommunications Union)'s\n    $(LINK2 http://www.itu.int/rec/T-REC-X.690/en, X.690 - ASN.1 encoding rules)\n\n    $(TABLE\n        $(TR $(TH Type)                 $(TH Construction)      $(TH Hexadecimal Value))\n        $(TR $(TD End-of-Content)       $(TD Primitive)         $(TD 0x00))\n        $(TR $(TD BOOLEAN)\t            $(TD Primitive)         $(TD 0x01))\n        $(TR $(TD INTEGER)\t            $(TD Primitive)         $(TD 0x02))\n        $(TR $(TD BIT STRING)           $(TD Both)              $(TD 0x03))\n        $(TR $(TD OCTET STRING)         $(TD Both)              $(TD 0x04))\n        $(TR $(TD NULL)                 $(TD Primitive)         $(TD 0x05))\n        $(TR $(TD OBJECT IDENTIFIER)\t$(TD Primitive)         $(TD 0x06))\n        $(TR $(TD Object Descriptor)    $(TD Both)              $(TD 0x07))\n        $(TR $(TD EXTERNAL)\t            $(TD Constructed)       $(TD 0x08))\n        $(TR $(TD REAL)            \t    $(TD Primitive)         $(TD 0x09))\n        $(TR $(TD ENUMERATED)\t        $(TD Primitive)         $(TD 0x0A))\n        $(TR $(TD EMBEDDED PDV)\t        $(TD Constructed)       $(TD 0x0B))\n        $(TR $(TD UTF8String)\t        $(TD Both)              $(TD 0x0C))\n        $(TR $(TD RELATIVE-OID)\t        $(TD Primitive)         $(TD 0x0D))\n        $(TR $(TD SEQUENCE)\t            $(TD Constructed)       $(TD 0x10))\n        $(TR $(TD SET)\t                $(TD Constructed)       $(TD 0x11))\n        $(TR $(TD NumericString)\t    $(TD Both)              $(TD 0x12))\n        $(TR $(TD PrintableString)\t    $(TD Both)              $(TD 0x13))\n        $(TR $(TD T61String)\t        $(TD Both)              $(TD 0x14))\n        $(TR $(TD VideotexString)\t    $(TD Both)              $(TD 0x15))\n        $(TR $(TD IA5String)\t        $(TD Both)              $(TD 0x16))\n        $(TR $(TD UTCTime)\t            $(TD Both)              $(TD 0x17))\n        $(TR $(TD GeneralizedTime)\t    $(TD Both)              $(TD 0x18))\n        $(TR $(TD GraphicString)\t    $(TD Both)              $(TD 0x19))\n        $(TR $(TD VisibleString)\t    $(TD Both)              $(TD 0x1A))\n        $(TR $(TD GeneralString)\t    $(TD Both)              $(TD 0x1B))\n        $(TR $(TD UniversalString)\t    $(TD Both)              $(TD 0x1C))\n        $(TR $(TD CHARACTER STRING)\t    $(TD Both)              $(TD 0x1D))\n        $(TR $(TD BMPString)\t        $(TD Both)              $(TD 0x1E))\n    )\n",
    "line" : 136,
    "char" : 1,
    "baseDeco" : "h",
    "members" : [
     {
      "name" : "endOfContent",
      "kind" : "enum member",
      "value" : "cast(ubyte)0u",
      "line" : 138,
      "char" : 5
     },
     {
      "name" : "eoc",
      "kind" : "enum member",
      "value" : "cast(ubyte)0u",
      "line" : 139,
      "char" : 5
     },
     {
      "name" : "boolean",
      "kind" : "enum member",
      "value" : "cast(ubyte)1u",
      "line" : 140,
      "char" : 5
     },
     {
      "name" : "integer",
      "kind" : "enum member",
      "value" : "cast(ubyte)2u",
      "line" : 141,
      "char" : 5
     },
     {
      "name" : "bitString",
      "kind" : "enum member",
      "value" : "cast(ubyte)3u",
      "line" : 142,
      "char" : 5
     },
     {
      "name" : "octetString",
      "kind" : "enum member",
      "value" : "cast(ubyte)4u",
      "line" : 143,
      "char" : 5
     },
     {
      "name" : "nill",
      "kind" : "enum member",
      "value" : "cast(ubyte)5u",
      "line" : 144,
      "char" : 5
     },
     {
      "name" : "objectIdentifier",
      "kind" : "enum member",
      "value" : "cast(ubyte)6u",
      "line" : 145,
      "char" : 5
     },
     {
      "name" : "oid",
      "kind" : "enum member",
      "value" : "cast(ubyte)6u",
      "line" : 146,
      "char" : 5
     },
     {
      "name" : "objectDescriptor",
      "kind" : "enum member",
      "value" : "cast(ubyte)7u",
      "line" : 147,
      "char" : 5
     },
     {
      "name" : "external",
      "kind" : "enum member",
      "value" : "cast(ubyte)8u",
      "line" : 148,
      "char" : 5
     },
     {
      "name" : "ext",
      "kind" : "enum member",
      "value" : "cast(ubyte)8u",
      "line" : 149,
      "char" : 5
     },
     {
      "name" : "realNumber",
      "kind" : "enum member",
      "value" : "cast(ubyte)9u",
      "line" : 150,
      "char" : 5
     },
     {
      "name" : "enumerated",
      "kind" : "enum member",
      "value" : "cast(ubyte)10u",
      "line" : 151,
      "char" : 5
     },
     {
      "name" : "embeddedPresentationDataValue",
      "kind" : "enum member",
      "value" : "cast(ubyte)11u",
      "line" : 152,
      "char" : 5
     },
     {
      "name" : "embeddedPDV",
      "kind" : "enum member",
      "value" : "cast(ubyte)11u",
      "line" : 153,
      "char" : 5
     },
     {
      "name" : "pdv",
      "kind" : "enum member",
      "value" : "cast(ubyte)11u",
      "line" : 154,
      "char" : 5
     },
     {
      "name" : "unicodeTransformationFormat8String",
      "kind" : "enum member",
      "value" : "cast(ubyte)12u",
      "line" : 155,
      "char" : 5
     },
     {
      "name" : "utf8String",
      "kind" : "enum member",
      "value" : "cast(ubyte)12u",
      "line" : 156,
      "char" : 5
     },
     {
      "name" : "utf8",
      "kind" : "enum member",
      "value" : "cast(ubyte)12u",
      "line" : 157,
      "char" : 5
     },
     {
      "name" : "relativeObjectIdentifier",
      "kind" : "enum member",
      "value" : "cast(ubyte)13u",
      "line" : 158,
      "char" : 5
     },
     {
      "name" : "relativeOID",
      "kind" : "enum member",
      "value" : "cast(ubyte)13u",
      "line" : 159,
      "char" : 5
     },
     {
      "name" : "roid",
      "kind" : "enum member",
      "value" : "cast(ubyte)13u",
      "line" : 160,
      "char" : 5
     },
     {
      "name" : "reserved14",
      "kind" : "enum member",
      "value" : "cast(ubyte)14u",
      "line" : 161,
      "char" : 5
     },
     {
      "name" : "reserved15",
      "kind" : "enum member",
      "value" : "cast(ubyte)15u",
      "line" : 162,
      "char" : 5
     },
     {
      "name" : "sequence",
      "kind" : "enum member",
      "value" : "cast(ubyte)16u",
      "line" : 163,
      "char" : 5
     },
     {
      "name" : "set",
      "kind" : "enum member",
      "value" : "cast(ubyte)17u",
      "line" : 164,
      "char" : 5
     },
     {
      "name" : "numericString",
      "kind" : "enum member",
      "value" : "cast(ubyte)18u",
      "line" : 165,
      "char" : 5
     },
     {
      "name" : "numeric",
      "kind" : "enum member",
      "value" : "cast(ubyte)18u",
      "line" : 166,
      "char" : 5
     },
     {
      "name" : "printableString",
      "kind" : "enum member",
      "value" : "cast(ubyte)19u",
      "line" : 167,
      "char" : 5
     },
     {
      "name" : "printable",
      "kind" : "enum member",
      "value" : "cast(ubyte)19u",
      "line" : 168,
      "char" : 5
     },
     {
      "name" : "teletexString",
      "kind" : "enum member",
      "value" : "cast(ubyte)20u",
      "line" : 169,
      "char" : 5
     },
     {
      "name" : "t61String",
      "kind" : "enum member",
      "value" : "cast(ubyte)20u",
      "line" : 170,
      "char" : 5
     },
     {
      "name" : "videotexString",
      "kind" : "enum member",
      "value" : "cast(ubyte)21u",
      "line" : 171,
      "char" : 5
     },
     {
      "name" : "internationalAlphabetNumber5String",
      "kind" : "enum member",
      "value" : "cast(ubyte)22u",
      "line" : 172,
      "char" : 5
     },
     {
      "name" : "ia5String",
      "kind" : "enum member",
      "value" : "cast(ubyte)22u",
      "line" : 173,
      "char" : 5
     },
     {
      "name" : "coordinatedUniversalTime",
      "kind" : "enum member",
      "value" : "cast(ubyte)23u",
      "line" : 174,
      "char" : 5
     },
     {
      "name" : "utcTime",
      "kind" : "enum member",
      "value" : "cast(ubyte)23u",
      "line" : 175,
      "char" : 5
     },
     {
      "name" : "generalizedTime",
      "kind" : "enum member",
      "value" : "cast(ubyte)24u",
      "line" : 176,
      "char" : 5
     },
     {
      "name" : "graphicString",
      "kind" : "enum member",
      "value" : "cast(ubyte)25u",
      "line" : 177,
      "char" : 5
     },
     {
      "name" : "graphic",
      "kind" : "enum member",
      "value" : "cast(ubyte)25u",
      "line" : 178,
      "char" : 5
     },
     {
      "name" : "visibleString",
      "kind" : "enum member",
      "value" : "cast(ubyte)26u",
      "line" : 179,
      "char" : 5
     },
     {
      "name" : "visible",
      "kind" : "enum member",
      "value" : "cast(ubyte)26u",
      "line" : 180,
      "char" : 5
     },
     {
      "name" : "generalString",
      "kind" : "enum member",
      "value" : "cast(ubyte)27u",
      "line" : 181,
      "char" : 5
     },
     {
      "name" : "general",
      "kind" : "enum member",
      "value" : "cast(ubyte)27u",
      "line" : 182,
      "char" : 5
     },
     {
      "name" : "universalString",
      "kind" : "enum member",
      "value" : "cast(ubyte)28u",
      "line" : 183,
      "char" : 5
     },
     {
      "name" : "universal",
      "kind" : "enum member",
      "value" : "cast(ubyte)28u",
      "line" : 184,
      "char" : 5
     },
     {
      "name" : "characterString",
      "kind" : "enum member",
      "value" : "cast(ubyte)29u",
      "line" : 185,
      "char" : 5
     },
     {
      "name" : "basicMultilingualPlaneString",
      "kind" : "enum member",
      "value" : "cast(ubyte)30u",
      "line" : 186,
      "char" : 5
     },
     {
      "name" : "bmpString",
      "kind" : "enum member",
      "value" : "cast(ubyte)30u",
      "line" : 187,
      "char" : 5
     }
    ]
   },
   {
    "name" : "ASN1LengthEncoding",
    "kind" : "alias",
    "comment" : "\n",
    "line" : 191,
    "char" : 8,
    "deco" : "E4asn137AbstractSyntaxNotation1LengthEncoding"
   },
   {
    "name" : "AbstractSyntaxNotation1LengthEncoding",
    "kind" : "enum",
    "comment" : "\n",
    "line" : 194,
    "char" : 1,
    "baseDeco" : "h",
    "members" : [
     {
      "name" : "definiteShort",
      "kind" : "enum member",
      "value" : "cast(ubyte)0u",
      "line" : 196,
      "char" : 5
     },
     {
      "name" : "indefinite",
      "kind" : "enum member",
      "value" : "cast(ubyte)128u",
      "line" : 197,
      "char" : 5
     },
     {
      "name" : "definiteLong",
      "kind" : "enum member",
      "value" : "cast(ubyte)129u",
      "line" : 198,
      "char" : 5
     },
     {
      "name" : "reserved",
      "kind" : "enum member",
      "value" : "cast(ubyte)255u",
      "line" : 199,
      "char" : 5
     }
    ]
   },
   {
    "name" : "ASN1RealEncodingBase",
    "kind" : "alias",
    "comment" : "\n",
    "line" : 203,
    "char" : 8,
    "deco" : "E4asn139AbstractSyntaxNotation1RealEncodingBase"
   },
   {
    "name" : "AbstractSyntaxNotation1RealEncodingBase",
    "kind" : "enum",
    "comment" : "\n",
    "line" : 206,
    "char" : 1,
    "baseDeco" : "h",
    "members" : [
     {
      "name" : "base2",
      "kind" : "enum member",
      "value" : "cast(ubyte)2u",
      "line" : 208,
      "char" : 5
     },
     {
      "name" : "base8",
      "kind" : "enum member",
      "value" : "cast(ubyte)8u",
      "line" : 209,
      "char" : 5
     },
     {
      "name" : "base10",
      "kind" : "enum member",
      "value" : "cast(ubyte)10u",
      "line" : 210,
      "char" : 5
     },
     {
      "name" : "base16",
      "kind" : "enum member",
      "value" : "cast(ubyte)16u",
      "line" : 211,
      "char" : 5
     }
    ]
   },
   {
    "name" : "ASN1RealEncodingScale",
    "kind" : "alias",
    "comment" : "\n",
    "line" : 215,
    "char" : 8,
    "deco" : "E4asn140AbstractSyntaxNotation1RealEncodingScale"
   },
   {
    "name" : "AbstractSyntaxNotation1RealEncodingScale",
    "kind" : "enum",
    "comment" : "\n",
    "line" : 218,
    "char" : 1,
    "baseDeco" : "h",
    "members" : [
     {
      "name" : "scale0",
      "kind" : "enum member",
      "value" : "cast(ubyte)0u",
      "line" : 220,
      "char" : 5
     },
     {
      "name" : "scale1",
      "kind" : "enum member",
      "value" : "cast(ubyte)1u",
      "line" : 221,
      "char" : 5
     },
     {
      "name" : "scale2",
      "kind" : "enum member",
      "value" : "cast(ubyte)2u",
      "line" : 222,
      "char" : 5
     },
     {
      "name" : "scale3",
      "kind" : "enum member",
      "value" : "cast(ubyte)3u",
      "line" : 223,
      "char" : 5
     }
    ]
   },
   {
    "name" : "ASN1RealExponentEncoding",
    "kind" : "alias",
    "comment" : "\n",
    "line" : 227,
    "char" : 8,
    "deco" : "E4asn143AbstractSyntaxNotation1RealExponentEncoding"
   },
   {
    "name" : "AbstractSyntaxNotation1RealExponentEncoding",
    "kind" : "enum",
    "comment" : "\n",
    "line" : 230,
    "char" : 1,
    "baseDeco" : "h",
    "members" : [
     {
      "name" : "followingOctet",
      "kind" : "enum member",
      "value" : "cast(ubyte)0u",
      "line" : 232,
      "char" : 5
     },
     {
      "name" : "following2Octets",
      "kind" : "enum member",
      "value" : "cast(ubyte)1u",
      "line" : 233,
      "char" : 5
     },
     {
      "name" : "following3Octets",
      "kind" : "enum member",
      "value" : "cast(ubyte)2u",
      "line" : 234,
      "char" : 5
     },
     {
      "name" : "complicated",
      "kind" : "enum member",
      "value" : "cast(ubyte)3u",
      "line" : 235,
      "char" : 5
     }
    ]
   },
   {
    "name" : "ASN1SpecialRealValue",
    "kind" : "alias",
    "comment" : "\n",
    "line" : 239,
    "char" : 8,
    "deco" : "E4asn139AbstractSyntaxNotation1SpecialRealValue"
   },
   {
    "name" : "AbstractSyntaxNotation1SpecialRealValue",
    "kind" : "enum",
    "comment" : "\n",
    "line" : 242,
    "char" : 1,
    "baseDeco" : "h",
    "members" : [
     {
      "name" : "plusInfinity",
      "kind" : "enum member",
      "value" : "cast(ubyte)64u",
      "line" : 244,
      "char" : 5
     },
     {
      "name" : "minusInfinity",
      "kind" : "enum member",
      "value" : "cast(ubyte)65u",
      "line" : 245,
      "char" : 5
     },
     {
      "name" : "notANumber",
      "kind" : "enum member",
      "value" : "cast(ubyte)66u",
      "line" : 246,
      "char" : 5
     },
     {
      "name" : "negativeZero",
      "kind" : "enum member",
      "value" : "cast(ubyte)67u",
      "line" : 247,
      "char" : 5
     }
    ]
   },
   {
    "name" : "ASN1Base10RealNumericalRepresentation",
    "kind" : "alias",
    "comment" : "\n",
    "line" : 251,
    "char" : 8,
    "deco" : "E4asn156AbstractSyntaxNotation1Base10RealNumericalRepresentation"
   },
   {
    "name" : "AbstractSyntaxNotation1Base10RealNumericalRepresentation",
    "kind" : "enum",
    "comment" : "    The standardized string representations of floating point numbers, as\n    specified in $(LINK2 https://www.iso.org/standard/12285.html, ISO 6093).\n\n    $(TABLE\n        $(TR $(TH Representation) $(TH Description) $(TH Examples))\n        $(TR $(TD NR1) $(TD Implicit decimal point) $(TD \"3\", \"-1\", \"+1000\"))\n        $(TR $(TD NR2) $(TD Explicit decimal) $(TD \"3.0\", \"-1.3\", \"-.3\"))\n        $(TR $(TD NR3) $(TD Explicit exponent) $(TD \"3.0E1\", \"123E+100\"))\n    )\n\n    Citations:\n        Dubuisson, Olivier. “Character String Types.” ASN.1:\n            Communication between Heterogeneous Systems, Morgan\n            Kaufmann, 2001, p. 143.\n",
    "line" : 269,
    "char" : 1,
    "baseDeco" : "h",
    "members" : [
     {
      "name" : "nr1",
      "kind" : "enum member",
      "value" : "cast(ubyte)1u",
      "line" : 271,
      "char" : 5
     },
     {
      "name" : "nr2",
      "kind" : "enum member",
      "value" : "cast(ubyte)2u",
      "line" : 272,
      "char" : 5
     },
     {
      "name" : "nr3",
      "kind" : "enum member",
      "value" : "cast(ubyte)3u",
      "line" : 273,
      "char" : 5
     }
    ]
   },
   {
    "name" : "numericStringCharacters",
    "kind" : "variable",
    "comment" : "The acceptable characters for a NumericString\n",
    "line" : 277,
    "char" : 25,
    "storageClass" : [
     "immutable"
    ],
    "deco" : "yAa",
    "originalType" : "string",
    "init" : "\"0123456789 \""
   },
   {
    "name" : "printableStringCharacters",
    "kind" : "variable",
    "comment" : "    The acceptable characters for a printableString.\n\n    The sorting of letters below is a slight optimization:\n    they are sorted in order of decreasing frequency in the English\n    language, so that canFind will usually have to iterate through\n    fewer letters before finding a match.\n",
    "line" : 287,
    "char" : 25,
    "storageClass" : [
     "immutable"
    ],
    "deco" : "yAa",
    "originalType" : "string",
    "init" : "\"etaoinsrhdlucmfywgpbvkxqjzETAOINSRHDLUCMFYWGPBVKXQJZ0123456789 '()+,-./:=?\""
   }
  ]
 },
 {
  "name" : "codec",
  "kind" : "module",
  "file" : "./source/codec.d",
  "comment" : "    The codecs in this library are values of an ASN1 encoding scheme.\n    The type, length, and value are set using properties defined on\n    abstract classes from which the encoding-specific values inherit.\n    This module contains those abstract classes, and with these classes,\n    it serves as the root module from which all other codec modules will\n    inherit.\n",
  "members" : [
   {
    "name" : "asn1",
    "kind" : "import",
    "line" : 10,
    "char" : 15
   },
   {
    "name" : "types.alltypes",
    "kind" : "import",
    "line" : 11,
    "char" : 15
   },
   {
    "name" : "types.identification",
    "kind" : "import",
    "line" : 12,
    "char" : 15
   },
   {
    "name" : "types.oidtype",
    "kind" : "import",
    "line" : 13,
    "char" : 15
   },
   {
    "name" : "std.algorithm.mutation",
    "kind" : "import",
    "line" : 14,
    "char" : 15,
    "selective" : [
     "reverse"
    ]
   },
   {
    "name" : "std.algorithm.searching",
    "kind" : "import",
    "line" : 15,
    "char" : 15,
    "selective" : [
     "canFind"
    ]
   },
   {
    "name" : "std.array",
    "kind" : "import",
    "line" : 16,
    "char" : 15,
    "selective" : [
     "appender",
     "Appender",
     "replace",
     "split"
    ]
   },
   {
    "name" : "std.ascii",
    "kind" : "import",
    "line" : 17,
    "char" : 15,
    "selective" : [
     "isASCII",
     "isGraphical"
    ]
   },
   {
    "name" : "std.conv",
    "kind" : "import",
    "line" : 18,
    "char" : 15,
    "selective" : [
     "text"
    ]
   },
   {
    "name" : "std.datetime.date",
    "kind" : "import",
    "line" : 19,
    "char" : 15,
    "selective" : [
     "DateTime"
    ]
   },
   {
    "name" : "std.datetime.systime",
    "kind" : "import",
    "line" : 20,
    "char" : 15,
    "selective" : [
     "SysTime"
    ]
   },
   {
    "name" : "std.datetime.timezone",
    "kind" : "import",
    "line" : 21,
    "char" : 15,
    "selective" : [
     "TimeZone",
     "UTC"
    ]
   },
   {
    "name" : "std.exception",
    "kind" : "import",
    "line" : 22,
    "char" : 16,
    "protection" : "private",
    "selective" : [
     "basicExceptionCtors"
    ]
   },
   {
    "name" : "std.math",
    "kind" : "import",
    "line" : 23,
    "char" : 15,
    "selective" : [
     "isNaN",
     "log2"
    ]
   },
   {
    "name" : "std.traits",
    "kind" : "import",
    "line" : 24,
    "char" : 15,
    "selective" : [
     "isFloatingPoint",
     "isIntegral",
     "isSigned",
     "isUnsigned"
    ]
   },
   {
    "name" : "ASN1CodecException",
    "kind" : "alias",
    "comment" : "\n",
    "line" : 27,
    "char" : 8,
    "deco" : "C5codec37AbstractSyntaxNotation1CodecException"
   },
   {
    "name" : "AbstractSyntaxNotation1CodecException",
    "kind" : "class",
    "comment" : "A generic exception from which any ASN.1 codec exception may inherit\n",
    "line" : 30,
    "char" : 1,
    "base" : "asn1.AbstractSyntaxNotation1Exception",
    "members" : [
     {
      "name" : "basicExceptionCtors!()",
      "kind" : "mixin",
      "line" : 32,
      "char" : 5
     }
    ]
   },
   {
    "name" : "ASN1RecursionException",
    "kind" : "alias",
    "comment" : "\n",
    "line" : 36,
    "char" : 8,
    "deco" : "C5codec41AbstractSyntaxNotation1RecursionException"
   },
   {
    "name" : "AbstractSyntaxNotation1RecursionException",
    "kind" : "class",
    "comment" : "An exception that is thrown when excessively deep recursion occurs.\n",
    "line" : 39,
    "char" : 1,
    "base" : "codec.AbstractSyntaxNotation1CodecException",
    "members" : [
     {
      "name" : "basicExceptionCtors!()",
      "kind" : "mixin",
      "line" : 41,
      "char" : 5
     }
    ]
   },
   {
    "name" : "ASN1TagException",
    "kind" : "alias",
    "comment" : "\n",
    "line" : 45,
    "char" : 8,
    "deco" : "C5codec35AbstractSyntaxNotation1TagException"
   },
   {
    "name" : "AbstractSyntaxNotation1TagException",
    "kind" : "class",
    "comment" : "\n",
    "line" : 48,
    "char" : 1,
    "base" : "codec.AbstractSyntaxNotation1CodecException",
    "members" : [
     {
      "name" : "basicExceptionCtors!()",
      "kind" : "mixin",
      "line" : 50,
      "char" : 5
     }
    ]
   },
   {
    "name" : "ASN1ValueSizeException",
    "kind" : "alias",
    "comment" : "\n",
    "line" : 54,
    "char" : 8,
    "deco" : "C5codec41AbstractSyntaxNotation1ValueSizeException"
   },
   {
    "name" : "AbstractSyntaxNotation1ValueSizeException",
    "kind" : "class",
    "comment" : "\n",
    "line" : 57,
    "char" : 1,
    "base" : "codec.AbstractSyntaxNotation1CodecException",
    "members" : [
     {
      "name" : "basicExceptionCtors!()",
      "kind" : "mixin",
      "line" : 59,
      "char" : 5
     }
    ]
   },
   {
    "name" : "ASN1ValueTooBigException",
    "kind" : "alias",
    "comment" : "\n",
    "line" : 63,
    "char" : 8,
    "deco" : "C5codec43AbstractSyntaxNotation1ValueTooBigException"
   },
   {
    "name" : "AbstractSyntaxNotation1ValueTooBigException",
    "kind" : "class",
    "comment" : "\n",
    "line" : 66,
    "char" : 1,
    "base" : "codec.AbstractSyntaxNotation1ValueSizeException",
    "members" : [
     {
      "name" : "basicExceptionCtors!()",
      "kind" : "mixin",
      "line" : 68,
      "char" : 5
     }
    ]
   },
   {
    "name" : "ASN1ValueTooSmallException",
    "kind" : "alias",
    "comment" : "\n",
    "line" : 72,
    "char" : 8,
    "deco" : "C5codec45AbstractSyntaxNotation1ValueTooSmallException"
   },
   {
    "name" : "AbstractSyntaxNotation1ValueTooSmallException",
    "kind" : "class",
    "comment" : "\n",
    "line" : 75,
    "char" : 1,
    "base" : "codec.AbstractSyntaxNotation1ValueSizeException",
    "members" : [
     {
      "name" : "basicExceptionCtors!()",
      "kind" : "mixin",
      "line" : 77,
      "char" : 5
     }
    ]
   },
   {
    "name" : "ASN1ValueInvalidException",
    "kind" : "alias",
    "comment" : "\n",
    "line" : 81,
    "char" : 8,
    "deco" : "C5codec44AbstractSyntaxNotation1ValueInvalidException"
   },
   {
    "name" : "AbstractSyntaxNotation1ValueInvalidException",
    "kind" : "class",
    "comment" : "    Thrown when an encoded value, or a decoded value (attempting to be encoded)\n    takes on a value that the codec cannot encode or decode.\n\n    Examples:\n    $(UL\n        $(LI When a DER codec detects a BOOLEAN encoded in a byte other than 0xFF or 0x00)\n        $(LI When a BER codec finds an invalid character in a string)\n    )\n",
    "line" : 93,
    "char" : 1,
    "base" : "codec.AbstractSyntaxNotation1CodecException",
    "members" : [
     {
      "name" : "basicExceptionCtors!()",
      "kind" : "mixin",
      "line" : 95,
      "char" : 5
     }
    ]
   },
   {
    "name" : "ASN1InvalidIndexException",
    "kind" : "alias",
    "comment" : "\n",
    "line" : 99,
    "char" : 8,
    "deco" : "C5codec44AbstractSyntaxNotation1InvalidIndexException"
   },
   {
    "name" : "AbstractSyntaxNotation1InvalidIndexException",
    "kind" : "class",
    "comment" : "    An exception thrown when a member of a CHOICE or SEQUENCE is given a\n    context-specific index that is not defined for that CHOICE or SEQUENCE.\n\n    For example, if:\n\n    TheQuestion := [APPLICATION 5] CHOICE {\n        toBe [0] NULL,\n        notToBe [1] NULL\n    }\n\n    This exception should be thrown if TheQuestion were to be decoded from the\n    BER-encoded byte sequence: $(D_INLINECODE 0x65 0x02 0x83 0x00), because\n    the third byte specifies a third choice in TheQuestion, but there is no\n    choice #3 in TheQuestion--there is only choice #0 and #1.\n",
    "line" : 117,
    "char" : 1,
    "base" : "codec.AbstractSyntaxNotation1CodecException",
    "members" : [
     {
      "name" : "basicExceptionCtors!()",
      "kind" : "mixin",
      "line" : 119,
      "char" : 5
     }
    ]
   },
   {
    "name" : "ASN1InvalidLengthException",
    "kind" : "alias",
    "comment" : "\n",
    "line" : 123,
    "char" : 8,
    "deco" : "C5codec45AbstractSyntaxNotation1InvalidLengthException"
   },
   {
    "name" : "AbstractSyntaxNotation1InvalidLengthException",
    "kind" : "class",
    "comment" : "    Thrown if an invalid length encoding is encountered, such as when a length byte\n    of 0xFF--which is reserved--is encountered in BER encoding.\n",
    "line" : 129,
    "char" : 1,
    "base" : "codec.AbstractSyntaxNotation1CodecException",
    "members" : [
     {
      "name" : "basicExceptionCtors!()",
      "kind" : "mixin",
      "line" : 131,
      "char" : 5
     }
    ]
   },
   {
    "name" : "ASN1Element",
    "kind" : "alias",
    "comment" : "\n",
    "line" : 135,
    "char" : 8
   },
   {
    "kind" : "template",
    "comment" : "\n",
    "line" : 138,
    "char" : 1,
    "name" : "AbstractSyntaxNotation1Element",
    "parameters" : [
     {
      "name" : "Element",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "AbstractSyntaxNotation1Element",
      "kind" : "class",
      "line" : 138,
      "char" : 1,
      "members" : [
       {
        "name" : "__unittest___source_codec_d_143_0",
        "kind" : "function",
        "line" : 143,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 149,
        "endchar" : 5
       },
       {
        "name" : "maxUintAsReal",
        "kind" : "variable",
        "line" : 149,
        "char" : 30,
        "storageClass" : [
         "immutable"
        ],
        "deco" : "e",
        "init" : "cast(real)(uint).max"
       },
       {
        "name" : "maxLongAsReal",
        "kind" : "variable",
        "line" : 150,
        "char" : 30,
        "storageClass" : [
         "immutable"
        ],
        "deco" : "e",
        "init" : "cast(real)(long).max"
       },
       {
        "name" : "logBaseTwoOfTen",
        "kind" : "variable",
        "line" : 151,
        "char" : 30,
        "storageClass" : [
         "immutable"
        ],
        "deco" : "e",
        "init" : "log2(10.0000)"
       },
       {
        "name" : "threeByteMax",
        "kind" : "variable",
        "line" : 152,
        "char" : 29,
        "storageClass" : [
         "immutable"
        ],
        "deco" : "i",
        "init" : "8388607"
       },
       {
        "name" : "threeByteMin",
        "kind" : "variable",
        "line" : 153,
        "char" : 29,
        "storageClass" : [
         "immutable"
        ],
        "deco" : "i",
        "init" : "4286578688u"
       },
       {
        "name" : "notWhatYouMeantText",
        "kind" : "variable",
        "line" : 156,
        "char" : 22,
        "storageClass" : [
         "immutable"
        ],
        "type" : "string",
        "init" : "\"It is highly likely that what you attempted to decode was not the \" ~ \"data type that you thought it was. Most likely, one of the following \" ~ \"scenarios occurred: (1) you did not write this program to the exact \" ~ \"specification of the protocol, or (2) someone is attempting to hack \" ~ \"this program (review the HeartBleed bug), or (3) the client sent \" ~ \"valid data that was just too big to decode. \""
       },
       {
        "name" : "forMoreInformationText",
        "kind" : "variable",
        "line" : 163,
        "char" : 22,
        "storageClass" : [
         "immutable"
        ],
        "type" : "string",
        "init" : "\"For more information on the specific method or property that originated \" ~ \"this exception, see the documentation associated with this ASN.1 \" ~ \"library. For more information on ASN.1's data types in general, see \" ~ \"the International Telecommunications Union's X.680 specification, \" ~ \"which can be found at: \" ~ \"https://www.itu.int/ITU-T/studygroups/com17/languages/X.680-0207.pdf. \" ~ \"For more information on how those data types are supposed to be \" ~ \"encoded using Basic Encoding Rules, Canonical Encoding Rules, or \" ~ \"Distinguished Encoding Rules, see the International \" ~ \"Telecommunications Union's X.690 specification, which can be found \" ~ \"at: https://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf. \""
       },
       {
        "name" : "debugInformationText",
        "kind" : "variable",
        "line" : 175,
        "char" : 22,
        "storageClass" : [
         "immutable"
        ],
        "type" : "string",
        "init" : "\"If reviewing the documentation does not help, you may want to run \" ~ \"the ASN.1 library in debug mode. To do this, compile the source code \" ~ \"for this library with the `-debug=asn1` flag (if you are compiling \" ~ \"with `dmd`). This will display information to the console that may \" ~ \"help you diagnose any issues. \""
       },
       {
        "name" : "reportBugsText",
        "kind" : "variable",
        "line" : 181,
        "char" : 22,
        "storageClass" : [
         "immutable"
        ],
        "type" : "string",
        "init" : "\"If none of the steps above helped, and you believe that you have \" ~ \"discovered a bug, please create an issue on the GitHub page's Issues \" ~ \"section at: https://github.com/JonathanWilbur/asn1-d/issues. \""
       },
       {
        "name" : "LengthEncodingPreference",
        "kind" : "enum",
        "comment" : "\n",
        "line" : 188,
        "char" : 5,
        "baseDeco" : "h",
        "members" : [
         {
          "name" : "definite",
          "kind" : "enum member",
          "line" : 190,
          "char" : 9
         },
         {
          "name" : "indefinite",
          "kind" : "enum member",
          "line" : 191,
          "char" : 9
         }
        ]
       },
       {
        "name" : "boolean",
        "kind" : "function",
        "comment" : "Decodes a boolean\n",
        "line" : 196,
        "char" : 10,
        "storageClass" : [
         "abstract"
        ],
        "type" : "const @property bool()"
       },
       {
        "name" : "boolean",
        "kind" : "function",
        "comment" : "Encodes a boolean\n",
        "line" : 200,
        "char" : 10,
        "storageClass" : [
         "abstract"
        ],
        "type" : "@property void(in bool value)",
        "parameters" : [
         {
          "name" : "value",
          "deco" : "b",
          "storageClass" : [
           "in"
          ]
         }
        ]
       },
       {
        "name" : "__unittest___source_codec_d_203_0",
        "kind" : "function",
        "line" : 203,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 216,
        "endchar" : 5
       },
       {
        "kind" : "template",
        "comment" : "Decodes an integer\n",
        "line" : 217,
        "char" : 7,
        "name" : "integer",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         }
        ],
        "constraint" : "isIntegral!T && isSigned!T",
        "members" : [
         {
          "name" : "integer",
          "kind" : "function",
          "line" : 217,
          "char" : 7,
          "storageClass" : [
           "abstract"
          ],
          "type" : "const @property T()"
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "Encodes an integer\n",
        "line" : 221,
        "char" : 10,
        "name" : "integer",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         }
        ],
        "constraint" : "isIntegral!T && isSigned!T",
        "members" : [
         {
          "name" : "integer",
          "kind" : "function",
          "line" : 221,
          "char" : 10,
          "storageClass" : [
           "abstract"
          ],
          "type" : "@property void(in T value)",
          "parameters" : [
           {
            "name" : "value",
            "type" : "T",
            "storageClass" : [
             "in"
            ]
           }
          ]
         }
        ]
       },
       {
        "name" : "__unittest___source_codec_d_225_0",
        "kind" : "function",
        "line" : 225,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 242,
        "endchar" : 5
       },
       {
        "name" : "__unittest___source_codec_d_243_0",
        "kind" : "function",
        "line" : 243,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 258,
        "endchar" : 5
       },
       {
        "name" : "__unittest___source_codec_d_259_0",
        "kind" : "function",
        "line" : 259,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 276,
        "endchar" : 5
       },
       {
        "name" : "__unittest___source_codec_d_277_0",
        "kind" : "function",
        "line" : 277,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 287,
        "endchar" : 5
       },
       {
        "name" : "__unittest___source_codec_d_288_0",
        "kind" : "function",
        "line" : 288,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 459,
        "endchar" : 5
       },
       {
        "name" : "bitString",
        "kind" : "function",
        "line" : 460,
        "char" : 12,
        "storageClass" : [
         "abstract"
        ],
        "type" : "const @property bool[]()"
       },
       {
        "name" : "bitString",
        "kind" : "function",
        "line" : 463,
        "char" : 10,
        "storageClass" : [
         "abstract"
        ],
        "type" : "@property void(in bool[] value)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "bool[]",
          "storageClass" : [
           "in"
          ]
         }
        ]
       },
       {
        "name" : "__unittest___source_codec_d_466_0",
        "kind" : "function",
        "line" : 466,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 483,
        "endchar" : 5
       },
       {
        "name" : "octetString",
        "kind" : "function",
        "comment" : "Decodes a ubyte[] array\n",
        "line" : 484,
        "char" : 13,
        "storageClass" : [
         "abstract"
        ],
        "type" : "const @property ubyte[]()"
       },
       {
        "name" : "octetString",
        "kind" : "function",
        "comment" : "Encodes a ubyte[] array\n",
        "line" : 488,
        "char" : 10,
        "storageClass" : [
         "abstract"
        ],
        "type" : "@property void(in ubyte[] value)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "ubyte[]",
          "storageClass" : [
           "in"
          ]
         }
        ]
       },
       {
        "name" : "__unittest___source_codec_d_491_0",
        "kind" : "function",
        "line" : 491,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 502,
        "endchar" : 5
       },
       {
        "name" : "__unittest___source_codec_d_503_0",
        "kind" : "function",
        "line" : 503,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 513,
        "endchar" : 5
       },
       {
        "name" : "__unittest___source_codec_d_514_0",
        "kind" : "function",
        "line" : 514,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 525,
        "endchar" : 5
       },
       {
        "name" : "oid",
        "kind" : "alias",
        "comment" : "\n",
        "line" : 525,
        "char" : 12,
        "type" : "objectIdentifier"
       },
       {
        "name" : "objectID",
        "kind" : "alias",
        "comment" : "\n",
        "line" : 527,
        "char" : 12,
        "type" : "objectIdentifier"
       },
       {
        "name" : "objectIdentifier",
        "kind" : "function",
        "comment" : "Decodes an Object Identifier\n",
        "line" : 530,
        "char" : 9,
        "storageClass" : [
         "abstract"
        ],
        "type" : "const @property OID()"
       },
       {
        "name" : "objectIdentifier",
        "kind" : "function",
        "comment" : "Encodes an Object Identifier\n",
        "line" : 534,
        "char" : 10,
        "storageClass" : [
         "abstract"
        ],
        "type" : "@property void(in OID value)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "OID",
          "storageClass" : [
           "in"
          ]
         }
        ]
       },
       {
        "name" : "__unittest___source_codec_d_537_0",
        "kind" : "function",
        "line" : 537,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 618,
        "endchar" : 5
       },
       {
        "name" : "objectDescriptor",
        "kind" : "function",
        "comment" : "        Decodes an ObjectDescriptor, which is a string consisting of only\n        graphical characters. In fact, ObjectDescriptor is actually implicitly\n        just a GraphicString! The formal specification for an ObjectDescriptor\n        is:\n\n        $(I ObjectDescriptor ::= [UNIVERSAL 7] IMPLICIT GraphicString)\n\n        GraphicString is just 0x20 to 0x7E, therefore ObjectDescriptor is just\n        0x20 to 0x7E.\n\n        Sources:\n            $(LINK2 ,\n                ASN.1: Communication Between Heterogeneous Systems, pages 175-178)\n            $(LINK2 https://en.wikipedia.org/wiki/ISO/IEC_2022,\n                The Wikipedia Page on ISO 2022)\n            $(LINK2 https://www.iso.org/standard/22747.html, ISO 2022)\n",
        "line" : 619,
        "char" : 12,
        "storageClass" : [
         "abstract"
        ],
        "type" : "const @property string()"
       },
       {
        "name" : "objectDescriptor",
        "kind" : "function",
        "comment" : "        Encodes an ObjectDescriptor, which is a string consisting of only\n        graphical characters. In fact, ObjectDescriptor is actually implicitly\n        just a GraphicString! The formal specification for an ObjectDescriptor\n        is:\n\n        $(I ObjectDescriptor ::= [UNIVERSAL 7] IMPLICIT GraphicString)\n\n        GraphicString is just 0x20 to 0x7E, therefore ObjectDescriptor is just\n        0x20 to 0x7E.\n\n        Sources:\n            $(LINK2 ,\n                ASN.1: Communication Between Heterogeneous Systems, pages 175-178)\n            $(LINK2 https://en.wikipedia.org/wiki/ISO/IEC_2022,\n                The Wikipedia Page on ISO 2022)\n            $(LINK2 https://www.iso.org/standard/22747.html, ISO 2022)\n",
        "line" : 640,
        "char" : 10,
        "storageClass" : [
         "abstract"
        ],
        "type" : "@property void(in string value)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "string",
          "storageClass" : [
           "in"
          ]
         }
        ]
       },
       {
        "name" : "__unittest___source_codec_d_643_0",
        "kind" : "function",
        "line" : 643,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 688,
        "endchar" : 5
       },
       {
        "name" : "external",
        "kind" : "function",
        "comment" : "        Decodes an EXTERNAL, which is a constructed data type, defined in\n        the $(LINK2 https://www.itu.int,\n            International Telecommunications Union)'s\n        $(LINK2 https://www.itu.int/rec/T-REC-X.680/en, X.680).\n\n        The specification defines EXTERNAL as:\n\n        $(I\n        EXTERNAL := [UNIVERSAL 8] IMPLICIT SEQUENCE {\n            identification CHOICE {\n                syntax OBJECT IDENTIFIER,\n                presentation-context-id INTEGER,\n                context-negotiation SEQUENCE {\n                    presentation-context-id INTEGER,\n                    transfer-syntax OBJECT IDENTIFIER } },\n            data-value-descriptor ObjectDescriptor OPTIONAL,\n            data-value OCTET STRING }\n        )\n\n        This assumes AUTOMATIC TAGS, so all of the identification choices\n        will be context-specific and numbered from 0 to 2.\n",
        "line" : 689,
        "char" : 14,
        "storageClass" : [
         "abstract",
         "deprecated"
        ],
        "type" : "const @property External()"
       },
       {
        "name" : "external",
        "kind" : "function",
        "comment" : "        Encodes an EXTERNAL, which is a constructed data type, defined in\n        the $(LINK2 https://www.itu.int,\n            International Telecommunications Union)'s\n        $(LINK2 https://www.itu.int/rec/T-REC-X.680/en, X.680).\n\n        The specification defines EXTERNAL as:\n\n        $(I\n        EXTERNAL := [UNIVERSAL 8] IMPLICIT SEQUENCE {\n            identification CHOICE {\n                syntax OBJECT IDENTIFIER,\n                presentation-context-id INTEGER,\n                context-negotiation SEQUENCE {\n                    presentation-context-id INTEGER,\n                    transfer-syntax OBJECT IDENTIFIER } },\n            data-value-descriptor ObjectDescriptor OPTIONAL,\n            data-value OCTET STRING }\n        )\n\n        This assumes AUTOMATIC TAGS, so all of the identification choices\n        will be context-specific and numbered from 0 to 2.\n",
        "line" : 715,
        "char" : 10,
        "storageClass" : [
         "abstract",
         "deprecated"
        ],
        "type" : "@property void(in External value)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "External",
          "storageClass" : [
           "in"
          ]
         }
        ]
       },
       {
        "name" : "__unittest___source_codec_d_719_0",
        "kind" : "function",
        "line" : 719,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 758,
        "endchar" : 5
       },
       {
        "kind" : "template",
        "comment" : "Encodes a floating-point number\n",
        "line" : 759,
        "char" : 7,
        "name" : "realNumber",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         }
        ],
        "constraint" : "isFloatingPoint!T",
        "members" : [
         {
          "name" : "realNumber",
          "kind" : "function",
          "line" : 759,
          "char" : 7,
          "storageClass" : [
           "abstract"
          ],
          "type" : "const @property T()"
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "Encodes a floating-point number\n",
        "line" : 763,
        "char" : 10,
        "name" : "realNumber",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         }
        ],
        "constraint" : "isFloatingPoint!T",
        "members" : [
         {
          "name" : "realNumber",
          "kind" : "function",
          "line" : 763,
          "char" : 10,
          "storageClass" : [
           "abstract"
          ],
          "type" : "@property void(in T value)",
          "parameters" : [
           {
            "name" : "value",
            "type" : "T",
            "storageClass" : [
             "in"
            ]
           }
          ]
         }
        ]
       },
       {
        "name" : "__unittest___source_codec_d_766_0",
        "kind" : "function",
        "line" : 766,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 793,
        "endchar" : 5
       },
       {
        "name" : "__unittest___source_codec_d_794_0",
        "kind" : "function",
        "line" : 794,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 818,
        "endchar" : 5
       },
       {
        "name" : "__unittest___source_codec_d_819_0",
        "kind" : "function",
        "line" : 819,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 918,
        "endchar" : 5
       },
       {
        "name" : "__unittest___source_codec_d_919_0",
        "kind" : "function",
        "line" : 919,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 937,
        "endchar" : 5
       },
       {
        "name" : "__unittest___source_codec_d_938_0",
        "kind" : "function",
        "line" : 938,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 973,
        "endchar" : 5
       },
       {
        "name" : "__unittest___source_codec_d_974_0",
        "kind" : "function",
        "line" : 974,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 1073,
        "endchar" : 5
       },
       {
        "name" : "__unittest___source_codec_d_1074_0",
        "kind" : "function",
        "line" : 1074,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 1137,
        "endchar" : 5
       },
       {
        "kind" : "template",
        "comment" : "Encodes an integer that represents an ENUMERATED value\n",
        "line" : 1138,
        "char" : 7,
        "name" : "enumerated",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         }
        ],
        "constraint" : "isIntegral!T && isSigned!T",
        "members" : [
         {
          "name" : "enumerated",
          "kind" : "function",
          "line" : 1138,
          "char" : 7,
          "storageClass" : [
           "abstract"
          ],
          "type" : "const @property T()"
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "Decodes an integer that represents an ENUMERATED value\n",
        "line" : 1142,
        "char" : 10,
        "name" : "enumerated",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         }
        ],
        "constraint" : "isIntegral!T && isSigned!T",
        "members" : [
         {
          "name" : "enumerated",
          "kind" : "function",
          "line" : 1142,
          "char" : 10,
          "storageClass" : [
           "abstract"
          ],
          "type" : "@property void(in T value)",
          "parameters" : [
           {
            "name" : "value",
            "type" : "T",
            "storageClass" : [
             "in"
            ]
           }
          ]
         }
        ]
       },
       {
        "name" : "__unittest___source_codec_d_1146_0",
        "kind" : "function",
        "line" : 1146,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 1163,
        "endchar" : 5
       },
       {
        "name" : "__unittest___source_codec_d_1164_0",
        "kind" : "function",
        "line" : 1164,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 1179,
        "endchar" : 5
       },
       {
        "name" : "__unittest___source_codec_d_1180_0",
        "kind" : "function",
        "line" : 1180,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 1197,
        "endchar" : 5
       },
       {
        "name" : "__unittest___source_codec_d_1198_0",
        "kind" : "function",
        "line" : 1198,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 1208,
        "endchar" : 5
       },
       {
        "name" : "__unittest___source_codec_d_1209_0",
        "kind" : "function",
        "line" : 1209,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 1381,
        "endchar" : 5
       },
       {
        "name" : "embeddedPDV",
        "kind" : "alias",
        "comment" : "\n",
        "line" : 1381,
        "char" : 12,
        "type" : "embeddedPresentationDataValue"
       },
       {
        "name" : "embeddedPresentationDataValue",
        "kind" : "function",
        "comment" : "        Decodes an EMBEDDED PDV, which is a constructed data type, defined in\n            the $(LINK2 https://www.itu.int,\n                International Telecommunications Union)'s\n            $(LINK2 https://www.itu.int/rec/T-REC-X.680/en, X.680).\n\n        The specification defines EMBEDDED PDV as:\n\n        $(I\n            EmbeddedPDV ::= [UNIVERSAL 11] IMPLICIT SEQUENCE {\n                identification CHOICE {\n                    syntaxes SEQUENCE {\n                        abstract OBJECT IDENTIFIER,\n                        transfer OBJECT IDENTIFIER },\n                    syntax OBJECT IDENTIFIER,\n                    presentation-context-id INTEGER,\n                    context-negotiation SEQUENCE {\n                        presentation-context-id INTEGER,\n                        transfer-syntax OBJECT IDENTIFIER },\n                    transfer-syntax OBJECT IDENTIFIER,\n                    fixed NULL },\n                data-value-descriptor ObjectDescriptor OPTIONAL,\n                data-value OCTET STRING }\n            (WITH COMPONENTS { ... , data-value-descriptor ABSENT })\n        )\n\n        This assumes AUTOMATIC TAGS, so all of the identification choices\n        will be context-specific and numbered from 0 to 5.\n",
        "line" : 1412,
        "char" : 17,
        "storageClass" : [
         "abstract"
        ],
        "type" : "const @property EmbeddedPDV()"
       },
       {
        "name" : "embeddedPresentationDataValue",
        "kind" : "function",
        "comment" : "        Encodes an EMBEDDED PDV, which is a constructed data type, defined in\n            the $(LINK2 https://www.itu.int,\n                International Telecommunications Union)'s\n            $(LINK2 https://www.itu.int/rec/T-REC-X.680/en, X.680).\n\n        The specification defines EMBEDDED PDV as:\n\n        $(I\n            EmbeddedPDV ::= [UNIVERSAL 11] IMPLICIT SEQUENCE {\n                identification CHOICE {\n                    syntaxes SEQUENCE {\n                        abstract OBJECT IDENTIFIER,\n                        transfer OBJECT IDENTIFIER },\n                    syntax OBJECT IDENTIFIER,\n                    presentation-context-id INTEGER,\n                    context-negotiation SEQUENCE {\n                        presentation-context-id INTEGER,\n                        transfer-syntax OBJECT IDENTIFIER },\n                    transfer-syntax OBJECT IDENTIFIER,\n                    fixed NULL },\n                data-value-descriptor ObjectDescriptor OPTIONAL,\n                data-value OCTET STRING }\n            (WITH COMPONENTS { ... , data-value-descriptor ABSENT })\n        )\n\n        This assumes AUTOMATIC TAGS, so all of the identification choices\n        will be context-specific and numbered from 0 to 5.\n",
        "line" : 1444,
        "char" : 10,
        "storageClass" : [
         "abstract"
        ],
        "type" : "@property void(in EmbeddedPDV value)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "EmbeddedPDV",
          "storageClass" : [
           "in"
          ]
         }
        ]
       },
       {
        "name" : "__unittest___source_codec_d_1447_0",
        "kind" : "function",
        "line" : 1447,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 1471,
        "endchar" : 5
       },
       {
        "name" : "__unittest___source_codec_d_1472_0",
        "kind" : "function",
        "line" : 1472,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 1488,
        "endchar" : 5
       },
       {
        "name" : "__unittest___source_codec_d_1489_0",
        "kind" : "function",
        "line" : 1489,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 1505,
        "endchar" : 5
       },
       {
        "name" : "__unittest___source_codec_d_1506_0",
        "kind" : "function",
        "line" : 1506,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 1523,
        "endchar" : 5
       },
       {
        "name" : "utf8String",
        "kind" : "alias",
        "comment" : "\n",
        "line" : 1523,
        "char" : 12,
        "type" : "unicodeTransformationFormat8String"
       },
       {
        "name" : "unicodeTransformationFormat8String",
        "kind" : "function",
        "comment" : "Decodes a UTF-8 String\n",
        "line" : 1526,
        "char" : 12,
        "storageClass" : [
         "abstract"
        ],
        "type" : "const @property string()"
       },
       {
        "name" : "unicodeTransformationFormat8String",
        "kind" : "function",
        "comment" : "Encodes a UTF-8 String\n",
        "line" : 1530,
        "char" : 10,
        "storageClass" : [
         "abstract"
        ],
        "type" : "@property void(in string value)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "string",
          "storageClass" : [
           "in"
          ]
         }
        ]
       },
       {
        "name" : "__unittest___source_codec_d_1533_0",
        "kind" : "function",
        "line" : 1533,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 1546,
        "endchar" : 5
       },
       {
        "name" : "__unittest___source_codec_d_1547_0",
        "kind" : "function",
        "line" : 1547,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 1557,
        "endchar" : 5
       },
       {
        "name" : "roid",
        "kind" : "alias",
        "comment" : "\n",
        "line" : 1557,
        "char" : 12,
        "type" : "relativeObjectIdentifier"
       },
       {
        "name" : "relativeOID",
        "kind" : "alias",
        "comment" : "\n",
        "line" : 1559,
        "char" : 12,
        "type" : "relativeObjectIdentifier"
       },
       {
        "name" : "relativeObjectIdentifier",
        "kind" : "function",
        "comment" : "Decodes a portion of an Object Identifier\n",
        "line" : 1562,
        "char" : 15,
        "storageClass" : [
         "abstract"
        ],
        "type" : "const @property OIDNode[]()"
       },
       {
        "name" : "relativeObjectIdentifier",
        "kind" : "function",
        "comment" : "Encodes a porition of an Object Identifier\n",
        "line" : 1566,
        "char" : 10,
        "storageClass" : [
         "abstract"
        ],
        "type" : "@property void(in OIDNode[] value)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "OIDNode[]",
          "storageClass" : [
           "in"
          ]
         }
        ]
       },
       {
        "name" : "__unittest___source_codec_d_1569_0",
        "kind" : "function",
        "line" : 1569,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 1595,
        "endchar" : 5
       },
       {
        "name" : "sequence",
        "kind" : "function",
        "comment" : "        Decodes an array of elements.\n\n        Credits:\n            Thanks to StackOverflow user\n            $(LINK2 https://stackoverflow.com/users/359297/biotronic, BioTronic)\n            for teaching me how to create the abstract method that uses the\n            child class as a template.\n",
        "line" : 1596,
        "char" : 15,
        "storageClass" : [
         "abstract"
        ],
        "type" : "const @property Element[]()"
       },
       {
        "name" : "sequence",
        "kind" : "function",
        "comment" : "        Encodes an array of elements.\n\n        Credits:\n            Thanks to StackOverflow user\n            $(LINK2 https://stackoverflow.com/users/359297/biotronic, BioTronic)\n            for teaching me how to create the abstract method that uses the\n            child class as a template.\n",
        "line" : 1608,
        "char" : 10,
        "storageClass" : [
         "abstract"
        ],
        "type" : "@property void(in Element[] value)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "Element[]",
          "storageClass" : [
           "in"
          ]
         }
        ]
       },
       {
        "name" : "set",
        "kind" : "function",
        "comment" : "        Decodes an array of elements.\n\n        Credits:\n            Thanks to StackOverflow user\n            $(LINK2 https://stackoverflow.com/users/359297/biotronic, BioTronic)\n            for teaching me how to create the abstract method that uses the\n            child class as a template.\n",
        "line" : 1620,
        "char" : 15,
        "storageClass" : [
         "abstract"
        ],
        "type" : "const @property Element[]()"
       },
       {
        "name" : "set",
        "kind" : "function",
        "comment" : "        Encodes an array of elements.\n\n        Credits:\n            Thanks to StackOverflow user\n            $(LINK2 https://stackoverflow.com/users/359297/biotronic, BioTronic)\n            for teaching me how to create the abstract method that uses the\n            child class as a template.\n",
        "line" : 1632,
        "char" : 10,
        "storageClass" : [
         "abstract"
        ],
        "type" : "@property void(in Element[] value)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "Element[]",
          "storageClass" : [
           "in"
          ]
         }
        ]
       },
       {
        "name" : "numericString",
        "kind" : "function",
        "comment" : "        Decodes a string, where the characters of the string are limited to\n        0 - 9 and space.\n",
        "line" : 1639,
        "char" : 12,
        "storageClass" : [
         "abstract"
        ],
        "type" : "const @property string()"
       },
       {
        "name" : "numericString",
        "kind" : "function",
        "comment" : "        Encodes a string, where the characters of the string are limited to\n        0 - 9 and space.\n",
        "line" : 1646,
        "char" : 10,
        "storageClass" : [
         "abstract"
        ],
        "type" : "@property void(in string value)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "string",
          "storageClass" : [
           "in"
          ]
         }
        ]
       },
       {
        "name" : "__unittest___source_codec_d_1649_0",
        "kind" : "function",
        "line" : 1649,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 1666,
        "endchar" : 5
       },
       {
        "name" : "__unittest___source_codec_d_1667_0",
        "kind" : "function",
        "line" : 1667,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 1681,
        "endchar" : 5
       },
       {
        "name" : "printableString",
        "kind" : "function",
        "comment" : "        Decodes a string that will only contain characters a-z, A-Z, 0-9,\n        space, apostrophe, parentheses, comma, minus, plus, period,\n        forward slash, colon, equals, and question mark.\n",
        "line" : 1682,
        "char" : 12,
        "storageClass" : [
         "abstract"
        ],
        "type" : "const @property string()"
       },
       {
        "name" : "printableString",
        "kind" : "function",
        "comment" : "        Encodes a string that will only contain characters a-z, A-Z, 0-9,\n        space, apostrophe, parentheses, comma, minus, plus, period,\n        forward slash, colon, equals, and question mark.\n",
        "line" : 1690,
        "char" : 10,
        "storageClass" : [
         "abstract"
        ],
        "type" : "@property void(in string value)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "string",
          "storageClass" : [
           "in"
          ]
         }
        ]
       },
       {
        "name" : "__unittest___source_codec_d_1693_0",
        "kind" : "function",
        "line" : 1693,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 1715,
        "endchar" : 5
       },
       {
        "name" : "__unittest___source_codec_d_1716_0",
        "kind" : "function",
        "line" : 1716,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 1726,
        "endchar" : 5
       },
       {
        "name" : "t61String",
        "kind" : "alias",
        "comment" : "\n",
        "line" : 1726,
        "char" : 12,
        "type" : "teletexString"
       },
       {
        "name" : "teletexString",
        "kind" : "function",
        "comment" : "Decodes bytes representing the T.61 Character Set\n",
        "line" : 1729,
        "char" : 13,
        "storageClass" : [
         "abstract"
        ],
        "type" : "const @property ubyte[]()"
       },
       {
        "name" : "teletexString",
        "kind" : "function",
        "comment" : "Encodes bytes representing the T.61 Character Set\n",
        "line" : 1733,
        "char" : 10,
        "storageClass" : [
         "abstract"
        ],
        "type" : "@property void(in ubyte[] value)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "ubyte[]",
          "storageClass" : [
           "in"
          ]
         }
        ]
       },
       {
        "name" : "__unittest___source_codec_d_1736_0",
        "kind" : "function",
        "line" : 1736,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 1749,
        "endchar" : 5
       },
       {
        "name" : "__unittest___source_codec_d_1750_0",
        "kind" : "function",
        "line" : 1750,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 1760,
        "endchar" : 5
       },
       {
        "name" : "__unittest___source_codec_d_1761_0",
        "kind" : "function",
        "line" : 1761,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 1771,
        "endchar" : 5
       },
       {
        "name" : "videotexString",
        "kind" : "function",
        "line" : 1772,
        "char" : 13,
        "storageClass" : [
         "abstract"
        ],
        "type" : "const @property ubyte[]()"
       },
       {
        "name" : "videotexString",
        "kind" : "function",
        "line" : 1775,
        "char" : 10,
        "storageClass" : [
         "abstract"
        ],
        "type" : "@property void(in ubyte[] value)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "ubyte[]",
          "storageClass" : [
           "in"
          ]
         }
        ]
       },
       {
        "name" : "__unittest___source_codec_d_1778_0",
        "kind" : "function",
        "line" : 1778,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 1791,
        "endchar" : 5
       },
       {
        "name" : "__unittest___source_codec_d_1792_0",
        "kind" : "function",
        "line" : 1792,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 1802,
        "endchar" : 5
       },
       {
        "name" : "__unittest___source_codec_d_1803_0",
        "kind" : "function",
        "line" : 1803,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 1814,
        "endchar" : 5
       },
       {
        "name" : "ia5String",
        "kind" : "alias",
        "comment" : "\n",
        "line" : 1814,
        "char" : 12,
        "type" : "internationalAlphabetNumber5String"
       },
       {
        "name" : "internationalAlphabetNumber5String",
        "kind" : "function",
        "comment" : "Decodes a string of ASCII characters\n",
        "line" : 1817,
        "char" : 12,
        "storageClass" : [
         "abstract"
        ],
        "type" : "const @property string()"
       },
       {
        "name" : "internationalAlphabetNumber5String",
        "kind" : "function",
        "comment" : "Encodes a string of ASCII characters\n",
        "line" : 1821,
        "char" : 10,
        "storageClass" : [
         "abstract"
        ],
        "type" : "@property void(in string value)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "string",
          "storageClass" : [
           "in"
          ]
         }
        ]
       },
       {
        "name" : "__unittest___source_codec_d_1824_0",
        "kind" : "function",
        "line" : 1824,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 1838,
        "endchar" : 5
       },
       {
        "name" : "__unittest___source_codec_d_1839_0",
        "kind" : "function",
        "line" : 1839,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 1849,
        "endchar" : 5
       },
       {
        "name" : "utc",
        "kind" : "alias",
        "comment" : "\n",
        "line" : 1849,
        "char" : 12,
        "type" : "coordinatedUniversalTime"
       },
       {
        "name" : "utcTime",
        "kind" : "alias",
        "comment" : "\n",
        "line" : 1851,
        "char" : 12,
        "type" : "coordinatedUniversalTime"
       },
       {
        "name" : "coordinatedUniversalTime",
        "kind" : "function",
        "comment" : "Decodes a DateTime\n",
        "line" : 1854,
        "char" : 14,
        "storageClass" : [
         "abstract"
        ],
        "type" : "const @property DateTime()"
       },
       {
        "name" : "coordinatedUniversalTime",
        "kind" : "function",
        "comment" : "Encodes a DateTime\n",
        "line" : 1858,
        "char" : 10,
        "storageClass" : [
         "abstract"
        ],
        "type" : "@property void(in DateTime value)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "DateTime",
          "storageClass" : [
           "in"
          ]
         }
        ]
       },
       {
        "name" : "__unittest___source_codec_d_1861_0",
        "kind" : "function",
        "line" : 1861,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 1872,
        "endchar" : 5
       },
       {
        "name" : "generalizedTime",
        "kind" : "function",
        "comment" : "Decodes a DateTime\n",
        "line" : 1873,
        "char" : 14,
        "storageClass" : [
         "abstract"
        ],
        "type" : "const @property DateTime()"
       },
       {
        "name" : "generalizedTime",
        "kind" : "function",
        "comment" : "Encodes a DateTime\n",
        "line" : 1877,
        "char" : 10,
        "storageClass" : [
         "abstract"
        ],
        "type" : "@property void(in DateTime value)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "DateTime",
          "storageClass" : [
           "in"
          ]
         }
        ]
       },
       {
        "name" : "__unittest___source_codec_d_1880_0",
        "kind" : "function",
        "line" : 1880,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 1902,
        "endchar" : 5
       },
       {
        "name" : "graphicString",
        "kind" : "function",
        "comment" : "        Decodes an ASCII string that contains only characters between and\n        including 0x20 and 0x75.\n\n        Sources:\n            $(LINK2 ,\n                ASN.1: Communication Between Heterogeneous Systems, pages 175-178)\n            $(LINK2 https://en.wikipedia.org/wiki/ISO/IEC_2022,\n                The Wikipedia Page on ISO 2022)\n            $(LINK2 https://www.iso.org/standard/22747.html, ISO 2022)\n\n",
        "line" : 1904,
        "char" : 12,
        "storageClass" : [
         "abstract",
         "deprecated"
        ],
        "type" : "const @property string()"
       },
       {
        "name" : "graphicString",
        "kind" : "function",
        "comment" : "        Encodes an ASCII string that contains only characters between and\n        including 0x20 and 0x75.\n\n        Sources:\n            $(LINK2 ,\n                ASN.1: Communication Between Heterogeneous Systems, pages 175-178)\n            $(LINK2 https://en.wikipedia.org/wiki/ISO/IEC_2022,\n                The Wikipedia Page on ISO 2022)\n            $(LINK2 https://www.iso.org/standard/22747.html, ISO 2022)\n\n",
        "line" : 1920,
        "char" : 10,
        "storageClass" : [
         "abstract",
         "deprecated"
        ],
        "type" : "@property void(in string value)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "string",
          "storageClass" : [
           "in"
          ]
         }
        ]
       },
       {
        "name" : "__unittest___source_codec_d_1923_0",
        "kind" : "function",
        "line" : 1923,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 1946,
        "endchar" : 5
       },
       {
        "name" : "__unittest___source_codec_d_1947_0",
        "kind" : "function",
        "line" : 1947,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 1957,
        "endchar" : 5
       },
       {
        "name" : "iso646String",
        "kind" : "alias",
        "comment" : "\n",
        "line" : 1957,
        "char" : 12,
        "type" : "visibleString"
       },
       {
        "name" : "visibleString",
        "kind" : "function",
        "comment" : "        Decodes a string that only contains characters between and including\n        0x20 and 0x7E. (Honestly, I don't know how this differs from\n        GraphicalString.)\n",
        "line" : 1964,
        "char" : 12,
        "storageClass" : [
         "abstract"
        ],
        "type" : "const @property string()"
       },
       {
        "name" : "visibleString",
        "kind" : "function",
        "comment" : "        Encodes a string that only contains characters between and including\n        0x20 and 0x7E. (Honestly, I don't know how this differs from\n        GraphicalString.)\n",
        "line" : 1972,
        "char" : 10,
        "storageClass" : [
         "abstract"
        ],
        "type" : "@property void(in string value)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "string",
          "storageClass" : [
           "in"
          ]
         }
        ]
       },
       {
        "name" : "__unittest___source_codec_d_1975_0",
        "kind" : "function",
        "line" : 1975,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 1998,
        "endchar" : 5
       },
       {
        "name" : "__unittest___source_codec_d_1999_0",
        "kind" : "function",
        "line" : 1999,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 2009,
        "endchar" : 5
       },
       {
        "name" : "generalString",
        "kind" : "function",
        "comment" : "Decodes a string containing only ASCII characters.\n",
        "line" : 2011,
        "char" : 12,
        "storageClass" : [
         "abstract",
         "deprecated"
        ],
        "type" : "@property string()"
       },
       {
        "name" : "generalString",
        "kind" : "function",
        "comment" : "Encodes a string containing only ASCII characters.\n",
        "line" : 2016,
        "char" : 10,
        "storageClass" : [
         "abstract",
         "deprecated"
        ],
        "type" : "@property void(in string value)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "string",
          "storageClass" : [
           "in"
          ]
         }
        ]
       },
       {
        "name" : "__unittest___source_codec_d_2019_0",
        "kind" : "function",
        "line" : 2019,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 2033,
        "endchar" : 5
       },
       {
        "name" : "__unittest___source_codec_d_2034_0",
        "kind" : "function",
        "line" : 2034,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 2044,
        "endchar" : 5
       },
       {
        "name" : "universalString",
        "kind" : "function",
        "comment" : "Decodes a string of UTF-32 characters\n",
        "line" : 2045,
        "char" : 13,
        "storageClass" : [
         "abstract"
        ],
        "type" : "const @property dstring()"
       },
       {
        "name" : "universalString",
        "kind" : "function",
        "comment" : "Encodes a string of UTF-32 characters\n",
        "line" : 2049,
        "char" : 10,
        "storageClass" : [
         "abstract"
        ],
        "type" : "@property void(in dstring value)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "dstring",
          "storageClass" : [
           "in"
          ]
         }
        ]
       },
       {
        "name" : "__unittest___source_codec_d_2052_0",
        "kind" : "function",
        "line" : 2052,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 2065,
        "endchar" : 5
       },
       {
        "name" : "__unittest___source_codec_d_2066_0",
        "kind" : "function",
        "line" : 2066,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 2102,
        "endchar" : 5
       },
       {
        "name" : "characterString",
        "kind" : "function",
        "comment" : "        Decodes a CHARACTER STRING, which is a constructed data type, defined\n        in the $(LINK2 https://www.itu.int,\n                International Telecommunications Union)'s\n            $(LINK2 https://www.itu.int/rec/T-REC-X.680/en, X.680).\n\n        The specification defines CHARACTER as:\n\n        $(I\n            CHARACTER STRING ::= [UNIVERSAL 29] SEQUENCE {\n                identification CHOICE {\n                    syntaxes SEQUENCE {\n                        abstract OBJECT IDENTIFIER,\n                        transfer OBJECT IDENTIFIER },\n                    syntax OBJECT IDENTIFIER,\n                    presentation-context-id INTEGER,\n                    context-negotiation SEQUENCE {\n                        presentation-context-id INTEGER,\n                        transfer-syntax OBJECT IDENTIFIER },\n                    transfer-syntax OBJECT IDENTIFIER,\n                    fixed NULL },\n                string-value OCTET STRING }\n        )\n\n        This assumes AUTOMATIC TAGS, so all of the identification choices\n        will be context-specific and numbered from 0 to 5.\n",
        "line" : 2103,
        "char" : 21,
        "storageClass" : [
         "abstract"
        ],
        "type" : "const @property CharacterString()"
       },
       {
        "name" : "characterString",
        "kind" : "function",
        "comment" : "        Encodes a CHARACTER STRING, which is a constructed data type, defined\n        in the $(LINK2 https://www.itu.int,\n                International Telecommunications Union)'s\n            $(LINK2 https://www.itu.int/rec/T-REC-X.680/en, X.680).\n\n        The specification defines CHARACTER as:\n\n        $(I\n            CHARACTER STRING ::= [UNIVERSAL 29] SEQUENCE {\n                identification CHOICE {\n                    syntaxes SEQUENCE {\n                        abstract OBJECT IDENTIFIER,\n                        transfer OBJECT IDENTIFIER },\n                    syntax OBJECT IDENTIFIER,\n                    presentation-context-id INTEGER,\n                    context-negotiation SEQUENCE {\n                        presentation-context-id INTEGER,\n                        transfer-syntax OBJECT IDENTIFIER },\n                    transfer-syntax OBJECT IDENTIFIER,\n                    fixed NULL },\n                string-value OCTET STRING }\n        )\n\n        This assumes AUTOMATIC TAGS, so all of the identification choices\n        will be context-specific and numbered from 0 to 5.\n",
        "line" : 2133,
        "char" : 10,
        "storageClass" : [
         "abstract"
        ],
        "type" : "@property void(in CharacterString value)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "CharacterString",
          "storageClass" : [
           "in"
          ]
         }
        ]
       },
       {
        "name" : "__unittest___source_codec_d_2136_0",
        "kind" : "function",
        "line" : 2136,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 2158,
        "endchar" : 5
       },
       {
        "name" : "__unittest___source_codec_d_2159_0",
        "kind" : "function",
        "line" : 2159,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 2175,
        "endchar" : 5
       },
       {
        "name" : "__unittest___source_codec_d_2176_0",
        "kind" : "function",
        "line" : 2176,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 2192,
        "endchar" : 5
       },
       {
        "name" : "__unittest___source_codec_d_2193_0",
        "kind" : "function",
        "line" : 2193,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 2213,
        "endchar" : 5
       },
       {
        "name" : "bmpString",
        "kind" : "alias",
        "comment" : "\n",
        "line" : 2213,
        "char" : 12,
        "type" : "basicMultilingualPlaneString"
       },
       {
        "name" : "basicMultilingualPlaneString",
        "kind" : "function",
        "comment" : "Decodes a string of UTF-16 characters\n",
        "line" : 2216,
        "char" : 13,
        "storageClass" : [
         "abstract"
        ],
        "type" : "const @property wstring()"
       },
       {
        "name" : "basicMultilingualPlaneString",
        "kind" : "function",
        "comment" : "Encodes a string of UTF-16 characters\n",
        "line" : 2220,
        "char" : 10,
        "storageClass" : [
         "abstract"
        ],
        "type" : "@property void(in wstring value)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "wstring",
          "storageClass" : [
           "in"
          ]
         }
        ]
       },
       {
        "name" : "__unittest___source_codec_d_2223_0",
        "kind" : "function",
        "line" : 2223,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 2236,
        "endchar" : 5
       },
       {
        "name" : "__unittest___source_codec_d_2237_0",
        "kind" : "function",
        "line" : 2237,
        "char" : 5,
        "storageClass" : [
         "@system"
        ],
        "endline" : 2246,
        "endchar" : 1
       }
      ]
     }
    ]
   }
  ]
 },
 {
  "name" : "interfaces",
  "kind" : "module",
  "file" : "./source/interfaces.d",
  "members" : [
   {
    "name" : "Byteable",
    "kind" : "interface",
    "comment" : "    An interface for anything that can be converted to and from bytes.\n",
    "line" : 7,
    "char" : 1,
    "members" : [
     {
      "name" : "fromBytes",
      "kind" : "function",
      "comment" : "Returns: the number of bytes read from the start of the input array\n",
      "line" : 10,
      "char" : 19,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FxAhZm",
      "originalType" : "size_t(in ubyte[])",
      "parameters" : [
       {
        "deco" : "xAh"
       }
      ]
     },
     {
      "name" : "toBytes",
      "kind" : "function",
      "comment" : "Returns: the byte representation of the implementing instance\n",
      "line" : 12,
      "char" : 20,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "xFZAh"
     }
    ]
   }
  ]
 },
 {
  "name" : "types.alltypes",
  "kind" : "module",
  "file" : "./source/types/alltypes.d",
  "members" : [
   {
    "name" : "types.universal.characterstring",
    "kind" : "import",
    "line" : 3,
    "char" : 5
   },
   {
    "name" : "types.universal.embeddedpdv",
    "kind" : "import",
    "line" : 4,
    "char" : 5
   },
   {
    "name" : "types.universal.external",
    "kind" : "import",
    "line" : 5,
    "char" : 5
   },
   {
    "name" : "types.universal.objectidentifier",
    "kind" : "import",
    "line" : 6,
    "char" : 5
   }
  ]
 },
 {
  "name" : "types.identification",
  "kind" : "module",
  "file" : "./source/types/identification.d",
  "members" : [
   {
    "name" : "std.typecons",
    "kind" : "import",
    "line" : 2,
    "char" : 8,
    "protection" : "private",
    "selective" : [
     "Nullable"
    ]
   },
   {
    "name" : "types.universal.objectidentifier",
    "kind" : "import",
    "line" : 3,
    "char" : 8,
    "protection" : "private"
   },
   {
    "name" : "ASN1ContextNegotiation",
    "kind" : "struct",
    "comment" : "\n",
    "line" : 7,
    "char" : 1,
    "members" : [
     {
      "name" : "presentationContextID",
      "kind" : "variable",
      "comment" : "\n",
      "line" : 10,
      "char" : 22,
      "deco" : "l",
      "originalType" : "ptrdiff_t",
      "init" : "0L",
      "offset" : 0
     },
     {
      "name" : "transferSyntax",
      "kind" : "variable",
      "comment" : "\n",
      "line" : 12,
      "char" : 29,
      "deco" : "C5types9universal16objectidentifier16ObjectIdentifier",
      "originalType" : "ObjectIdentifier",
      "offset" : 8
     },
     {
      "name" : "directReference",
      "kind" : "alias",
      "line" : 15,
      "char" : 12
     },
     {
      "name" : "indirectReference",
      "kind" : "alias",
      "line" : 16,
      "char" : 12
     }
    ]
   },
   {
    "name" : "ASN1Syntaxes",
    "kind" : "struct",
    "comment" : "\n",
    "line" : 21,
    "char" : 1,
    "members" : [
     {
      "name" : "abstractSyntax",
      "kind" : "variable",
      "comment" : "\n",
      "line" : 24,
      "char" : 29,
      "deco" : "C5types9universal16objectidentifier16ObjectIdentifier",
      "originalType" : "ObjectIdentifier",
      "offset" : 0
     },
     {
      "name" : "transferSyntax",
      "kind" : "variable",
      "comment" : "\n",
      "line" : 26,
      "char" : 29,
      "deco" : "C5types9universal16objectidentifier16ObjectIdentifier",
      "originalType" : "ObjectIdentifier",
      "offset" : 8
     }
    ]
   },
   {
    "name" : "ASN1ContextSwitchingTypeID",
    "kind" : "alias",
    "comment" : "\n",
    "line" : 30,
    "char" : 8,
    "deco" : "S5types14identification38ASN1ContextSwitchingTypeIdentification"
   },
   {
    "name" : "ASN1ContextSwitchingTypeIdentification",
    "kind" : "struct",
    "comment" : "    This can be used for the creation of Externals, EmbeddedPDVs, and CharacterStrings.\n",
    "line" : 35,
    "char" : 1,
    "members" : [
     {
      "name" : "syntaxes",
      "kind" : "variable",
      "comment" : "\n",
      "line" : 38,
      "char" : 34,
      "deco" : "S3std8typecons__T8NullableTS5types14identification12ASN1SyntaxesZQBw",
      "originalType" : "Nullable!ASN1Syntaxes",
      "offset" : 0
     },
     {
      "name" : "syntax",
      "kind" : "variable",
      "comment" : "\n",
      "line" : 40,
      "char" : 38,
      "deco" : "S3std8typecons__T8NullableTC5types9universal16objectidentifier16ObjectIdentifierZQCm",
      "originalType" : "Nullable!ObjectIdentifier",
      "offset" : 24
     },
     {
      "name" : "presentationContextID",
      "kind" : "variable",
      "comment" : "\n",
      "line" : 42,
      "char" : 22,
      "deco" : "l",
      "originalType" : "ptrdiff_t",
      "init" : "0L",
      "offset" : 40
     },
     {
      "name" : "contextNegotiation",
      "kind" : "variable",
      "comment" : "\n",
      "line" : 44,
      "char" : 44,
      "deco" : "S3std8typecons__T8NullableTS5types14identification22ASN1ContextNegotiationZQCg",
      "originalType" : "Nullable!ASN1ContextNegotiation",
      "offset" : 48
     },
     {
      "name" : "transferSyntax",
      "kind" : "variable",
      "comment" : "\n",
      "line" : 46,
      "char" : 38,
      "deco" : "S3std8typecons__T8NullableTC5types9universal16objectidentifier16ObjectIdentifierZQCm",
      "originalType" : "Nullable!ObjectIdentifier",
      "offset" : 72
     },
     {
      "name" : "fixed",
      "kind" : "variable",
      "comment" : "\n",
      "line" : 48,
      "char" : 17,
      "deco" : "b",
      "offset" : 88
     },
     {
      "name" : "directReference",
      "kind" : "alias",
      "line" : 51,
      "char" : 12
     },
     {
      "name" : "indirectReference",
      "kind" : "alias",
      "line" : 52,
      "char" : 12
     }
    ]
   }
  ]
 },
 {
  "name" : "types.oidtype",
  "kind" : "module",
  "file" : "./source/types/oidtype.d",
  "members" : [
   {
    "name" : "asn1",
    "kind" : "import",
    "line" : 2,
    "char" : 8,
    "protection" : "private"
   },
   {
    "name" : "codec",
    "kind" : "import",
    "line" : 3,
    "char" : 8,
    "protection" : "private",
    "selective" : [
     "ASN1ValueInvalidException"
    ]
   },
   {
    "name" : "std.ascii",
    "kind" : "import",
    "line" : 4,
    "char" : 8,
    "protection" : "private",
    "selective" : [
     "isGraphical"
    ]
   },
   {
    "name" : "OIDNode",
    "kind" : "alias",
    "comment" : "\n",
    "line" : 7,
    "char" : 8,
    "deco" : "S5types7oidtype20ObjectIdentifierNode"
   },
   {
    "name" : "ObjectIdentifierNode",
    "kind" : "struct",
    "comment" : "    A struct representing a single node in an OID, which has a mandatory\n    number and an optional descriptor.\n",
    "line" : 13,
    "char" : 1,
    "members" : [
     {
      "name" : "number",
      "kind" : "variable",
      "comment" : "        The unique unsigned integral number associated with a node in the\n        object identifier hierarchy.\n",
      "line" : 19,
      "char" : 29,
      "storageClass" : [
       "immutable"
      ],
      "deco" : "ym",
      "originalType" : "size_t",
      "offset" : 0
     },
     {
      "name" : "descriptor",
      "kind" : "variable",
      "comment" : "        The descriptor string is an ObjectDescriptor, which is defined as:\n\n        $(I ObjectDescriptor ::= [UNIVERSAL 7] IMPLICIT GraphicString)\n\n        GraphicString is just 0x20 to 0x7E, therefore ObjectDescriptor is just\n        0x20 to 0x7E.\n\n        It is used to describe the object identified by this node.\n",
      "line" : 30,
      "char" : 29,
      "storageClass" : [
       "immutable"
      ],
      "deco" : "yAa",
      "originalType" : "string",
      "offset" : 8
     },
     {
      "name" : "opEquals",
      "kind" : "function",
      "comment" : "Override for use of the `==` operand.\n",
      "line" : 34,
      "char" : 10,
      "deco" : "xFNbNiNfxS5types7oidtype20ObjectIdentifierNodeZb",
      "originalType" : "const nothrow @nogc @safe bool(const OIDNode other)",
      "parameters" : [
       {
        "name" : "other",
        "deco" : "xS5types7oidtype20ObjectIdentifierNode"
       }
      ],
      "endline" : 37,
      "endchar" : 5
     },
     {
      "name" : "__unittest___source_types_oidtype_d_41_0",
      "kind" : "function",
      "comment" : "\n",
      "line" : 41,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 49,
      "endchar" : 5
     },
     {
      "name" : "opCmp",
      "kind" : "function",
      "comment" : "Override for the use of the '>', '<', '<=', and '>=' operands.\n",
      "line" : 50,
      "char" : 15,
      "deco" : "xFNbNiNfKxS5types7oidtype20ObjectIdentifierNodeZl",
      "originalType" : "const nothrow @nogc @safe ptrdiff_t(ref const OIDNode other)",
      "parameters" : [
       {
        "name" : "other",
        "deco" : "xS5types7oidtype20ObjectIdentifierNode",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 53,
      "endchar" : 5
     },
     {
      "name" : "toHash",
      "kind" : "function",
      "comment" : "        An override so that associative arrays can use an OIDNode as a\n        key.\n        Returns: A size_t that represents a hash of the OIDNode\n",
      "line" : 61,
      "char" : 12,
      "deco" : "xFNbNeZm",
      "originalType" : "const nothrow @trusted size_t()",
      "endline" : 64,
      "endchar" : 5
     },
     {
      "name" : "__unittest___source_types_oidtype_d_68_1",
      "kind" : "function",
      "comment" : "\n",
      "line" : 68,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 76,
      "endchar" : 5
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "The simple numeric constructor. Does not throw exceptions.\n",
      "line" : 77,
      "char" : 5,
      "deco" : "FNbNcNiNfxmZS5types7oidtype20ObjectIdentifierNode",
      "originalType" : "nothrow @nogc ref @safe (in size_t number)",
      "parameters" : [
       {
        "name" : "number",
        "deco" : "xm"
       }
      ],
      "endline" : 81,
      "endchar" : 5
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "        A constructor that accepts a descriptor string.\n        The descriptor string is an ObjectDescriptor, which is defined as:\n\n        $(I ObjectDescriptor ::= [UNIVERSAL 7] IMPLICIT GraphicString)\n\n        GraphicString is just 0x20 to 0x7E, therefore ObjectDescriptor is just\n        0x20 to 0x7E.\n\n        Sources:\n            $(LINK2 ,\n                ASN.1: Communication Between Heterogeneous Systems, pages 175-178)\n            $(LINK2 https://en.wikipedia.org/wiki/ISO/IEC_2022,\n                The Wikipedia Page on ISO 2022)\n            $(LINK2 https://www.iso.org/standard/22747.html, ISO 2022)\n\n        Returns: a string.\n        Throws:\n            ASN1ValueInvalidException = if the encoded value contains any bytes\n                outside of 0x20 to 0x7E.\n",
      "line" : 105,
      "char" : 5,
      "deco" : "FNcxmxAyaZS5types7oidtype20ObjectIdentifierNode",
      "originalType" : "ref @system (in size_t number, in string descriptor)",
      "parameters" : [
       {
        "name" : "number",
        "deco" : "xm"
       },
       {
        "name" : "descriptor",
        "deco" : "xAya"
       }
      ],
      "endline" : 130,
      "endchar" : 5
     },
     {
      "name" : "__unittest___source_types_oidtype_d_133_2",
      "kind" : "function",
      "line" : 133,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 150,
      "endchar" : 1
     }
    ]
   }
  ]
 },
 {
  "name" : "types.universal.characterstring",
  "kind" : "module",
  "file" : "./source/types/universal/characterstring.d",
  "members" : [
   {
    "name" : "types.identification",
    "kind" : "import",
    "line" : 2,
    "char" : 8,
    "protection" : "private"
   },
   {
    "name" : "CharacterString",
    "kind" : "struct",
    "comment" : "Page 309\nCHARACTER STRING ::= [UNIVERSAL 29] SEQUENCE {\n    identification CHOICE {\n        syntaxes SEQUENCE {\n            abstract OBJECT IDENTIFIER,\n            transfer OBJECT IDENTIFIER },\n        syntax OBJECT IDENTIFIER,\n        presentation-context-id INTEGER,\n        context-negotiation SEQUENCE {\n            presentation-context-id INTEGER,\n            transfer-syntax OBJECT IDENTIFIER },\n        transfer-syntax OBJECT IDENTIFIER,\n        fixed NULL },\n    string-value OCTET STRING }\n",
    "line" : 21,
    "char" : 1,
    "members" : [
     {
      "name" : "identification",
      "kind" : "variable",
      "comment" : "        A field indicating the the transfer syntax used to indicate the means\n        by which the string-value field is encoded. Can also be used to specify\n        the abstract syntax of what is encoded.\n",
      "line" : 28,
      "char" : 39,
      "deco" : "S5types14identification38ASN1ContextSwitchingTypeIdentification",
      "originalType" : "ASN1ContextSwitchingTypeID",
      "offset" : 0
     },
     {
      "name" : "stringValue",
      "kind" : "variable",
      "comment" : "The encoded data\n",
      "line" : 30,
      "char" : 20,
      "deco" : "Ah",
      "offset" : 96
     }
    ]
   }
  ]
 },
 {
  "name" : "types.universal.embeddedpdv",
  "kind" : "module",
  "file" : "./source/types/universal/embeddedpdv.d",
  "members" : [
   {
    "name" : "types.identification",
    "kind" : "import",
    "line" : 2,
    "char" : 8,
    "protection" : "private"
   },
   {
    "name" : "EmbeddedPDV",
    "kind" : "alias",
    "comment" : "\n",
    "line" : 10,
    "char" : 8,
    "deco" : "S5types9universal11embeddedpdv29EmbeddedPresentationDataValue"
   },
   {
    "name" : "EmbeddedPresentationDataValue",
    "kind" : "struct",
    "comment" : "    Page: 215\n    If a module includes the clause AUTOMATIC TAGS in its header,\n    the components of all its structured types (SEQUENCE, SET or CHOICE)\n    are automatically tagged by the compiler starting from 0 by one-increment.\n    By default, every component is tagged in the implicit mode except if it\n    is a CHOICE type, an open type or a parameter that is a type. This\n    tagging mechanism is obviously documented in the ASN.1 standard and,\n    as a result, does not depend on the compiler. Hence, the module:\n\n        $(I\n            M DEFINITIONS AUTOMATIC TAGS ::=\n            BEGIN\n                T ::= SEQUENCE { a INTEGER,\n                b CHOICE { i INTEGER, n NULL },\n                c REAL }\n            END\n        )\n\n    is equivalent, once applied the automatic tagging, to:\n\n        $(I\n            M DEFINITIONS ::=\n            BEGIN\n            T ::= SEQUENCE {\n            a [0] IMPLICIT INTEGER,\n            b [1] EXPLICIT CHOICE { i [0] IMPLICIT INTEGER,\n                                    n [1] IMPLICIT NULL },\n            c [2] IMPLICIT REAL }\n            END\n        )\n\n        $(I\n            EmbeddedPDV ::= [UNIVERSAL 11] IMPLICIT SEQUENCE {\n                identification CHOICE {\n                    syntaxes SEQUENCE {\n                        abstract OBJECT IDENTIFIER,\n                        transfer OBJECT IDENTIFIER },\n                    syntax OBJECT IDENTIFIER,\n                    presentation-context-id INTEGER,\n                    context-negotiation SEQUENCE {\n                        presentation-context-id INTEGER,\n                        transfer-syntax OBJECT IDENTIFIER },\n                    transfer-syntax OBJECT IDENTIFIER,\n                    fixed NULL },\n                data-value-descriptor ObjectDescriptor OPTIONAL,\n                data-value OCTET STRING }\n            (WITH COMPONENTS { ... , data-value-descriptor ABSENT })\n        )\n\n    Note that, the data-value-descriptor field should be absent!\n",
    "line" : 64,
    "char" : 1,
    "members" : [
     {
      "name" : "identification",
      "kind" : "variable",
      "comment" : "        A field indicating the the transfer syntax used to indicate the means\n        by which the data-value field is encoded. Can also be used to specify\n        the abstract syntax of what is encoded.\n",
      "line" : 71,
      "char" : 39,
      "deco" : "S5types14identification38ASN1ContextSwitchingTypeIdentification",
      "originalType" : "ASN1ContextSwitchingTypeID",
      "offset" : 0
     },
     {
      "name" : "dataValue",
      "kind" : "variable",
      "comment" : "The encoded data\n",
      "line" : 73,
      "char" : 20,
      "deco" : "Ah",
      "offset" : 96
     }
    ]
   }
  ]
 },
 {
  "name" : "types.universal.external",
  "kind" : "module",
  "file" : "./source/types/universal/external.d",
  "members" : [
   {
    "name" : "types.identification",
    "kind" : "import",
    "line" : 2,
    "char" : 8,
    "protection" : "private"
   },
   {
    "name" : "External",
    "kind" : "struct",
    "comment" : "    According to the\n    $(LINK2 http://www.itu.int/en/pages/default.aspx,\n        International Telecommunications Union)'s\n    $(LINK2 https://www.itu.int/rec/T-REC-X.680/en,\n        X.680 - Abstract Syntax Notation One (ASN.1)),\n    the abstract definition for an EXTERNAL, after removing the comments in the\n    specification, is as follows:\n\n    $(I\n        EXTERNAL ::= [UNIVERSAL 8] SEQUENCE {\n            identification CHOICE {\n                syntaxes SEQUENCE {\n                    abstract OBJECT IDENTIFIER,\n                    transfer OBJECT IDENTIFIER },\n                syntax OBJECT IDENTIFIER,\n                presentation-context-id INTEGER,\n                context-negotiation SEQUENCE {\n                    presentation-context-id INTEGER,\n                    transfer-syntax OBJECT IDENTIFIER },\n                transfer-syntax OBJECT IDENTIFIER,\n                fixed NULL },\n            data-value-descriptor ObjectDescriptor OPTIONAL,\n            data-value OCTET STRING }\n                ( WITH COMPONENTS {\n                    ... ,\n                    identification ( WITH COMPONENTS {\n                        ... ,\n                        syntaxes ABSENT,\n                        transfer-syntax ABSENT,\n                        fixed ABSENT } ) } )\n    )\n\n    Note that the abstract syntax resembles that of EMBEDDED PDV and\n    CharacterString, except with a WITH COMPONENTS constraint that removes some\n    of our choices of identification.\n    As can be seen on page 303 of Olivier Dubuisson's\n    $(I $(LINK2 http://www.oss.com/asn1/resources/books-whitepapers-pubs/dubuisson-asn1-book.PDF,\n        ASN.1: Communication Between Heterogeneous Systems)),\n    after applying the WITH COMPONENTS constraint, our reduced syntax becomes:\n\n    $(I\n        EXTERNAL ::= [UNIVERSAL 8] IMPLICIT SEQUENCE {\n            identification CHOICE {\n                syntax OBJECT IDENTIFIER,\n                presentation-context-id INTEGER,\n                context-negotiation SEQUENCE {\n                    presentation-context-id INTEGER,\n                    transfer-syntax OBJECT IDENTIFIER } },\n            data-value-descriptor ObjectDescriptor OPTIONAL,\n            data-value OCTET STRING }\n    )\n\n    But, according to the\n    $(LINK2 http://www.itu.int/en/pages/default.aspx,\n    International Telecommunications Union)'s\n    $(LINK2 http://www.itu.int/rec/T-REC-X.690/en, X.690 - ASN.1 encoding rules),\n    section 8.18, when encoded using Basic Encoding Rules (BER), is encoded as\n    follows, for compatibility reasons:\n\n    $(I\n        EXTERNAL ::= [UNIVERSAL 8] IMPLICIT SEQUENCE {\n            direct-reference  OBJECT IDENTIFIER OPTIONAL,\n            indirect-reference  INTEGER OPTIONAL,\n            data-value-descriptor  ObjectDescriptor  OPTIONAL,\n            encoding  CHOICE {\n                single-ASN1-type  [0] ANY,\n                octet-aligned     [1] IMPLICIT OCTET STRING,\n                arbitrary         [2] IMPLICIT BIT STRING } }\n    )\n\n    The definition above is the pre-1994 definition of EXTERNAL. The syntax\n    field of the post-1994 definition maps to the direct-reference field of\n    the pre-1994 definition. The presentation-context-id field of the post-1994\n    definition maps to the indirect-reference field of the pre-1994 definition.\n    If context-negotiation is used, per the abstract syntax, then the\n    presentation-context-id field of the context-negotiation SEQUENCE in the\n    post-1994 definition maps to the indirect-reference field of the pre-1994\n    definition, and the transfer-syntax field of the context-negotiation\n    SEQUENCE maps to the direct-reference field of the pre-1994 definition.\n\n    The following additional constraints are applied to the abstract syntax\n    when using Canonical Encoding Rules or Distinguished Encoding Rules,\n    which are also defined in the\n    $(LINK2 http://www.itu.int/en/pages/default.aspx,\n    International Telecommunications Union)'s\n    $(LINK2 http://www.itu.int/rec/T-REC-X.690/en, X.690 - ASN.1 encoding rules):\n\n    $(I\n        EXTERNAL ( WITH COMPONENTS {\n            ... ,\n            identification ( WITH COMPONENTS {\n                ... ,\n                presentation-context-id ABSENT,\n                context-negotiation ABSENT } ) } )\n    )\n\n    The stated purpose of the constraints shown above is to restrict the use of\n    the presentation-context-id, either by itself or within the\n    context-negotiation, which makes the following the effective abstract\n    syntax of EXTERNAL when using Canonical Encoding Rules or\n    Distinguished Encoding Rules:\n\n    $(I\n        EXTERNAL ::= [UNIVERSAL 8] SEQUENCE {\n            identification CHOICE {\n                syntaxes SEQUENCE {\n                    abstract OBJECT IDENTIFIER,\n                    transfer OBJECT IDENTIFIER },\n                syntax OBJECT IDENTIFIER,\n                presentation-context-id INTEGER,\n                context-negotiation SEQUENCE {\n                    presentation-context-id INTEGER,\n                    transfer-syntax OBJECT IDENTIFIER },\n                transfer-syntax OBJECT IDENTIFIER,\n                fixed NULL },\n            data-value-descriptor ObjectDescriptor OPTIONAL,\n            data-value OCTET STRING }\n                ( WITH COMPONENTS {\n                    ... ,\n                    identification ( WITH COMPONENTS {\n                        ... ,\n                        syntaxes ABSENT,\n                        presentation-context-id ABSENT,\n                        context-negotiation ABSENT,\n                        transfer-syntax ABSENT,\n                        fixed ABSENT } ) } )\n    )\n\n    With the constraints applied, the abstract syntax for EXTERNALs encoded\n    using Canonical Encoding Rules or Distinguished Encoding Rules becomes:\n\n    $(I\n        EXTERNAL ::= [UNIVERSAL 8] SEQUENCE {\n            identification CHOICE {\n                syntax OBJECT IDENTIFIER },\n            data-value-descriptor ObjectDescriptor OPTIONAL,\n            data-value OCTET STRING }\n    )\n\n    Upon removing the CHOICE tag (since you have no choice but to use syntax\n    at this point), the encoding definition when using\n    Canonical Encoding Rules or Distinguished Encoding Rules:\n\n    $(I\n        EXTERNAL ::= [UNIVERSAL 8] SEQUENCE {\n            syntax OBJECT IDENTIFIER,\n            data-value-descriptor ObjectDescriptor OPTIONAL,\n            data-value OCTET STRING }\n    )\n\n    For all encoding rules defined in the\n    $(LINK2 http://www.itu.int/en/pages/default.aspx,\n    International Telecommunications Union)'s\n    $(LINK2 http://www.itu.int/rec/T-REC-X.690/en, X.690 - ASN.1 encoding rules)\n    (meaning Basic Encoding Rules, Canonical Encoding Rules, and\n    Distinguished Encoding Rules), EXPLICIT tagging must be used when encoding\n    the EXTERNAL type. Unlike the other Context-Switching Types, automatic\n    tagging is NOT used when encoding with Basic Encoding Rules,\n    Canonical Encoding Rules, or Distinguished Encoding Rules.\n",
    "line" : 166,
    "char" : 1,
    "members" : [
     {
      "name" : "identification",
      "kind" : "variable",
      "comment" : "        A field indicating the the transfer syntax used to indicate the means\n        by which the data-value field is encoded. Can also be used to specify\n        the abstract syntax of what is encoded.\n",
      "line" : 173,
      "char" : 39,
      "deco" : "S5types14identification38ASN1ContextSwitchingTypeIdentification",
      "originalType" : "ASN1ContextSwitchingTypeID",
      "offset" : 0
     },
     {
      "name" : "dataValueDescriptor",
      "kind" : "variable",
      "comment" : "An optional field used to describe the encoded data.\n",
      "line" : 175,
      "char" : 19,
      "deco" : "Aya",
      "offset" : 96
     },
     {
      "name" : "dataValue",
      "kind" : "variable",
      "comment" : "The encoded data\n",
      "line" : 177,
      "char" : 20,
      "deco" : "Ah",
      "offset" : 112
     },
     {
      "name" : "encoding",
      "kind" : "variable",
      "comment" : "        A field that exists only to determine the developer's choice of\n        encoding used, per the pre-1994 definition of EXTERNAL.\n\n        octet-aligned is a sensible default, since it is the most lax of the\n        three choices.\n",
      "line" : 185,
      "char" : 32,
      "deco" : "E5types9universal8external45AbstractSyntaxNotation1ExternalEncodingChoice",
      "originalType" : "ASN1ExternalEncodingChoice",
      "init" : "cast(AbstractSyntaxNotation1ExternalEncodingChoice)cast(ubyte)1u",
      "offset" : 128
     }
    ]
   },
   {
    "name" : "ASN1ExternalEncodingChoice",
    "kind" : "alias",
    "comment" : "\n",
    "line" : 189,
    "char" : 8,
    "deco" : "E5types9universal8external45AbstractSyntaxNotation1ExternalEncodingChoice"
   },
   {
    "name" : "AbstractSyntaxNotation1ExternalEncodingChoice",
    "kind" : "enum",
    "comment" : "    The CHOICE of encoding used for the encoding of a pre-1994 EXTERNAL,\n    as used by the Basic Encoding Rules, Canonical Encoding Rules, or\n    Distinguished Encoding Rules.\n",
    "line" : 196,
    "char" : 1,
    "baseDeco" : "h",
    "members" : [
     {
      "name" : "singleASN1Type",
      "kind" : "enum member",
      "value" : "cast(ubyte)0u",
      "comment" : "single-ASN1-type [0] ABSTRACT-SYNTAX.&Type\n",
      "line" : 199,
      "char" : 5
     },
     {
      "name" : "singleAbstractSyntaxNotation1Type",
      "kind" : "enum member",
      "value" : "cast(ubyte)0u",
      "comment" : "single-ASN1-type [0] ABSTRACT-SYNTAX.&Type\n",
      "line" : 201,
      "char" : 5
     },
     {
      "name" : "octetAligned",
      "kind" : "enum member",
      "value" : "cast(ubyte)1u",
      "comment" : "octet-aligned [1] IMPLICIT OCTET STRING\n",
      "line" : 203,
      "char" : 5
     },
     {
      "name" : "arbitrary",
      "kind" : "enum member",
      "value" : "cast(ubyte)2u",
      "comment" : "arbitrary [2] IMPLICIT BIT STRING\n",
      "line" : 205,
      "char" : 5
     }
    ]
   }
  ]
 },
 {
  "name" : "types.universal.objectidentifier",
  "kind" : "module",
  "file" : "./source/types/universal/objectidentifier.d",
  "members" : [
   {
    "name" : "asn1",
    "kind" : "import",
    "line" : 2,
    "char" : 8,
    "protection" : "private"
   },
   {
    "name" : "types.oidtype",
    "kind" : "import",
    "line" : 3,
    "char" : 8,
    "protection" : "private"
   },
   {
    "name" : "std.array",
    "kind" : "import",
    "line" : 4,
    "char" : 8,
    "protection" : "private",
    "selective" : [
     "appender",
     "Appender"
    ]
   },
   {
    "name" : "OIDException",
    "kind" : "alias",
    "comment" : "\n",
    "line" : 7,
    "char" : 8,
    "deco" : "C5types9universal16objectidentifier25ObjectIdentifierException"
   },
   {
    "name" : "ObjectIDException",
    "kind" : "alias",
    "comment" : "\n",
    "line" : 9,
    "char" : 8,
    "deco" : "C5types9universal16objectidentifier25ObjectIdentifierException"
   },
   {
    "name" : "ObjectIdentifierException",
    "kind" : "class",
    "comment" : "\n",
    "line" : 12,
    "char" : 1,
    "base" : "asn1.AbstractSyntaxNotation1Exception",
    "members" : [
     {
      "name" : "std.exception",
      "kind" : "import",
      "line" : 14,
      "char" : 12,
      "protection" : "private",
      "selective" : [
       "basicExceptionCtors"
      ]
     },
     {
      "name" : "basicExceptionCtors!()",
      "kind" : "mixin",
      "line" : 15,
      "char" : 5
     }
    ]
   },
   {
    "name" : "OID",
    "kind" : "alias",
    "comment" : "\n",
    "line" : 19,
    "char" : 8,
    "deco" : "C5types9universal16objectidentifier16ObjectIdentifier"
   },
   {
    "name" : "ObjectID",
    "kind" : "alias",
    "comment" : "\n",
    "line" : 21,
    "char" : 8,
    "deco" : "C5types9universal16objectidentifier16ObjectIdentifier"
   },
   {
    "name" : "ObjectIdentifier",
    "kind" : "class",
    "comment" : "    A class for Object Identifiers, that supports object descriptors and various\n    output formatting.\n",
    "line" : 26,
    "char" : 8,
    "members" : [
     {
      "name" : "std.conv",
      "kind" : "import",
      "line" : 28,
      "char" : 12,
      "protection" : "private",
      "selective" : [
       "text"
      ]
     },
     {
      "name" : "showDescriptors",
      "kind" : "variable",
      "line" : 30,
      "char" : 24,
      "storageClass" : [
       "static"
      ],
      "deco" : "b",
      "init" : "true"
     },
     {
      "name" : "nodes",
      "kind" : "variable",
      "line" : 31,
      "char" : 32,
      "storageClass" : [
       "immutable"
      ],
      "deco" : "yAS5types7oidtype20ObjectIdentifierNode",
      "originalType" : "OIDNode[]",
      "offset" : 16
     },
     {
      "name" : "length",
      "kind" : "function",
      "comment" : "Returns: the number of nodes in the OID.\n",
      "line" : 35,
      "char" : 12,
      "deco" : "xFNdNfZm",
      "originalType" : "const @property @safe size_t()",
      "endline" : 38,
      "endchar" : 5
     },
     {
      "name" : "__unittest___source_types_universal_objectidentifier_d_41_0",
      "kind" : "function",
      "line" : 41,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 58,
      "endchar" : 5
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "        Constructor for an Object Identifier\n\n        Params:\n            numbers = an array of unsigned integer representing the Object Identifier\n        Returns: An OID object\n        Throws:\n            OIDException = if fewer than three numbers are provided, or if the\n                first number is not 0, 1, or 2, or if the second number is\n                greater than 39.\n",
      "line" : 59,
      "char" : 5,
      "deco" : "FNfxAmXC5types9universal16objectidentifier16ObjectIdentifier",
      "originalType" : "@safe (in size_t[] numbers...)",
      "parameters" : [
       {
        "name" : "numbers",
        "deco" : "xAm"
       }
      ],
      "endline" : 94,
      "endchar" : 5
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "        Constructor for an Object Identifier\n\n        Params:\n            nodes = An array of OIDNodes\n        Returns: An OID object\n        Throws:\n            OIDException = if fewer than three nodes are provided, or if the\n                first node is not 0, 1, or 2, or if the second node is greater\n                than 39.\n",
      "line" : 109,
      "char" : 5,
      "deco" : "FNfAS5types7oidtype20ObjectIdentifierNodeXCQBm9universal16objectidentifier16ObjectIdentifier",
      "originalType" : "@safe (OIDNode[] nodes...)",
      "parameters" : [
       {
        "name" : "nodes",
        "deco" : "AS5types7oidtype20ObjectIdentifierNode"
       }
      ],
      "endline" : 138,
      "endchar" : 5
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "        Constructor for an Object Identifier\n\n        Params:\n            nodes = An array of OIDNodes\n        Returns: An OID object\n        Throws:\n            OIDException = if fewer than three nodes are provided, or if the\n                first node is not 0, 1, or 2, or if the second node is greater\n                than 39.\n",
      "line" : 152,
      "char" : 5,
      "deco" : "FNfxAyaZC5types9universal16objectidentifier16ObjectIdentifier",
      "originalType" : "@safe (in string str)",
      "parameters" : [
       {
        "name" : "str",
        "deco" : "xAya"
       }
      ],
      "endline" : 199,
      "endchar" : 5
     },
     {
      "name" : "__unittest___source_types_universal_objectidentifier_d_202_1",
      "kind" : "function",
      "line" : 202,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 223,
      "endchar" : 5
     },
     {
      "name" : "opEquals",
      "kind" : "function",
      "line" : 224,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFxC6ObjectZb",
      "originalType" : "const @system bool(in Object other)",
      "parameters" : [
       {
        "name" : "other",
        "deco" : "xC6Object"
       }
      ],
      "endline" : 234,
      "endchar" : 5,
      "overrides" : [
       "object.Object.opEquals"
      ]
     },
     {
      "name" : "__unittest___source_types_universal_objectidentifier_d_237_2",
      "kind" : "function",
      "line" : 237,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 253,
      "endchar" : 5
     },
     {
      "name" : "opIndex",
      "kind" : "function",
      "comment" : "        Returns: the OIDNode at the specified index.\n        Throws:\n            RangeError = if invalid index specified.\n",
      "line" : 254,
      "char" : 13,
      "deco" : "xFNbNiNfxlZS5types7oidtype20ObjectIdentifierNode",
      "originalType" : "const nothrow @nogc @safe OIDNode(in ptrdiff_t index)",
      "parameters" : [
       {
        "name" : "index",
        "deco" : "xl"
       }
      ],
      "endline" : 257,
      "endchar" : 5
     },
     {
      "name" : "__unittest___source_types_universal_objectidentifier_d_260_3",
      "kind" : "function",
      "line" : 260,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 271,
      "endchar" : 5
     },
     {
      "name" : "opSlice",
      "kind" : "function",
      "comment" : "        Returns: a range of OIDNodes from the OID.\n        Throws:\n            RangeError = if invalid indices are specified.\n",
      "line" : 272,
      "char" : 15,
      "deco" : "xFNbNixlxlZAS5types7oidtype20ObjectIdentifierNode",
      "originalType" : "const nothrow @nogc @system OIDNode[](in ptrdiff_t index1, in ptrdiff_t index2)",
      "parameters" : [
       {
        "name" : "index1",
        "deco" : "xl"
       },
       {
        "name" : "index2",
        "deco" : "xl"
       }
      ],
      "endline" : 275,
      "endchar" : 5
     },
     {
      "name" : "opDollar",
      "kind" : "function",
      "comment" : "        Returns: the length of the OID.\n",
      "line" : 281,
      "char" : 12,
      "deco" : "xFNbNiNfZm",
      "originalType" : "const nothrow @nogc @safe size_t()",
      "endline" : 284,
      "endchar" : 5
     },
     {
      "name" : "descriptor",
      "kind" : "function",
      "comment" : "        Returns: The descriptor at the specified index.\n        Throws:\n            RangeError = if invalid index specified.\n",
      "line" : 292,
      "char" : 12,
      "deco" : "xFNbNiNfxmZAya",
      "originalType" : "const nothrow @nogc @safe string(in size_t index)",
      "parameters" : [
       {
        "name" : "index",
        "deco" : "xm"
       }
      ],
      "endline" : 295,
      "endchar" : 5
     },
     {
      "name" : "__unittest___source_types_universal_objectidentifier_d_298_4",
      "kind" : "function",
      "line" : 298,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 306,
      "endchar" : 5
     },
     {
      "name" : "numbers",
      "kind" : "alias",
      "comment" : "\n",
      "line" : 306,
      "char" : 12
     },
     {
      "name" : "numericArray",
      "kind" : "function",
      "comment" : "        Returns:\n            an array of $(D size_t)s representing the dot-delimited sequence of\n            integers that constitute the numeric OID.\n",
      "line" : 313,
      "char" : 14,
      "deco" : "xFNbNdNfZAm",
      "originalType" : "const nothrow @property @safe size_t[]()",
      "endline" : 322,
      "endchar" : 5
     },
     {
      "name" : "__unittest___source_types_universal_objectidentifier_d_325_5",
      "kind" : "function",
      "line" : 325,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 332,
      "endchar" : 5
     },
     {
      "name" : "asn1Notation",
      "kind" : "alias",
      "comment" : "\n",
      "line" : 332,
      "char" : 12
     },
     {
      "name" : "abstractSyntaxNotation1Notation",
      "kind" : "function",
      "comment" : "        Returns: the OID in ASN.1 Notation\n",
      "line" : 337,
      "char" : 12,
      "deco" : "xFNbNdNfZAya",
      "endline" : 353,
      "endchar" : 5
     },
     {
      "name" : "__unittest___source_types_universal_objectidentifier_d_356_6",
      "kind" : "function",
      "line" : 356,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 372,
      "endchar" : 5
     },
     {
      "name" : "dotNotation",
      "kind" : "function",
      "comment" : "        Returns:\n            the OID as a dot-delimited string, where all nodes with descriptors\n            are represented as descriptors instead of numbers\n",
      "line" : 373,
      "char" : 12,
      "deco" : "xFNbNdNfZAya",
      "endline" : 389,
      "endchar" : 5
     },
     {
      "name" : "__unittest___source_types_universal_objectidentifier_d_392_7",
      "kind" : "function",
      "line" : 392,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 404,
      "endchar" : 5
     },
     {
      "name" : "iriNotation",
      "kind" : "alias",
      "comment" : "\n",
      "line" : 404,
      "char" : 12
     },
     {
      "name" : "uriNotation",
      "kind" : "alias",
      "comment" : "\n",
      "line" : 406,
      "char" : 12
     },
     {
      "name" : "uniformResourceIdentifierNotation",
      "kind" : "alias",
      "comment" : "\n",
      "line" : 408,
      "char" : 12
     },
     {
      "name" : "internationalizedResourceIdentifierNotation",
      "kind" : "function",
      "comment" : "        Returns:\n            the OID as a forward-slash-delimited string (as one might expect in\n            a URI / IRI path), where all nodes with descriptors are represented\n            as descriptors instead of numbers\n",
      "line" : 416,
      "char" : 12,
      "deco" : "xFNdZAya",
      "endline" : 433,
      "endchar" : 5
     },
     {
      "name" : "__unittest___source_types_universal_objectidentifier_d_436_8",
      "kind" : "function",
      "line" : 436,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 448,
      "endchar" : 5
     },
     {
      "name" : "urnNotation",
      "kind" : "alias",
      "comment" : "\n",
      "line" : 448,
      "char" : 12
     },
     {
      "name" : "uniformResourceNameNotation",
      "kind" : "function",
      "comment" : "        Returns:\n            the OID as a URN, where all nodes of the OID are translated to a\n            segment in the URN path, and where all nodes are represented as\n            numbers regardless of whether or not they have a descriptor\n        See_Also:\n            $(LINK2 https://www.ietf.org/rfc/rfc3061.txt, RFC 3061)\n",
      "line" : 458,
      "char" : 12,
      "deco" : "xFNbNdNfZAya",
      "endline" : 467,
      "endchar" : 5
     },
     {
      "name" : "__unittest___source_types_universal_objectidentifier_d_470_9",
      "kind" : "function",
      "line" : 470,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 482,
      "endchar" : 5
     },
     {
      "name" : "toString",
      "kind" : "function",
      "comment" : "\n",
      "line" : 483,
      "char" : 12,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdZAya",
      "endline" : 486,
      "endchar" : 5,
      "overrides" : [
       "object.Object.toString"
      ]
     },
     {
      "name" : "toHash",
      "kind" : "function",
      "comment" : "        An override so that associative arrays can use an OIDNode as a\n        key.\n        Returns: A size_t that represents a hash of the OIDNode\n",
      "line" : 494,
      "char" : 12,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNbNeZm",
      "originalType" : "const nothrow @trusted size_t()",
      "endline" : 502,
      "endchar" : 5,
      "overrides" : [
       "object.Object.toHash"
      ]
     }
    ]
   }
  ]
 },
 {
  "name" : "codecs.ber",
  "kind" : "module",
  "file" : "./source/codecs/ber.d",
  "comment" : "    Basic Encoding Rules (BER) is a standard for encoding ASN.1 data. It is by\n    far the most common standard for doing so, being used in LDAP, TLS, SNMP,\n    RDP, and other protocols. Like Distinguished Encoding Rules (DER),\n    Canonical Encoding Rules (CER), and Packed Encoding Rules (PER), Basic\n    Encoding Rules is a specification created by the\n    $(LINK2 http://www.itu.int/en/pages/default.aspx,\n        International Telecommunications Union),\n    and specified in\n    $(LINK2 http://www.itu.int/rec/T-REC-X.690/en, X.690 - ASN.1 encoding rules)\n\n    BER is generally regarded as the most flexible of the encoding schemes,\n    because all values can be encoded in a multitude of ways. This flexibility\n    might be convenient for developers who use a BER Library, but creating\n    a BER library in the first place is a nightmare, because of its flexibility.\n    I personally suspect that the complexity of BER may make its implementation\n    inclined to security vulnerabilities, so I would not use it if you have a\n    choice in the matter. Also, the ability to represent values in several\n    different ways is actually a security problem when data has to be guarded\n    against tampering with a cryptographic signature. (Basically, it makes it\n    a lot easier to find a tampered payload that has the identical signature\n    as the genuine payload.)\n\n    Author:\n        $(LINK2 http://jonathan.wilbur.space, Jonathan M. Wilbur)\n            $(LINK2 mailto:jonathan@wilbur.space, jonathan@wilbur.space)\n    License: $(LINK2 https://mit-license.org/, MIT License)\n    Standards:\n        $(LINK2 https://www.itu.int/rec/T-REC-X.680/en, X.680 - Abstract Syntax Notation One (ASN.1))\n        $(LINK2 http://www.itu.int/rec/T-REC-X.690/en, X.690 - ASN.1 encoding rules)\n    See_Also:\n        $(LINK2 https://en.wikipedia.org/wiki/Abstract_Syntax_Notation_One, The Wikipedia Page on ASN.1)\n        $(LINK2 https://en.wikipedia.org/wiki/X.690, The Wikipedia Page on X.690)\n        $(LINK2 https://www.strozhevsky.com/free_docs/asn1_in_simple_words.pdf, ASN.1 By Simple Words)\n        $(LINK2 http://www.oss.com/asn1/resources/books-whitepapers-pubs/dubuisson-asn1-book.PDF, ASN.1: Communication Between Heterogeneous Systems)\n",
  "members" : [
   {
    "name" : "codec",
    "kind" : "import",
    "line" : 38,
    "char" : 15
   },
   {
    "name" : "interfaces",
    "kind" : "import",
    "line" : 39,
    "char" : 15,
    "selective" : [
     "Byteable"
    ]
   },
   {
    "name" : "types.identification",
    "kind" : "import",
    "line" : 40,
    "char" : 15
   },
   {
    "name" : "berOID",
    "kind" : "alias",
    "comment" : "\n",
    "line" : 43,
    "char" : 8
   },
   {
    "name" : "berObjectID",
    "kind" : "alias",
    "comment" : "\n",
    "line" : 45,
    "char" : 8
   },
   {
    "name" : "berObjectIdentifier",
    "kind" : "alias",
    "comment" : "\n",
    "line" : 47,
    "char" : 8
   },
   {
    "name" : "basicEncodingRulesObjectIdentifier",
    "kind" : "variable",
    "comment" : "    The object identifier assigned to the Basic Encoding Rules (BER), per the\n    $(LINK2 http://www.itu.int/en/pages/default.aspx,\n        International Telecommunications Union)'s,\n    $(LINK2 http://www.itu.int/rec/T-REC-X.690/en, X.690 - ASN.1 encoding rules)\n\n    $(I {joint-iso-itu-t asn1 (1) basic-encoding (1)} )\n",
    "line" : 56,
    "char" : 22,
    "storageClass" : [
     "immutable"
    ],
    "deco" : "yC5types9universal16objectidentifier16ObjectIdentifier",
    "originalType" : "OID",
    "init" : "ObjectIdentifier([ObjectIdentifierNode(2LU, \"\"), ObjectIdentifierNode(1LU, \"\"), ObjectIdentifierNode(1LU, \"\")])"
   },
   {
    "name" : "BERElement",
    "kind" : "alias",
    "comment" : "\n",
    "line" : 59,
    "char" : 8,
    "deco" : "C6codecs3ber25BasicEncodingRulesElement"
   },
   {
    "name" : "BasicEncodingRulesElement",
    "kind" : "class",
    "comment" : "    The unit of encoding and decoding for Basic Encoding Rules (BER).\n\n    There are three parts to an element encoded according to the Basic\n    Encoding Rules (BER):\n\n    $(UL\n        $(LI A Type Tag, which specifies what data type is encoded)\n        $(LI A Length Tag, which specifies how many subsequent bytes encode the data)\n        $(LI The Encoded Value)\n    )\n\n    They appear in the binary encoding in that order, and as such, the encoding\n    scheme is sometimes described as \"TLV,\" which stands for Type-Length-Value.\n\n    This class provides a properties for getting and setting bit fields of\n    the type tag, but most of it is functionality for encoding data per\n    the specification.\n\n    As an example, this is what encoding a simple INTEGER looks like:\n\n    ---\n    BERElement bv = new BERElement();\n    bv.tagNumber = 0x02u; // \"2\" means this is an INTEGER\n    bv.integer = 1433; // Now the data is encoded.\n    transmit(cast(ubyte[]) bv); // transmit() is a made-up function.\n    ---\n\n    And this is what decoding looks like:\n\n    ---\n    ubyte[] data = receive(); // receive() is a made-up function.\n    BERElement bv2 = new BERElement(data);\n\n    long x;\n    if (bv.tagNumber == 0x02u) // it is an INTEGER\n    {\n        x = bv.integer;\n    }\n    // Now x is 1433!\n    ---\n",
    "line" : 112,
    "char" : 1,
    "base" : "codec.ASN1Element!(codecs.ber.BasicEncodingRulesElement).AbstractSyntaxNotation1Element",
    "interfaces" : [
     "interfaces.Byteable"
    ],
    "members" : [
     {
      "name" : "__unittest___source_codecs_ber_d_115_0",
      "kind" : "function",
      "line" : 115,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 128,
      "endchar" : 5
     },
     {
      "name" : "lengthEncodingPreference",
      "kind" : "variable",
      "comment" : "        Unlike most other settings, this is non-static, because wanting to\n        encode with indefinite length is probably going to be somewhat rare,\n        and it is also less safe, because the value octets have to be inspected\n        for double octets before encoding! (If they are not, the receiver will\n        interpret those inner null octets as the terminator for the indefinite\n        length value, and the rest will be truncated.)\n",
      "line" : 128,
      "char" : 37,
      "deco" : "E5codec__T30AbstractSyntaxNotation1ElementTC6codecs3ber25BasicEncodingRulesElementZQCv24LengthEncodingPreference",
      "init" : "cast(LengthEncodingPreference)cast(ubyte)0u",
      "offset" : 144
     },
     {
      "name" : "nestingRecursionCount",
      "kind" : "variable",
      "protection" : "protected",
      "comment" : "The number of recursions used for parsing constructed elements.\n",
      "line" : 132,
      "char" : 29,
      "storageClass" : [
       "static"
      ],
      "deco" : "m",
      "originalType" : "size_t",
      "init" : "0LU"
     },
     {
      "name" : "nestingRecursionLimit",
      "kind" : "variable",
      "comment" : "The limit of recursions permitted for parsing constructed elements.\n",
      "line" : 135,
      "char" : 29,
      "storageClass" : [
       "static",
       "immutable"
      ],
      "deco" : "ym",
      "originalType" : "size_t",
      "init" : "5LU"
     },
     {
      "name" : "tagClass",
      "kind" : "variable",
      "line" : 137,
      "char" : 25,
      "deco" : "E4asn131AbstractSyntaxNotation1TagClass",
      "originalType" : "ASN1TagClass",
      "offset" : 145
     },
     {
      "name" : "construction",
      "kind" : "variable",
      "line" : 138,
      "char" : 29,
      "deco" : "E4asn135AbstractSyntaxNotation1Construction",
      "originalType" : "ASN1Construction",
      "offset" : 146
     },
     {
      "name" : "tagNumber",
      "kind" : "variable",
      "line" : 139,
      "char" : 19,
      "deco" : "m",
      "originalType" : "size_t",
      "offset" : 152
     },
     {
      "name" : "length",
      "kind" : "function",
      "comment" : "The length of the value in octets\n",
      "line" : 143,
      "char" : 12,
      "deco" : "xFNbNdNfZm",
      "originalType" : "const nothrow @property @safe size_t()",
      "endline" : 146,
      "endchar" : 5
     },
     {
      "name" : "value",
      "kind" : "variable",
      "line" : 164,
      "char" : 20,
      "deco" : "Ah",
      "offset" : 160
     },
     {
      "name" : "boolean",
      "kind" : "function",
      "comment" : "        Decodes a boolean.\n\n        Any non-zero value will be interpreted as TRUE. Only zero will be\n        interpreted as FALSE.\n\n        Returns: a boolean\n        Throws:\n            ASN1ValueSizeException = if the encoded value is anything other\n                than exactly 1 byte in size.\n",
      "line" : 178,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdNfZb",
      "endline" : 192,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(BasicEncodingRulesElement).AbstractSyntaxNotation1Element.boolean"
      ]
     },
     {
      "name" : "boolean",
      "kind" : "function",
      "comment" : "        Encodes a boolean.\n\n        Any non-zero value will be interpreted as TRUE. Only zero will be\n        interpreted as FALSE.\n",
      "line" : 201,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNbNdNfxbZv",
      "originalType" : "nothrow @property @safe void(in bool value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xb"
       }
      ],
      "endline" : 209,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(BasicEncodingRulesElement).AbstractSyntaxNotation1Element.boolean"
      ],
      "out" : {
       "name" : "__ensure",
       "kind" : "function",
       "line" : 203,
       "char" : 5,
       "deco" : "FNaNbNiNfZv",
       "originalType" : "nothrow @safe void()",
       "endline" : 203,
       "endchar" : 5
      }
     },
     {
      "name" : "__unittest___source_codecs_ber_d_213_0",
      "kind" : "function",
      "comment" : "\n",
      "line" : 213,
      "char" : 5,
      "storageClass" : [
       "@safe"
      ],
      "endline" : 239,
      "endchar" : 5
     },
     {
      "kind" : "template",
      "comment" : "        Decodes a signed integer.\n\n        Bytes are stored in big-endian order, where the bytes represent\n        the two's complement encoding of the integer.\n\n        Returns: any chosen signed integral type\n        Throws:\n            ASN1ValueTooBigException = if the value is too big to decode\n                to a signed integral type.\n",
      "line" : 240,
      "char" : 7,
      "name" : "integer",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "constraint" : "isIntegral!T && isSigned!T",
      "members" : [
       {
        "name" : "integer",
        "kind" : "function",
        "line" : 240,
        "char" : 7,
        "type" : "const @property @system T()",
        "endline" : 312,
        "endchar" : 5
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "        Encodes an integer.\n\n        Bytes are stored in big-endian order, where the bytes represent\n        the two's complement encoding of the integer.\n",
      "line" : 321,
      "char" : 10,
      "name" : "integer",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "constraint" : "isIntegral!T && isSigned!T",
      "members" : [
       {
        "name" : "integer",
        "kind" : "function",
        "line" : 321,
        "char" : 10,
        "type" : "nothrow @property @system void(in T value)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "T",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 378,
        "endchar" : 5
       }
      ]
     },
     {
      "name" : "__unittest___source_codecs_ber_d_382_0",
      "kind" : "function",
      "line" : 382,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 406,
      "endchar" : 5
     },
     {
      "name" : "__unittest___source_codecs_ber_d_407_0",
      "kind" : "function",
      "line" : 407,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 440,
      "endchar" : 5
     },
     {
      "name" : "bitString",
      "kind" : "function",
      "comment" : "        Encodes an array of $(D bool)s representing a string of bits.\n\n        In Basic Encoding Rules, the first byte is an unsigned\n        integral byte indicating the number of unused bits at the end of\n        the BIT STRING. The unused bits can be anything.\n\n        Returns: an array of booleans.\n        Throws:\n            ASN1ValueInvalidException = if the first byte has a value greater\n                than seven.\n",
      "line" : 441,
      "char" : 12,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZAb",
      "endline" : 505,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(BasicEncodingRulesElement).AbstractSyntaxNotation1Element.bitString"
      ]
     },
     {
      "name" : "bitString",
      "kind" : "function",
      "comment" : "        Encodes an array of $(D bool)s representing a string of bits.\n\n        In Basic Encoding Rules, the first byte is an unsigned\n        integral byte indicating the number of unused bits at the end of\n        the BIT STRING. The unused bits can be anything.\n",
      "line" : 515,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxAbZv",
      "originalType" : "@property void(in bool[] value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAb"
       }
      ],
      "endline" : 531,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(BasicEncodingRulesElement).AbstractSyntaxNotation1Element.bitString"
      ],
      "out" : {
       "name" : "__ensure",
       "kind" : "function",
       "line" : 517,
       "char" : 5,
       "deco" : "FNaNbNiNfZv",
       "originalType" : "void()",
       "endline" : 517,
       "endchar" : 5
      }
     },
     {
      "name" : "__unittest___source_codecs_ber_d_535_0",
      "kind" : "function",
      "line" : 535,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 547,
      "endchar" : 5
     },
     {
      "name" : "octetString",
      "kind" : "function",
      "comment" : "        Decodes an OCTET STRING into an unsigned byte array.\n\n        Returns: an unsigned byte array.\n",
      "line" : 548,
      "char" : 13,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdNfZAh",
      "endline" : 551,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(BasicEncodingRulesElement).AbstractSyntaxNotation1Element.octetString"
      ]
     },
     {
      "name" : "octetString",
      "kind" : "function",
      "comment" : "        Encodes an OCTET STRING from an unsigned byte array.\n",
      "line" : 557,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdNfxAhZv",
      "originalType" : "@property @safe void(in ubyte[] value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAh"
       }
      ],
      "endline" : 560,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(BasicEncodingRulesElement).AbstractSyntaxNotation1Element.octetString"
      ]
     },
     {
      "name" : "objectIdentifier",
      "kind" : "function",
      "comment" : "        Decodes an OBJECT IDENTIFIER.\n        See source/types/universal/objectidentifier.d for information about\n        the ObjectIdentifier class (aliased as \"OID\").\n\n        The encoded OBJECT IDENTIFIER's first byte contains the first number\n        of the OID multiplied by 40 and added to the second number of the OID.\n        The subsequent bytes have all the remaining number encoded in base-128\n        on the least significant 7 bits of each byte. For these bytes, the most\n        significant bit is set if the next byte continues the encoding of the\n        current OID number. In other words, the bytes encoding each number\n        always end with a byte whose most significant bit is cleared.\n\n        Throws:\n            ASN1ValueTooSmallException = if an attempt is made to decode\n                an Object Identifier from zero bytes.\n            ASN1ValueTooBigException = if a single OID number is too big to\n                decode to a size_t.\n        Standards:\n            $(LINK2 http://www.itu.int/rec/T-REC-X.660-201107-I/en, X.660)\n",
      "line" : 584,
      "char" : 9,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZC5types9universal16objectidentifier16ObjectIdentifier",
      "originalType" : "const @property @system OID()",
      "endline" : 688,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(BasicEncodingRulesElement).AbstractSyntaxNotation1Element.objectIdentifier"
      ],
      "out" : {
       "name" : "__ensure",
       "kind" : "function",
       "line" : 586,
       "char" : 5,
       "deco" : "FKxC5types9universal16objectidentifier16ObjectIdentifierZv",
       "originalType" : "@system void(ref const ObjectIdentifier value)",
       "parameters" : [
        {
         "name" : "value",
         "deco" : "xC5types9universal16objectidentifier16ObjectIdentifier",
         "storageClass" : [
          "ref"
         ]
        }
       ],
       "endline" : 586,
       "endchar" : 5
      }
     },
     {
      "name" : "objectIdentifier",
      "kind" : "function",
      "comment" : "        Encodes an OBJECT IDENTIFIER.\n        See source/types/universal/objectidentifier.d for information about\n        the ObjectIdentifier class (aliased as \"OID\").\n\n        The encoded OBJECT IDENTIFIER's first byte contains the first number\n        of the OID multiplied by 40 and added to the second number of the OID.\n        The subsequent bytes have all the remaining number encoded in base-128\n        on the least significant 7 bits of each byte. For these bytes, the most\n        significant bit is set if the next byte continues the encoding of the\n        current OID number. In other words, the bytes encoding each number\n        always end with a byte whose most significant bit is cleared.\n\n        Standards:\n            $(LINK2 http://www.itu.int/rec/T-REC-X.660-201107-I/en, X.660)\n",
      "line" : 707,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxC5types9universal16objectidentifier16ObjectIdentifierZv",
      "originalType" : "@property @system void(in OID value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xC5types9universal16objectidentifier16ObjectIdentifier"
       }
      ],
      "endline" : 750,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(BasicEncodingRulesElement).AbstractSyntaxNotation1Element.objectIdentifier"
      ],
      "in" : {
       "name" : "__require",
       "kind" : "function",
       "line" : 709,
       "char" : 5,
       "type" : "@system void()",
       "endline" : 709,
       "endchar" : 5
      },
      "out" : {
       "name" : "__ensure",
       "kind" : "function",
       "line" : 718,
       "char" : 5,
       "deco" : "FNaNbNiZv",
       "originalType" : "@system void()",
       "endline" : 718,
       "endchar" : 5
      }
     },
     {
      "name" : "__unittest___source_codecs_ber_d_753_0",
      "kind" : "function",
      "line" : 753,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 772,
      "endchar" : 5
     },
     {
      "name" : "__unittest___source_codecs_ber_d_773_0",
      "kind" : "function",
      "line" : 773,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 824,
      "endchar" : 5
     },
     {
      "name" : "objectDescriptor",
      "kind" : "function",
      "comment" : "        Decodes an ObjectDescriptor, which is a string consisting of only\n        graphical characters. In fact, ObjectDescriptor is actually implicitly\n        just a GraphicString! The formal specification for an ObjectDescriptor\n        is:\n\n        $(I ObjectDescriptor ::= [UNIVERSAL 7] IMPLICIT GraphicString)\n\n        GraphicString is just 0x20 to 0x7E, therefore ObjectDescriptor is just\n        0x20 to 0x7E.\n\n        Citations:\n            Dubuisson, Olivier. “Character String Types.” ASN.1:\n                Communication between Heterogeneous Systems, Morgan\n                Kaufmann, 2001, pp. 175-178.\n            $(LINK2 https://en.wikipedia.org/wiki/ISO/IEC_2022,\n                The Wikipedia Page on ISO 2022)\n            $(LINK2 https://www.iso.org/standard/22747.html, ISO 2022)\n\n        Returns: a string.\n        Throws:\n            ASN1ValueInvalidException = if the encoded value contains any bytes\n                outside of 0x20 to 0x7E.\n",
      "line" : 825,
      "char" : 12,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZAya",
      "endline" : 843,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(BasicEncodingRulesElement).AbstractSyntaxNotation1Element.objectDescriptor"
      ]
     },
     {
      "name" : "objectDescriptor",
      "kind" : "function",
      "comment" : "        Encodes an ObjectDescriptor, which is a string consisting of only\n        graphical characters. In fact, ObjectDescriptor is actually implicitly\n        just a GraphicString! The formal specification for an ObjectDescriptor\n        is:\n\n        $(I ObjectDescriptor ::= [UNIVERSAL 7] IMPLICIT GraphicString)\n\n        GraphicString is just 0x20 to 0x7E, therefore ObjectDescriptor is just\n        0x20 to 0x7E.\n\n        Citations:\n            Dubuisson, Olivier. “Character String Types.” ASN.1:\n                Communication between Heterogeneous Systems, Morgan\n                Kaufmann, 2001, pp. 175-178.\n            $(LINK2 https://en.wikipedia.org/wiki/ISO/IEC_2022,\n                The Wikipedia Page on ISO 2022)\n            $(LINK2 https://www.iso.org/standard/22747.html, ISO 2022)\n\n        Throws:\n            ASN1ValueInvalidException = if the string value contains any\n                character outside of 0x20 to 0x7E, which means any control\n                characters or DELETE.\n",
      "line" : 870,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxAyaZv",
      "originalType" : "@property @system void(in string value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAya"
       }
      ],
      "endline" : 888,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(BasicEncodingRulesElement).AbstractSyntaxNotation1Element.objectDescriptor"
      ]
     },
     {
      "name" : "external",
      "kind" : "function",
      "comment" : "        Decodes an EXTERNAL, which is a constructed data type, defined in\n        the $(LINK2 https://www.itu.int,\n            International Telecommunications Union)'s\n        $(LINK2 https://www.itu.int/rec/T-REC-X.680/en, X.680).\n\n        The specification defines EXTERNAL as:\n\n        $(I\n            EXTERNAL := [UNIVERSAL 8] IMPLICIT SEQUENCE {\n                identification CHOICE {\n                    syntax OBJECT IDENTIFIER,\n                    presentation-context-id INTEGER,\n                    context-negotiation SEQUENCE {\n                        presentation-context-id INTEGER,\n                        transfer-syntax OBJECT IDENTIFIER } },\n                data-value-descriptor ObjectDescriptor OPTIONAL,\n                data-value OCTET STRING }\n        )\n\n        This assumes AUTOMATIC TAGS, so all of the identification choices\n        will be context-specific and numbered from 0 to 2.\n\n        Returns: an External, defined in types.universal.external.\n        Throws:\n            ASN1SizeException = if encoded EmbeddedPDV has too few or too many\n                elements, or if syntaxes or context-negotiation element has\n                too few or too many elements.\n            ASN1ValueTooBigException = if encoded INTEGER is too large to decode.\n            ASN1ValueInvalidException = if encoded ObjectDescriptor contains\n                invalid characters.\n            ASN1InvalidIndexException = if encoded value selects a choice for\n                identification or uses an unspecified index for an element in\n                syntaxes or context-negotiation, or if an unspecified element\n                of EMBEDDED PDV itself is referenced by an out-of-range\n                context-specific index. (See $(D_INLINECODE ASN1InvalidIndexException).)\n\n        EXTERNAL ::= [UNIVERSAL 8] IMPLICIT SEQUENCE {\n            direct-reference  OBJECT IDENTIFIER OPTIONAL,\n            indirect-reference  INTEGER OPTIONAL,\n            data-value-descriptor  ObjectDescriptor  OPTIONAL,\n            encoding  CHOICE {\n                single-ASN1-type  [0] ANY,\n                octet-aligned     [1] IMPLICIT OCTET STRING,\n                arbitrary         [2] IMPLICIT BIT STRING } }\n",
      "line" : 937,
      "char" : 14,
      "storageClass" : [
       "deprecated",
       "override"
      ],
      "deco" : "xFNdZS5types9universal8external8External",
      "endline" : 1175,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(BasicEncodingRulesElement).AbstractSyntaxNotation1Element.external"
      ]
     },
     {
      "name" : "external",
      "kind" : "function",
      "comment" : "        Encodes an EXTERNAL, which is a constructed data type, defined in\n        the $(LINK2 https://www.itu.int,\n            International Telecommunications Union)'s\n        $(LINK2 https://www.itu.int/rec/T-REC-X.680/en, X.680).\n\n        The specification defines EXTERNAL as:\n\n        $(I\n            EXTERNAL := [UNIVERSAL 8] IMPLICIT SEQUENCE {\n                identification CHOICE {\n                    syntax OBJECT IDENTIFIER,\n                    presentation-context-id INTEGER,\n                    context-negotiation SEQUENCE {\n                        presentation-context-id INTEGER,\n                        transfer-syntax OBJECT IDENTIFIER } },\n                data-value-descriptor ObjectDescriptor OPTIONAL,\n                data-value OCTET STRING }\n        )\n\n        This assumes AUTOMATIC TAGS, so all of the identification choices\n        will be context-specific and numbered from 0 to 2.\n\n        Throws:\n            ASN1ValueTooBigException = if encoded INTEGER is too large to decode\n            ASN1ValueInvalidException = if encoded ObjectDescriptor contains\n                invalid characters.\n\n        EXTERNAL  ::=  [UNIVERSAL 8] IMPLICIT SEQUENCE {\n            direct-reference  OBJECT IDENTIFIER OPTIONAL,\n            indirect-reference  INTEGER OPTIONAL,\n            data-value-descriptor  ObjectDescriptor  OPTIONAL,\n            encoding  CHOICE {\n                single-ASN1-type  [0] ANY,\n                octet-aligned     [1] IMPLICIT OCTET STRING,\n                arbitrary         [2] IMPLICIT BIT STRING } }\n",
      "line" : 1215,
      "char" : 10,
      "storageClass" : [
       "deprecated",
       "override"
      ],
      "deco" : "FNdxS5types9universal8external8ExternalZv",
      "originalType" : "@property @system void(in External value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xS5types9universal8external8External"
       }
      ],
      "endline" : 1263,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(BasicEncodingRulesElement).AbstractSyntaxNotation1Element.external"
      ],
      "out" : {
       "name" : "__ensure",
       "kind" : "function",
       "line" : 1217,
       "char" : 5,
       "deco" : "FNaNbNiZv",
       "originalType" : "@system void()",
       "endline" : 1217,
       "endchar" : 5
      }
     },
     {
      "name" : "__unittest___source_codecs_ber_d_1271_0",
      "kind" : "function",
      "line" : 1271,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 1294,
      "endchar" : 5
     },
     {
      "name" : "__unittest___source_codecs_ber_d_1295_0",
      "kind" : "function",
      "line" : 1295,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 1322,
      "endchar" : 5
     },
     {
      "name" : "__unittest___source_codecs_ber_d_1323_0",
      "kind" : "function",
      "line" : 1323,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 1351,
      "endchar" : 5
     },
     {
      "name" : "__unittest___source_codecs_ber_d_1352_0",
      "kind" : "function",
      "line" : 1352,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 1448,
      "endchar" : 5
     },
     {
      "kind" : "template",
      "comment" : "        Decodes a float or double. This can never decode directly to a\n        real type, because of the way it works.\n\n        For the BER-encoded REAL, a value of 0x40 means \"positive infinity,\"\n        a value of 0x41 means \"negative infinity.\" An empty value means\n        exactly zero. A value whose first byte starts with two cleared bits\n        encodes the real as a string of characters, where the latter nybble\n        takes on values of 0x1, 0x2, or 0x3 to indicate that the string\n        representation conforms to\n        $(LINK2 https://www.iso.org/standard/12285.html, ISO 6093)\n        Numeric Representation 1, 2, or 3 respectively.\n\n        If the first bit is set, then the first byte is an \"information block\"\n        that describes the binary encoding of the REAL on the subsequent bytes.\n        If bit 6 is set, the value is negative; if clear, the value is\n        positive. Bits 4 and 5 determine the base, with a value of 0 indicating\n        a base of 2, a value of 1 indicating a base of 8, and a value of 2\n        indicating a base of 16. Bits 2 and 3 indicates that the value should\n        be scaled by 1, 2, 4, or 8 for values of 1, 2, 3, or 4 respectively.\n        Bits 0 and 1 determine how the exponent is encoded, with 0 indicating\n        that the exponent is encoded as a signed byte on the second byte of\n        the value, with 1 indicating that the exponent is encoded as a signed\n        short on the subsequent two bytes, with 2 indicating that the exponent\n        is encoded as a three-byte signed integer on the subsequent three\n        bytes, and with 4 indicating that the subsequent byte encodes the\n        unsigned length of the exponent on the following bytes. The remaining\n        bytes encode an unsigned integer, N, such that mantissa is equal to\n        sign * N * 2^scale.\n\n        Note that this method assumes that your machine uses IEEE 754 floating\n        point format.\n\n        If you attempt to decode a REAL that is too big to fit into the selected\n        floating point type, the value of the real will quietly set to zero. This\n        cannot happen if the transmitted value is in base-2, but it can happen if\n        the transmitted value is in base-8 or base-16.\n\n        Throws:\n            ConvException = if character-encoding cannot be converted to\n                the selected floating-point type, T.\n            ConvOverflowException = if the character-encoding encodes a\n                number that is too big for the selected floating-point\n                type to express.\n            ASN1ValueTooSmallException = if the binary-encoding contains fewer\n                bytes than the information byte purports.\n            ASN1ValueTooBigException = if the binary-encoded mantissa is too\n                big to be expressed by an unsigned long integer.\n            ASN1ValueInvalidException = if both bits indicating the base in the\n                information byte of a binary-encoded REAL's information byte\n                are set, which would indicate an invalid base.\n\n        Citations:\n            Dubuisson, Olivier. “Basic Encoding Rules (BER).” ASN.1:\n            Communication between Heterogeneous Systems, Morgan Kaufmann,\n            2001, pp. 400–402.\n",
      "line" : 1449,
      "char" : 7,
      "name" : "realNumber",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "constraint" : "isFloatingPoint!T",
      "members" : [
       {
        "name" : "realNumber",
        "kind" : "function",
        "line" : 1449,
        "char" : 7,
        "type" : "const @property @system T()",
        "endline" : 1756,
        "endchar" : 5
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "        Encodes a float or double. This can never decode directly to a\n        real type, because of the way it works.\n\n        This is admittedly a pretty slow function, so I would recommend\n        avoiding it, if possible. Also, because it is so complex, it is\n        highly likely to have bugs, so for that reason as well, I highly\n        recommand against encoding or decoding REALs if you do not have\n        to; try using INTEGER instead.\n\n        For the BER-encoded REAL, a value of 0x40 means \"positive infinity,\"\n        a value of 0x41 means \"negative infinity.\" An empty value means\n        exactly zero. A value whose first byte starts with two cleared bits\n        encodes the real as a string of characters, where the latter nybble\n        takes on values of 0x1, 0x2, or 0x3 to indicate that the string\n        representation conforms to\n        $(LINK2 , ISO 6093) Numeric Representation 1, 2, or 3 respectively.\n\n        If the first bit is set, then the first byte is an \"information block\"\n        that describes the binary encoding of the REAL on the subsequent bytes.\n        If bit 6 is set, the value is negative; if clear, the value is\n        positive. Bits 4 and 5 determine the base, with a value of 0 indicating\n        a base of 2, a value of 1 indicating a base of 8, and a value of 2\n        indicating a base of 16. Bits 2 and 3 indicates that the value should\n        be scaled by 1, 2, 4, or 8 for values of 1, 2, 3, or 4 respectively.\n        Bits 0 and 1 determine how the exponent is encoded, with 0 indicating\n        that the exponent is encoded as a signed byte on the second byte of\n        the value, with 1 indicating that the exponent is encoded as a signed\n        short on the subsequent two bytes, with 2 indicating that the exponent\n        is encoded as a three-byte signed integer on the subsequent three\n        bytes, and with 4 indicating that the subsequent byte encodes the\n        unsigned length of the exponent on the following bytes. The remaining\n        bytes encode an unsigned integer, N, such that mantissa is equal to\n        sign * N * 2^scale.\n\n        Note that this method assumes that your machine uses IEEE 754 floating\n        point format.\n\n        Throws:\n            ASN1ValueInvalidException = if an attempt to encode NaN is made.\n            ASN1ValueTooSmallException = if an attempt to encode would result\n                in an arithmetic underflow of a signed short.\n            ASN1ValueTooBigException = if an attempt to encode would result\n                in an arithmetic overflow of a signed short.\n\n        Citations:\n            Dubuisson, Olivier. “Basic Encoding Rules (BER).” ASN.1:\n            Communication between Heterogeneous Systems, Morgan Kaufmann,\n            2001, pp. 400–402.\n",
      "line" : 1809,
      "char" : 10,
      "name" : "realNumber",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "constraint" : "isFloatingPoint!T",
      "members" : [
       {
        "name" : "realNumber",
        "kind" : "function",
        "line" : 1809,
        "char" : 10,
        "type" : "@property @system void(in T value)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "T",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 1950,
        "endchar" : 5
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "        Decodes an integer from an ENUMERATED type. In BER, an ENUMERATED\n        type is encoded the exact same way that an INTEGER is.\n\n        Returns: any chosen signed integral type\n        Throws:\n            ASN1ValueTooBigException = if the value is too big to decode\n                to a signed integral type.\n",
      "line" : 2059,
      "char" : 7,
      "name" : "enumerated",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "constraint" : "isIntegral!T && isSigned!T",
      "members" : [
       {
        "name" : "enumerated",
        "kind" : "function",
        "line" : 2059,
        "char" : 7,
        "type" : "const @property @system T()",
        "endline" : 2131,
        "endchar" : 5
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "        Encodes an ENUMERATED type from an integer. In BER, an ENUMERATED\n        type is encoded the exact same way that an INTEGER is.\n",
      "line" : 2138,
      "char" : 10,
      "name" : "enumerated",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "enumerated",
        "kind" : "function",
        "line" : 2138,
        "char" : 10,
        "type" : "nothrow @property @system void(in T value)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "T",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 2195,
        "endchar" : 5
       }
      ]
     },
     {
      "name" : "__unittest___source_codecs_ber_d_2199_0",
      "kind" : "function",
      "line" : 2199,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 2223,
      "endchar" : 5
     },
     {
      "name" : "__unittest___source_codecs_ber_d_2224_0",
      "kind" : "function",
      "line" : 2224,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 2287,
      "endchar" : 5
     },
     {
      "name" : "embeddedPresentationDataValue",
      "kind" : "function",
      "comment" : "        Decodes an EMBEDDED PDV, which is a constructed data type, defined in\n            the $(LINK2 https://www.itu.int,\n                International Telecommunications Union)'s\n            $(LINK2 https://www.itu.int/rec/T-REC-X.680/en, X.680).\n\n        The specification defines EMBEDDED PDV as:\n\n        $(I\n            EmbeddedPDV ::= [UNIVERSAL 11] IMPLICIT SEQUENCE {\n                identification CHOICE {\n                    syntaxes SEQUENCE {\n                        abstract OBJECT IDENTIFIER,\n                        transfer OBJECT IDENTIFIER },\n                    syntax OBJECT IDENTIFIER,\n                    presentation-context-id INTEGER,\n                    context-negotiation SEQUENCE {\n                        presentation-context-id INTEGER,\n                        transfer-syntax OBJECT IDENTIFIER },\n                    transfer-syntax OBJECT IDENTIFIER,\n                    fixed NULL },\n                data-value-descriptor ObjectDescriptor OPTIONAL,\n                data-value OCTET STRING }\n            (WITH COMPONENTS { ... , data-value-descriptor ABSENT })\n        )\n\n        This assumes AUTOMATIC TAGS, so all of the identification choices\n        will be context-specific and numbered from 0 to 5.\n\n        Throws:\n            ASN1SizeException = if encoded EmbeddedPDV has too few or too many\n                elements, or if syntaxes or context-negotiation element has\n                too few or too many elements.\n            ASN1ValueTooBigException = if encoded INTEGER is too large to decode.\n            ASN1ValueInvalidException = if encoded ObjectDescriptor contains\n                invalid characters.\n            ASN1InvalidIndexException = if encoded value selects a choice for\n                identification or uses an unspecified index for an element in\n                syntaxes or context-negotiation, or if an unspecified element\n                of EMBEDDED PDV itself is referenced by an out-of-range\n                context-specific index. (See $(D_INLINECODE ASN1InvalidIndexException).)\n",
      "line" : 2288,
      "char" : 17,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZS5types9universal11embeddedpdv29EmbeddedPresentationDataValue",
      "originalType" : "const @property @system EmbeddedPDV()",
      "endline" : 2490,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(BasicEncodingRulesElement).AbstractSyntaxNotation1Element.embeddedPresentationDataValue"
      ]
     },
     {
      "name" : "embeddedPresentationDataValue",
      "kind" : "function",
      "comment" : "        Encodes an EMBEDDED PDV, which is a constructed data type, defined in\n            the $(LINK2 https://www.itu.int,\n                International Telecommunications Union)'s\n            $(LINK2 https://www.itu.int/rec/T-REC-X.680/en, X.680).\n\n        The specification defines EMBEDDED PDV as:\n\n        $(I\n            EmbeddedPDV ::= [UNIVERSAL 11] IMPLICIT SEQUENCE {\n                identification CHOICE {\n                    syntaxes SEQUENCE {\n                        abstract OBJECT IDENTIFIER,\n                        transfer OBJECT IDENTIFIER },\n                    syntax OBJECT IDENTIFIER,\n                    presentation-context-id INTEGER,\n                    context-negotiation SEQUENCE {\n                        presentation-context-id INTEGER,\n                        transfer-syntax OBJECT IDENTIFIER },\n                    transfer-syntax OBJECT IDENTIFIER,\n                    fixed NULL },\n                data-value-descriptor ObjectDescriptor OPTIONAL,\n                data-value OCTET STRING }\n            (WITH COMPONENTS { ... , data-value-descriptor ABSENT })\n        )\n\n        This assumes AUTOMATIC TAGS, so all of the identification choices\n        will be context-specific and numbered from 0 to 5.\n\n        Throws:\n            ASN1ValueInvalidException = if encoded ObjectDescriptor contains\n                invalid characters.\n",
      "line" : 2526,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxS5types9universal11embeddedpdv29EmbeddedPresentationDataValueZv",
      "originalType" : "@property @system void(in EmbeddedPDV value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xS5types9universal11embeddedpdv29EmbeddedPresentationDataValue"
       }
      ],
      "endline" : 2599,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(BasicEncodingRulesElement).AbstractSyntaxNotation1Element.embeddedPresentationDataValue"
      ],
      "out" : {
       "name" : "__ensure",
       "kind" : "function",
       "line" : 2528,
       "char" : 5,
       "deco" : "FNaNbNiZv",
       "originalType" : "@system void()",
       "endline" : 2528,
       "endchar" : 5
      }
     },
     {
      "name" : "__unittest___source_codecs_ber_d_2606_0",
      "kind" : "function",
      "line" : 2606,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 2627,
      "endchar" : 5
     },
     {
      "name" : "__unittest___source_codecs_ber_d_2628_0",
      "kind" : "function",
      "line" : 2628,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 2650,
      "endchar" : 5
     },
     {
      "name" : "__unittest___source_codecs_ber_d_2651_0",
      "kind" : "function",
      "line" : 2651,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 2693,
      "endchar" : 5
     },
     {
      "name" : "unicodeTransformationFormat8String",
      "kind" : "function",
      "comment" : "        Decodes the value to UTF-8 characters.\n\n        Throws:\n            UTF8Exception if it does not decode correctly.\n",
      "line" : 2694,
      "char" : 12,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZAya",
      "endline" : 2697,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(BasicEncodingRulesElement).AbstractSyntaxNotation1Element.unicodeTransformationFormat8String"
      ]
     },
     {
      "name" : "unicodeTransformationFormat8String",
      "kind" : "function",
      "comment" : "        Encodes a UTF-8 string to bytes. No checks are performed.\n",
      "line" : 2703,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNbNdxAyaZv",
      "originalType" : "nothrow @property @system void(in string value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAya"
       }
      ],
      "endline" : 2706,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(BasicEncodingRulesElement).AbstractSyntaxNotation1Element.unicodeTransformationFormat8String"
      ]
     },
     {
      "name" : "relativeObjectIdentifier",
      "kind" : "function",
      "comment" : "        Decodes a RELATIVE OBJECT IDENTIFIER.\n        See source/types/universal/objectidentifier.d for information about\n        the ObjectIdentifier class (aliased as \"OID\").\n\n        The RELATIVE OBJECT IDENTIFIER's numbers are encoded in base-128\n        on the least significant 7 bits of each byte. For these bytes, the most\n        significant bit is set if the next byte continues the encoding of the\n        current OID number. In other words, the bytes encoding each number\n        always end with a byte whose most significant bit is cleared.\n\n        Standards:\n            $(LINK2 http://www.itu.int/rec/T-REC-X.660-201107-I/en, X.660)\n",
      "line" : 2723,
      "char" : 15,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZAS5types7oidtype20ObjectIdentifierNode",
      "originalType" : "const @property @system OIDNode[]()",
      "endline" : 2795,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(BasicEncodingRulesElement).AbstractSyntaxNotation1Element.relativeObjectIdentifier"
      ]
     },
     {
      "name" : "relativeObjectIdentifier",
      "kind" : "function",
      "comment" : "        Encodes a RELATIVE OBJECT IDENTIFIER.\n        See source/types/universal/objectidentifier.d for information about\n        the ObjectIdentifier class (aliased as \"OID\").\n\n        The RELATIVE OBJECT IDENTIFIER's numbers are encoded in base-128\n        on the least significant 7 bits of each byte. For these bytes, the most\n        significant bit is set if the next byte continues the encoding of the\n        current OID number. In other words, the bytes encoding each number\n        always end with a byte whose most significant bit is cleared.\n\n        Standards:\n            $(LINK2 http://www.itu.int/rec/T-REC-X.660-201107-I/en, X.660)\n",
      "line" : 2812,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNbNdxAS5types7oidtype20ObjectIdentifierNodeZv",
      "originalType" : "nothrow @property @system void(in OIDNode[] value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAS5types7oidtype20ObjectIdentifierNode"
       }
      ],
      "endline" : 2837,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(BasicEncodingRulesElement).AbstractSyntaxNotation1Element.relativeObjectIdentifier"
      ]
     },
     {
      "name" : "__unittest___source_codecs_ber_d_2840_0",
      "kind" : "function",
      "line" : 2840,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 2859,
      "endchar" : 5
     },
     {
      "name" : "__unittest___source_codecs_ber_d_2860_0",
      "kind" : "function",
      "line" : 2860,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 2893,
      "endchar" : 5
     },
     {
      "name" : "sequence",
      "kind" : "function",
      "comment" : "        Decodes a sequence of BERElements.\n\n        Returns: an array of BERElements.\n        Throws:\n            ASN1ValueSizeException = if long definite-length is too big to be\n                decoded to an unsigned integral type.\n            ASN1ValueTooSmallException = if there are fewer value bytes than\n                indicated by the length tag.\n",
      "line" : 2894,
      "char" : 18,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZAC6codecs3ber25BasicEncodingRulesElement",
      "originalType" : "const @property @system BERElement[]()",
      "endline" : 2901,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(BasicEncodingRulesElement).AbstractSyntaxNotation1Element.sequence"
      ]
     },
     {
      "name" : "sequence",
      "kind" : "function",
      "comment" : "        Encodes a sequence of BERElements.\n",
      "line" : 2907,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxAC6codecs3ber25BasicEncodingRulesElementZv",
      "originalType" : "@property @system void(in BERElement[] value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAC6codecs3ber25BasicEncodingRulesElement"
       }
      ],
      "endline" : 2915,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(BasicEncodingRulesElement).AbstractSyntaxNotation1Element.sequence"
      ]
     },
     {
      "name" : "set",
      "kind" : "function",
      "comment" : "        Decodes a set of BERElements.\n\n        Returns: an array of BERElements.\n        Throws:\n            ASN1ValueSizeException = if long definite-length is too big to be\n                decoded to an unsigned integral type.\n            ASN1ValueTooSmallException = if there are fewer value bytes than\n                indicated by the length tag.\n",
      "line" : 2928,
      "char" : 18,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZAC6codecs3ber25BasicEncodingRulesElement",
      "originalType" : "const @property @system BERElement[]()",
      "endline" : 2935,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(BasicEncodingRulesElement).AbstractSyntaxNotation1Element.set"
      ]
     },
     {
      "name" : "set",
      "kind" : "function",
      "comment" : "        Encodes a set of BERElements.\n",
      "line" : 2941,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxAC6codecs3ber25BasicEncodingRulesElementZv",
      "originalType" : "@property @system void(in BERElement[] value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAC6codecs3ber25BasicEncodingRulesElement"
       }
      ],
      "endline" : 2949,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(BasicEncodingRulesElement).AbstractSyntaxNotation1Element.set"
      ]
     },
     {
      "name" : "numericString",
      "kind" : "function",
      "comment" : "        Decodes a string, where the characters of the string are limited to\n        0 - 9 and space.\n\n        Returns: a string.\n        Throws:\n            ASN1ValueInvalidException = if any character other than 0-9 or\n                space is encoded.\n",
      "line" : 2961,
      "char" : 12,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZAya",
      "endline" : 2976,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(BasicEncodingRulesElement).AbstractSyntaxNotation1Element.numericString"
      ]
     },
     {
      "name" : "numericString",
      "kind" : "function",
      "comment" : "        Encodes a string, where the characters of the string are limited to\n        0 - 9 and space.\n\n        Throws:\n            ASN1ValueInvalidException = if any character other than 0-9 or\n                space is supplied.\n",
      "line" : 2987,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxAyaZv",
      "originalType" : "@property @system void(in string value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAya"
       }
      ],
      "endline" : 3002,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(BasicEncodingRulesElement).AbstractSyntaxNotation1Element.numericString"
      ]
     },
     {
      "name" : "printableString",
      "kind" : "function",
      "comment" : "        Decodes a string that will only contain characters a-z, A-Z, 0-9,\n        space, apostrophe, parentheses, comma, minus, plus, period,\n        forward slash, colon, equals, and question mark.\n\n        Returns: a string.\n        Throws:\n            ASN1ValueInvalidException = if any character other than a-z, A-Z,\n                0-9, space, apostrophe, parentheses, comma, minus, plus,\n                period, forward slash, colon, equals, or question mark are\n                encoded.\n",
      "line" : 3017,
      "char" : 12,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZAya",
      "endline" : 3035,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(BasicEncodingRulesElement).AbstractSyntaxNotation1Element.printableString"
      ]
     },
     {
      "name" : "printableString",
      "kind" : "function",
      "comment" : "        Encodes a string that may only contain characters a-z, A-Z, 0-9,\n        space, apostrophe, parentheses, comma, minus, plus, period,\n        forward slash, colon, equals, and question mark.\n\n        Throws:\n            ASN1ValueInvalidException = if any character other than a-z, A-Z,\n                0-9, space, apostrophe, parentheses, comma, minus, plus,\n                period, forward slash, colon, equals, or question mark are\n                supplied.\n",
      "line" : 3049,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxAyaZv",
      "originalType" : "@property @system void(in string value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAya"
       }
      ],
      "endline" : 3066,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(BasicEncodingRulesElement).AbstractSyntaxNotation1Element.printableString"
      ]
     },
     {
      "name" : "teletexString",
      "kind" : "function",
      "comment" : "        Literally just returns the value bytes.\n\n        Returns: an unsigned byte array, where each byte is a T.61 character.\n",
      "line" : 3074,
      "char" : 13,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNbNdNfZAh",
      "endline" : 3078,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(BasicEncodingRulesElement).AbstractSyntaxNotation1Element.teletexString"
      ]
     },
     {
      "name" : "teletexString",
      "kind" : "function",
      "comment" : "        Literally just sets the value bytes.\n",
      "line" : 3084,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNbNdNfxAhZv",
      "originalType" : "nothrow @property @safe void(in ubyte[] value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAh"
       }
      ],
      "endline" : 3088,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(BasicEncodingRulesElement).AbstractSyntaxNotation1Element.teletexString"
      ]
     },
     {
      "name" : "videotexString",
      "kind" : "function",
      "comment" : "        Literally just returns the value bytes.\n\n        Returns: an unsigned byte array.\n",
      "line" : 3096,
      "char" : 13,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNbNdNfZAh",
      "endline" : 3100,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(BasicEncodingRulesElement).AbstractSyntaxNotation1Element.videotexString"
      ]
     },
     {
      "name" : "videotexString",
      "kind" : "function",
      "comment" : "        Literally just sets the value bytes.\n",
      "line" : 3106,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNbNdNfxAhZv",
      "originalType" : "nothrow @property @safe void(in ubyte[] value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAh"
       }
      ],
      "endline" : 3110,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(BasicEncodingRulesElement).AbstractSyntaxNotation1Element.videotexString"
      ]
     },
     {
      "name" : "internationalAlphabetNumber5String",
      "kind" : "function",
      "comment" : "        Decodes a string that only contains ASCII characters.\n\n        IA5String differs from ASCII ever so slightly: IA5 is international,\n        leaving 10 characters up to be locale-specific:\n\n        $(TABLE\n            $(TR $(TH Byte) $(TH ASCII Character))\n            $(TR $(TD 0x40) $(TD @))\n            $(TR $(TD 0x5B) $(TD [))\n            $(TR $(TD 0x5C) $(TD \\))\n            $(TR $(TD 0x5D) $(TD ]))\n            $(TR $(TD 0x5E) $(TD ^))\n            $(TR $(TD 0x60) $(TD `))\n            $(TR $(TD 0x7B) $(TD {))\n            $(TR $(TD 0x7C) $(TD /))\n            $(TR $(TD 0x7D) $(TD }))\n            $(TR $(TD 0x7E) $(TD ~))\n        )\n\n        Returns: a string.\n        Throws:\n            ASN1ValueInvalidException = if any enecoded character is not ASCII.\n",
      "line" : 3137,
      "char" : 12,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZAya",
      "endline" : 3153,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(BasicEncodingRulesElement).AbstractSyntaxNotation1Element.internationalAlphabetNumber5String"
      ]
     },
     {
      "name" : "internationalAlphabetNumber5String",
      "kind" : "function",
      "comment" : "        Encodes a string that may only contain ASCII characters.\n\n        IA5String differs from ASCII ever so slightly: IA5 is international,\n        leaving 10 characters up to be locale-specific:\n\n        $(TABLE\n            $(TR $(TH Byte) $(TH ASCII Character))\n            $(TR $(TD 0x40) $(TD @))\n            $(TR $(TD 0x5B) $(TD [))\n            $(TR $(TD 0x5C) $(TD \\))\n            $(TR $(TD 0x5D) $(TD ]))\n            $(TR $(TD 0x5E) $(TD ^))\n            $(TR $(TD 0x60) $(TD `))\n            $(TR $(TD 0x7B) $(TD {))\n            $(TR $(TD 0x7C) $(TD /))\n            $(TR $(TD 0x7D) $(TD }))\n            $(TR $(TD 0x7E) $(TD ~))\n        )\n\n        Throws:\n            ASN1ValueInvalidException = if any enecoded character is not ASCII.\n",
      "line" : 3179,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxAyaZv",
      "originalType" : "@property @system void(in string value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAya"
       }
      ],
      "endline" : 3193,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(BasicEncodingRulesElement).AbstractSyntaxNotation1Element.internationalAlphabetNumber5String"
      ]
     },
     {
      "name" : "coordinatedUniversalTime",
      "kind" : "function",
      "comment" : "        Decodes a DateTime.\n\n        The BER-encoded value is just the ASCII character representation of\n        the UTC-formatted timestamp.\n\n        An UTC Timestamp looks like:\n        $(UL\n            $(LI 9912312359Z)\n            $(LI 991231235959+0200)\n        )\n\n        If the first digit of the two-digit year is 7, 6, 5, 4, 3, 2, 1, or 0,\n        meaning that the date refers to the first 80 years of the century, this\n        assumes we are talking about the 21st century and prepend '20' when\n        creating the ISO Date String. Otherwise, it assumes we are talking\n        about the 20th century, and prepend '19' when creating the string.\n\n        See_Also:\n            $(LINK2 https://www.obj-sys.com/asn1tutorial/node15.html, UTCTime)\n\n        Throws:\n            DateTimeException = if string cannot be decoded to a DateTime\n",
      "line" : 3220,
      "char" : 14,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZS3std8datetime4date8DateTime",
      "endline" : 3244,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(BasicEncodingRulesElement).AbstractSyntaxNotation1Element.coordinatedUniversalTime"
      ]
     },
     {
      "name" : "coordinatedUniversalTime",
      "kind" : "function",
      "comment" : "        Encodes a DateTime.\n\n        The BER-encoded value is just the ASCII character representation of\n        the UTC-formatted timestamp.\n\n        An UTC Timestamp looks like:\n        $(UL\n            $(LI 9912312359Z)\n            $(LI 991231235959+0200)\n        )\n\n        See_Also:\n            $(LINK2 https://www.obj-sys.com/asn1tutorial/node15.html, UTCTime)\n",
      "line" : 3262,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNbNdxS3std8datetime4date8DateTimeZv",
      "originalType" : "nothrow @property @system void(in DateTime value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xS3std8datetime4date8DateTime"
       }
      ],
      "endline" : 3272,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(BasicEncodingRulesElement).AbstractSyntaxNotation1Element.coordinatedUniversalTime"
      ],
      "out" : {
       "name" : "__ensure",
       "kind" : "function",
       "line" : 3264,
       "char" : 5,
       "deco" : "FNaNbNiZv",
       "originalType" : "nothrow @system void()",
       "endline" : 3264,
       "endchar" : 5
      }
     },
     {
      "name" : "generalizedTime",
      "kind" : "function",
      "comment" : "        Decodes a DateTime.\n\n        The BER-encoded value is just the ASCII character representation of\n        the $(LINK2 https://www.iso.org/iso-8601-date-and-time-format.html,\n        ISO 8601)-formatted timestamp.\n\n        An ISO-8601 Timestamp looks like:\n        $(UL\n            $(LI 19851106210627.3)\n            $(LI 19851106210627.3Z)\n            $(LI 19851106210627.3-0500)\n        )\n\n        Throws:\n            DateTimeException = if string cannot be decoded to a DateTime\n",
      "line" : 3292,
      "char" : 14,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZS3std8datetime4date8DateTime",
      "endline" : 3316,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(BasicEncodingRulesElement).AbstractSyntaxNotation1Element.generalizedTime"
      ]
     },
     {
      "name" : "generalizedTime",
      "kind" : "function",
      "comment" : "        Encodes a DateTime.\n\n        The BER-encoded value is just the ASCII character representation of\n        the $(LINK2 https://www.iso.org/iso-8601-date-and-time-format.html,\n        ISO 8601)-formatted timestamp.\n\n        An ISO-8601 Timestamp looks like:\n        $(UL\n            $(LI 19851106210627.3)\n            $(LI 19851106210627.3Z)\n            $(LI 19851106210627.3-0500)\n        )\n",
      "line" : 3333,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNbNdxS3std8datetime4date8DateTimeZv",
      "originalType" : "nothrow @property @system void(in DateTime value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xS3std8datetime4date8DateTime"
       }
      ],
      "endline" : 3343,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(BasicEncodingRulesElement).AbstractSyntaxNotation1Element.generalizedTime"
      ],
      "out" : {
       "name" : "__ensure",
       "kind" : "function",
       "line" : 3335,
       "char" : 5,
       "deco" : "FNaNbNiZv",
       "originalType" : "nothrow @system void()",
       "endline" : 3335,
       "endchar" : 5
      }
     },
     {
      "name" : "graphicString",
      "kind" : "function",
      "comment" : "        Decodes an ASCII string that contains only characters between and\n        including 0x20 and 0x75.\n\n        Deprecated, according to page 182 of the Dubuisson book.\n\n        Citations:\n            Dubuisson, Olivier. “Character String Types.” ASN.1:\n                Communication between Heterogeneous Systems, Morgan\n                Kaufmann, 2001, pp. 175-178.\n            $(LINK2 https://en.wikipedia.org/wiki/ISO/IEC_2022,\n                The Wikipedia Page on ISO 2022)\n            $(LINK2 https://www.iso.org/standard/22747.html, ISO 2022)\n\n        Returns: a string.\n        Throws:\n            ASN1ValueInvalidException = if any non-graphical character\n                (including space) is encoded.\n",
      "line" : 3365,
      "char" : 12,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZAya",
      "endline" : 3382,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(BasicEncodingRulesElement).AbstractSyntaxNotation1Element.graphicString"
      ]
     },
     {
      "name" : "graphicString",
      "kind" : "function",
      "comment" : "        Encodes an ASCII string that may contain only characters between and\n        including 0x20 and 0x75.\n\n        Deprecated, according to page 182 of the Dubuisson book.\n\n        Citations:\n            Dubuisson, Olivier. “Character String Types.” ASN.1:\n                Communication between Heterogeneous Systems, Morgan\n                Kaufmann, 2001, pp. 175-178.\n            $(LINK2 https://en.wikipedia.org/wiki/ISO/IEC_2022,\n                The Wikipedia Page on ISO 2022)\n            $(LINK2 https://www.iso.org/standard/22747.html, ISO 2022)\n\n        Throws:\n            ASN1ValueInvalidException = if any non-graphical character\n                (including space) is supplied.\n",
      "line" : 3403,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxAyaZv",
      "originalType" : "@property @system void(in string value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAya"
       }
      ],
      "endline" : 3419,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(BasicEncodingRulesElement).AbstractSyntaxNotation1Element.graphicString"
      ]
     },
     {
      "name" : "visibleString",
      "kind" : "function",
      "comment" : "        Decodes a string that only contains characters between and including\n        0x20 and 0x7E. (Honestly, I don't know how this differs from\n        GraphicalString.)\n\n        Returns: a string.\n        Throws:\n            ASN1ValueInvalidException = if any non-graphical character\n                (including space) is encoded.\n",
      "line" : 3432,
      "char" : 12,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZAya",
      "endline" : 3449,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(BasicEncodingRulesElement).AbstractSyntaxNotation1Element.visibleString"
      ]
     },
     {
      "name" : "visibleString",
      "kind" : "function",
      "comment" : "        Encodes a string that only contains characters between and including\n        0x20 and 0x7E. (Honestly, I don't know how this differs from\n        GraphicalString.)\n\n        Throws:\n            ASN1ValueInvalidException = if any non-graphical character\n                (including space) is supplied.\n",
      "line" : 3461,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxAyaZv",
      "originalType" : "@property @system void(in string value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAya"
       }
      ],
      "endline" : 3477,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(BasicEncodingRulesElement).AbstractSyntaxNotation1Element.visibleString"
      ]
     },
     {
      "name" : "generalString",
      "kind" : "function",
      "comment" : "        Decodes a string containing only ASCII characters.\n\n        Deprecated, according to page 182 of the Dubuisson book.\n\n        Returns: a string.\n        Throws:\n            ASN1ValueInvalidException = if any enecoded character is not ASCII.\n\n        Citations:\n            Dubuisson, Olivier. “Basic Encoding Rules (BER).” ASN.1:\n            Communication between Heterogeneous Systems, Morgan Kaufmann,\n            2001, p. 182.\n",
      "line" : 3494,
      "char" : 12,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZAya",
      "endline" : 3511,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(BasicEncodingRulesElement).AbstractSyntaxNotation1Element.generalString"
      ]
     },
     {
      "name" : "generalString",
      "kind" : "function",
      "comment" : "        Encodes a string containing only ASCII characters.\n\n        Deprecated, according to page 182 of the Dubuisson book.\n\n        Throws:\n            ASN1ValueInvalidException = if any enecoded character is not ASCII.\n\n        Citations:\n            Dubuisson, Olivier. “Basic Encoding Rules (BER).” ASN.1:\n            Communication between Heterogeneous Systems, Morgan Kaufmann,\n            2001, p. 182.\n",
      "line" : 3527,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxAyaZv",
      "originalType" : "@property @system void(in string value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAya"
       }
      ],
      "endline" : 3542,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(BasicEncodingRulesElement).AbstractSyntaxNotation1Element.generalString"
      ]
     },
     {
      "name" : "universalString",
      "kind" : "function",
      "comment" : "        Decodes a dstring of UTF-32 characters.\n\n        Returns: a string of UTF-32 characters.\n        Throws:\n            ASN1ValueInvalidException = if the encoded bytes is not evenly\n                divisible by four.\n",
      "line" : 3553,
      "char" : 13,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZAyw",
      "endline" : 3590,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(BasicEncodingRulesElement).AbstractSyntaxNotation1Element.universalString"
      ]
     },
     {
      "name" : "universalString",
      "kind" : "function",
      "comment" : "        Encodes a dstring of UTF-32 characters.\n",
      "line" : 3596,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxAywZv",
      "originalType" : "@property @system void(in dstring value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAyw"
       }
      ],
      "endline" : 3615,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(BasicEncodingRulesElement).AbstractSyntaxNotation1Element.universalString"
      ]
     },
     {
      "name" : "characterString",
      "kind" : "function",
      "comment" : "        Decodes a CHARACTER STRING, which is a constructed data type, defined\n        in the $(LINK2 https://www.itu.int,\n                International Telecommunications Union)'s\n            $(LINK2 https://www.itu.int/rec/T-REC-X.680/en, X.680).\n\n        The specification defines CHARACTER as:\n\n        $(I\n            CHARACTER STRING ::= [UNIVERSAL 29] SEQUENCE {\n                identification CHOICE {\n                    syntaxes SEQUENCE {\n                        abstract OBJECT IDENTIFIER,\n                        transfer OBJECT IDENTIFIER },\n                    syntax OBJECT IDENTIFIER,\n                    presentation-context-id INTEGER,\n                    context-negotiation SEQUENCE {\n                        presentation-context-id INTEGER,\n                        transfer-syntax OBJECT IDENTIFIER },\n                    transfer-syntax OBJECT IDENTIFIER,\n                    fixed NULL },\n                string-value OCTET STRING }\n        )\n\n        This assumes AUTOMATIC TAGS, so all of the identification choices\n        will be context-specific and numbered from 0 to 5.\n\n        Returns: an instance of types.universal.CharacterString.\n        Throws:\n            ASN1SizeException = if encoded CharacterString has too few or too many\n                elements, or if syntaxes or context-negotiation element has\n                too few or too many elements.\n            ASN1ValueTooBigException = if encoded INTEGER is too large to decode.\n            ASN1InvalidIndexException = if encoded value selects a choice for\n                identification or uses an unspecified index for an element in\n                syntaxes or context-negotiation, or if an unspecified element\n                of CharacterString itself is referenced by an out-of-range\n                context-specific index. (See $(D_INLINECODE ASN1InvalidIndexException).)\n",
      "line" : 3657,
      "char" : 21,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZS5types9universal15characterstring15CharacterString",
      "endline" : 3859,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(BasicEncodingRulesElement).AbstractSyntaxNotation1Element.characterString"
      ]
     },
     {
      "name" : "characterString",
      "kind" : "function",
      "comment" : "        Encodes a CHARACTER STRING, which is a constructed data type, defined\n        in the $(LINK2 https://www.itu.int,\n                International Telecommunications Union)'s\n            $(LINK2 https://www.itu.int/rec/T-REC-X.680/en, X.680).\n\n        The specification defines CHARACTER as:\n\n        $(I\n            CHARACTER STRING ::= [UNIVERSAL 29] SEQUENCE {\n                identification CHOICE {\n                    syntaxes SEQUENCE {\n                        abstract OBJECT IDENTIFIER,\n                        transfer OBJECT IDENTIFIER },\n                    syntax OBJECT IDENTIFIER,\n                    presentation-context-id INTEGER,\n                    context-negotiation SEQUENCE {\n                        presentation-context-id INTEGER,\n                        transfer-syntax OBJECT IDENTIFIER },\n                    transfer-syntax OBJECT IDENTIFIER,\n                    fixed NULL },\n                string-value OCTET STRING }\n        )\n\n        This assumes AUTOMATIC TAGS, so all of the identification choices\n        will be context-specific and numbered from 0 to 5.\n",
      "line" : 3889,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxS5types9universal15characterstring15CharacterStringZv",
      "originalType" : "@property @system void(in CharacterString value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xS5types9universal15characterstring15CharacterString"
       }
      ],
      "endline" : 3962,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(BasicEncodingRulesElement).AbstractSyntaxNotation1Element.characterString"
      ],
      "out" : {
       "name" : "__ensure",
       "kind" : "function",
       "line" : 3891,
       "char" : 5,
       "deco" : "FNaNbNiZv",
       "originalType" : "@system void()",
       "endline" : 3891,
       "endchar" : 5
      }
     },
     {
      "name" : "__unittest___source_codecs_ber_d_3970_0",
      "kind" : "function",
      "line" : 3970,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 3992,
      "endchar" : 5
     },
     {
      "name" : "__unittest___source_codecs_ber_d_3993_0",
      "kind" : "function",
      "line" : 3993,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 4015,
      "endchar" : 5
     },
     {
      "name" : "__unittest___source_codecs_ber_d_4016_0",
      "kind" : "function",
      "line" : 4016,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 4060,
      "endchar" : 5
     },
     {
      "name" : "basicMultilingualPlaneString",
      "kind" : "function",
      "comment" : "        Decodes a wstring of UTF-16 characters.\n\n        Returns: an immutable array of UTF-16 characters.\n        Throws:\n            ASN1ValueInvalidException = if the encoded bytes is not evenly\n                divisible by two.\n",
      "line" : 4061,
      "char" : 13,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZAyu",
      "endline" : 4096,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(BasicEncodingRulesElement).AbstractSyntaxNotation1Element.basicMultilingualPlaneString"
      ]
     },
     {
      "name" : "basicMultilingualPlaneString",
      "kind" : "function",
      "comment" : "        Encodes a wstring of UTF-16 characters.\n",
      "line" : 4102,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxAyuZv",
      "originalType" : "@property @system void(in wstring value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAyu"
       }
      ],
      "endline" : 4121,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(BasicEncodingRulesElement).AbstractSyntaxNotation1Element.basicMultilingualPlaneString"
      ]
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "        Creates an EndOfContent BER Value.\n",
      "line" : 4127,
      "char" : 5,
      "deco" : "FNbNiNfZC6codecs3ber25BasicEncodingRulesElement",
      "originalType" : "nothrow @nogc @safe ()",
      "endline" : 4131,
      "endchar" : 5
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "        Creates a BERElement from the supplied bytes, inferring that the first\n        byte is the type tag. The supplied ubyte[] array is \"chomped\" by\n        reference, so the original array will grow shorter as BERElements are\n        generated.\n\n        Throws:\n            ASN1ValueTooSmallException = if the bytes supplied are fewer than\n                two (one or zero, in other words), such that no valid BERElement\n                can be decoded, or if the length is encoded in indefinite\n                form, but the END OF CONTENT octets (two consecutive null\n                octets) cannot be found, or if the value is encoded in fewer\n                octets than indicated by the length byte.\n            ASN1InvalidLengthException = if the length byte is set to 0xFF,\n                which is reserved.\n            ASN1ValueTooBigException = if the length cannot be represented by\n                the largest unsigned integer.\n\n        Example:\n        ---\n        // Decoding looks like:\n        BERElement[] result;\n        while (bytes.length > 0)\n            result ~= new BERElement(bytes);\n\n        // Encoding looks like:\n        ubyte[] result;\n        foreach (bv; bervalues)\n        {\n            result ~= cast(ubyte[]) bv;\n        }\n        ---\n",
      "line" : 4167,
      "char" : 5,
      "deco" : "FKAhZC6codecs3ber25BasicEncodingRulesElement",
      "originalType" : "@system (ref ubyte[] bytes)",
      "parameters" : [
       {
        "name" : "bytes",
        "deco" : "Ah",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 4171,
      "endchar" : 5
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "        Creates a BERElement from the supplied bytes, inferring that the first\n        byte is the type tag. The supplied ubyte[] array is read, starting\n        from the index specified by $(D bytesRead), and increments\n        $(D bytesRead) by the number of bytes read.\n\n        Throws:\n            ASN1ValueTooSmallException = if the bytes supplied are fewer than\n                two (one or zero, in other words), such that no valid BERElement\n                can be decoded, or if the length is encoded in indefinite\n                form, but the END OF CONTENT octets (two consecutive null\n                octets) cannot be found, or if the value is encoded in fewer\n                octets than indicated by the length byte.\n            ASN1InvalidLengthException = if the length byte is set to 0xFF,\n                which is reserved.\n            ASN1ValueTooBigException = if the length cannot be represented by\n                the largest unsigned integer.\n\n        Example:\n        ---\n        // Decoding looks like:\n        BERElement[] result;\n        size_t i = 0u;\n        while (i < bytes.length)\n            result ~= new BERElement(i, bytes);\n\n        // Encoding looks like:\n        ubyte[] result;\n        foreach (bv; bervalues)\n        {\n            result ~= cast(ubyte[]) bv;\n        }\n        ---\n",
      "line" : 4208,
      "char" : 5,
      "deco" : "FKmxAhZC6codecs3ber25BasicEncodingRulesElement",
      "originalType" : "@system (ref size_t bytesRead, in ubyte[] bytes)",
      "parameters" : [
       {
        "name" : "bytesRead",
        "deco" : "m",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "bytes",
        "deco" : "xAh"
       }
      ],
      "endline" : 4211,
      "endchar" : 5
     },
     {
      "name" : "fromBytes",
      "kind" : "function",
      "line" : 4215,
      "char" : 12,
      "deco" : "FxAhZm",
      "originalType" : "size_t(in ubyte[] bytes)",
      "parameters" : [
       {
        "name" : "bytes",
        "deco" : "xAh"
       }
      ],
      "endline" : 4490,
      "endchar" : 5,
      "overrides" : [
       "interfaces.Byteable.fromBytes"
      ]
     },
     {
      "name" : "toBytes",
      "kind" : "function",
      "comment" : "        This differs from $(D_INLINECODE this.value) in that\n        $(D_INLINECODE this.value) only returns the value octets, whereas\n        $(D_INLINECODE this.toBytes) returns the type tag, length tag / octets,\n        and the value octets, all concatenated.\n\n        This is the exact same as $(D_INLINECODE this.opCast!(ubyte[])()).\n\n        Returns: type tag, length tag, and value, all concatenated as a ubyte array.\n",
      "line" : 4503,
      "char" : 13,
      "deco" : "xFNbNdZAh",
      "endline" : 4575,
      "endchar" : 5,
      "overrides" : [
       "interfaces.Byteable.toBytes"
      ]
     },
     {
      "kind" : "template",
      "comment" : "        This differs from $(D_INLINECODE this.value) in that\n        $(D_INLINECODE this.value) only returns the value octets, whereas\n        $(D_INLINECODE this.toBytes) returns the type tag, length tag / octets,\n        and the value octets, all concatenated.\n\n        This is the exact same as $(D_INLINECODE this.toBytes()).\n\n        Returns: type tag, length tag, and value, all concatenated as a ubyte array.\n",
      "line" : 4588,
      "char" : 13,
      "name" : "opCast",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type",
        "default" : "ubyte[]"
       }
      ],
      "members" : [
       {
        "name" : "opCast",
        "kind" : "function",
        "line" : 4588,
        "char" : 13,
        "type" : "nothrow @system ubyte[]()",
        "endline" : 4591,
        "endchar" : 5
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittest___source_codecs_ber_d_4597_21",
    "kind" : "function",
    "line" : 4597,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 4748,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_ber_d_4749_22",
    "kind" : "function",
    "line" : 4749,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 4790,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_ber_d_4791_23",
    "kind" : "function",
    "line" : 4791,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 4834,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_ber_d_4835_24",
    "kind" : "function",
    "line" : 4835,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 4847,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_ber_d_4848_25",
    "kind" : "function",
    "line" : 4848,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 4861,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_ber_d_4862_26",
    "kind" : "function",
    "line" : 4862,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 4873,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_ber_d_4874_27",
    "kind" : "function",
    "line" : 4874,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 4884,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_ber_d_4885_28",
    "kind" : "function",
    "line" : 4885,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 4895,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_ber_d_4896_29",
    "kind" : "function",
    "line" : 4896,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 4906,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_ber_d_4907_30",
    "kind" : "function",
    "line" : 4907,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 4925,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_ber_d_4926_31",
    "kind" : "function",
    "line" : 4926,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 4949,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_ber_d_4950_32",
    "kind" : "function",
    "line" : 4950,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 4966,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_ber_d_4967_33",
    "kind" : "function",
    "line" : 4967,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 4979,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_ber_d_4980_34",
    "kind" : "function",
    "line" : 4980,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 4994,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_ber_d_4995_35",
    "kind" : "function",
    "line" : 4995,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 5004,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_ber_d_5005_36",
    "kind" : "function",
    "line" : 5005,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 5012,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_ber_d_5013_37",
    "kind" : "function",
    "line" : 5013,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 5020,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_ber_d_5021_38",
    "kind" : "function",
    "line" : 5021,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 5032,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_ber_d_5033_39",
    "kind" : "function",
    "line" : 5033,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 5044,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_ber_d_5045_40",
    "kind" : "function",
    "line" : 5045,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 5053,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_ber_d_5054_41",
    "kind" : "function",
    "line" : 5054,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 5062,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_ber_d_5063_42",
    "kind" : "function",
    "line" : 5063,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 5071,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_ber_d_5072_43",
    "kind" : "function",
    "line" : 5072,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 5097,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_ber_d_5098_44",
    "kind" : "function",
    "line" : 5098,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 5114,
    "endchar" : 2
   }
  ]
 },
 {
  "name" : "codecs.cer",
  "kind" : "module",
  "file" : "./source/codecs/cer.d",
  "comment" : "    Canonical Encoding Rules (CER) is a standard for encoding ASN.1 data.\n    CER is often used for cryptgraphically-signed data, such as X.509\n    certificates, because CER's defining feature is that there is only one way\n    to encode each data type, which means that two encodings of the same data\n    could not have different cryptographic signatures. For this reason, CER\n    is generally regarded as the most secure encoding standard for ASN.1.\n    Like Basic Encoding Rules (BER), Canonical Encoding Rules (CER), and\n    Packed Encoding Rules (PER), Canonical Encoding Rules (CER) is a\n    specification created by the\n    $(LINK2 http://www.itu.int/en/pages/default.aspx,\n        International Telecommunications Union),\n    and specified in\n    $(LINK2 http://www.itu.int/rec/T-REC-X.690/en, X.690 - ASN.1 encoding rules)\n\n    Author:\n        $(LINK2 http://jonathan.wilbur.space, Jonathan M. Wilbur)\n            $(LINK2 mailto:jonathan@wilbur.space, jonathan@wilbur.space)\n    License: $(LINK2 https://mit-license.org/, MIT License)\n    Standards:\n        $(LINK2 https://www.itu.int/rec/T-REC-X.680/en, X.680 - Abstract Syntax Notation One (ASN.1))\n        $(LINK2 http://www.itu.int/rec/T-REC-X.690/en, X.690 - ASN.1 encoding rules)\n    See_Also:\n        $(LINK2 https://en.wikipedia.org/wiki/Abstract_Syntax_Notation_One, The Wikipedia Page on ASN.1)\n        $(LINK2 https://en.wikipedia.org/wiki/X.690, The Wikipedia Page on X.690)\n        $(LINK2 https://www.strozhevsky.com/free_docs/asn1_in_simple_words.pdf, ASN.1 By Simple Words)\n        $(LINK2 http://www.oss.com/asn1/resources/books-whitepapers-pubs/dubuisson-asn1-book.PDF, ASN.1: Communication Between Heterogeneous Systems)\n",
  "members" : [
   {
    "name" : "codec",
    "kind" : "import",
    "line" : 30,
    "char" : 15
   },
   {
    "name" : "interfaces",
    "kind" : "import",
    "line" : 31,
    "char" : 15,
    "selective" : [
     "Byteable"
    ]
   },
   {
    "name" : "types.identification",
    "kind" : "import",
    "line" : 32,
    "char" : 15
   },
   {
    "name" : "cerOID",
    "kind" : "alias",
    "comment" : "\n",
    "line" : 35,
    "char" : 8
   },
   {
    "name" : "cerObjectID",
    "kind" : "alias",
    "comment" : "\n",
    "line" : 37,
    "char" : 8
   },
   {
    "name" : "cerObjectIdentifier",
    "kind" : "alias",
    "comment" : "\n",
    "line" : 39,
    "char" : 8
   },
   {
    "name" : "canonicalEncodingRulesObjectIdentifier",
    "kind" : "variable",
    "comment" : "    The object identifier assigned to the Canonical Encoding Rules (CER), per the\n    $(LINK2 http://www.itu.int/en/pages/default.aspx,\n        International Telecommunications Union)'s,\n    $(LINK2 http://www.itu.int/rec/T-REC-X.690/en, X.690 - ASN.1 encoding rules)\n\n    $(I {joint-iso-itu-t asn1(1) ber-derived(2) canonical-encoding(0)} )\n",
    "line" : 48,
    "char" : 22,
    "storageClass" : [
     "immutable"
    ],
    "deco" : "yC5types9universal16objectidentifier16ObjectIdentifier",
    "originalType" : "OID",
    "init" : "ObjectIdentifier([ObjectIdentifierNode(2LU, \"\"), ObjectIdentifierNode(1LU, \"\"), ObjectIdentifierNode(2LU, \"\"), ObjectIdentifierNode(0LU, \"\")])"
   },
   {
    "name" : "CERElement",
    "kind" : "alias",
    "comment" : "\n",
    "line" : 51,
    "char" : 8,
    "deco" : "C6codecs3cer29CanonicalEncodingRulesElement"
   },
   {
    "name" : "CanonicalEncodingRulesElement",
    "kind" : "class",
    "comment" : "    The unit of encoding and decoding for Canonical Encoding Rules (CER).\n\n    There are three parts to an element encoded according to the Canonical\n    Encoding Rules (CER):\n\n    $(UL\n        $(LI A Type Tag, which specifies what data type is encoded)\n        $(LI A Length Tag, which specifies how many subsequent bytes encode the data)\n        $(LI The Encoded Value)\n    )\n\n    They appear in the binary encoding in that order, and as such, the encoding\n    scheme is sometimes described as \"TLV,\" which stands for Type-Length-Value.\n\n    This class provides a properties for getting and setting bit fields of\n    the type tag, but most of it is functionality for encoding data per\n    the specification.\n\n    As an example, this is what encoding a simple INTEGER looks like:\n\n    ---\n    CERElement cv = new CERElement();\n    cv.tagNumber = 0x02u; // \"2\" means this is an INTEGER\n    cv.integer = 1433; // Now the data is encoded.\n    transmit(cast(ubyte[]) cv); // transmit() is a made-up function.\n    ---\n\n    And this is what decoding looks like:\n\n    ---\n    ubyte[] data = receive(); // receive() is a made-up function.\n    CERElement cv2 = new CERElement(data);\n\n    long x;\n    if (cv.tagNumber == 0x02u) // it is an INTEGER\n    {\n        x = cv.integer;\n    }\n    // Now x is 1433!\n    ---\n",
    "line" : 104,
    "char" : 1,
    "base" : "codec.ASN1Element!(codecs.cer.CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element",
    "interfaces" : [
     "interfaces.Byteable"
    ],
    "members" : [
     {
      "name" : "__unittest___source_codecs_cer_d_107_0",
      "kind" : "function",
      "line" : 107,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 113,
      "endchar" : 5
     },
     {
      "name" : "realEncodingBase",
      "kind" : "variable",
      "comment" : "The base of encoded REALs. May be 2, 8, 10, or 16.\n",
      "line" : 113,
      "char" : 40,
      "storageClass" : [
       "static"
      ],
      "deco" : "E4asn139AbstractSyntaxNotation1RealEncodingBase",
      "originalType" : "ASN1RealEncodingBase",
      "init" : "cast(AbstractSyntaxNotation1RealEncodingBase)cast(ubyte)2u"
     },
     {
      "name" : "nestingRecursionCount",
      "kind" : "variable",
      "protection" : "protected",
      "comment" : "The number of recursions used for parsing constructed elements.\n",
      "line" : 116,
      "char" : 29,
      "storageClass" : [
       "static"
      ],
      "deco" : "m",
      "originalType" : "size_t",
      "init" : "0LU"
     },
     {
      "name" : "nestingRecursionLimit",
      "kind" : "variable",
      "comment" : "The limit of recursions permitted for parsing constructed elements.\n",
      "line" : 119,
      "char" : 29,
      "storageClass" : [
       "static",
       "immutable"
      ],
      "deco" : "ym",
      "originalType" : "size_t",
      "init" : "5LU"
     },
     {
      "name" : "tagClass",
      "kind" : "variable",
      "line" : 121,
      "char" : 25,
      "deco" : "E4asn131AbstractSyntaxNotation1TagClass",
      "originalType" : "ASN1TagClass",
      "offset" : 144
     },
     {
      "name" : "construction",
      "kind" : "variable",
      "line" : 122,
      "char" : 29,
      "deco" : "E4asn135AbstractSyntaxNotation1Construction",
      "originalType" : "ASN1Construction",
      "offset" : 145
     },
     {
      "name" : "tagNumber",
      "kind" : "variable",
      "line" : 123,
      "char" : 19,
      "deco" : "m",
      "originalType" : "size_t",
      "offset" : 152
     },
     {
      "name" : "length",
      "kind" : "function",
      "comment" : "The length of the value in octets\n",
      "line" : 127,
      "char" : 12,
      "storageClass" : [
       "final"
      ],
      "deco" : "xFNbNdNfZm",
      "originalType" : "const nothrow @property @safe size_t()",
      "endline" : 130,
      "endchar" : 5
     },
     {
      "name" : "value",
      "kind" : "variable",
      "comment" : "The octets of the encoded value.\n",
      "line" : 133,
      "char" : 20,
      "deco" : "Ah",
      "offset" : 160
     },
     {
      "name" : "boolean",
      "kind" : "function",
      "comment" : "        Decodes a boolean.\n\n        Any non-zero value will be interpreted as TRUE. Only zero will be\n        interpreted as FALSE.\n\n        Returns: a boolean\n        Throws:\n            ASN1ValueSizeException = if the encoded value is anything other\n                than exactly 1 byte in size.\n            ASN1ValueInvalidException = if the encoded byte is not 0xFF or 0x00\n",
      "line" : 148,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdNfZb",
      "endline" : 180,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element.boolean"
      ]
     },
     {
      "name" : "boolean",
      "kind" : "function",
      "comment" : "        Encodes a boolean.\n\n        Any non-zero value will be interpreted as TRUE. Only zero will be\n        interpreted as FALSE.\n",
      "line" : 189,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNbNdNfxbZv",
      "originalType" : "nothrow @property @safe void(in bool value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xb"
       }
      ],
      "endline" : 197,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element.boolean"
      ],
      "out" : {
       "name" : "__ensure",
       "kind" : "function",
       "line" : 191,
       "char" : 5,
       "deco" : "FNaNbNiNfZv",
       "originalType" : "nothrow @safe void()",
       "endline" : 191,
       "endchar" : 5
      }
     },
     {
      "name" : "__unittest___source_codecs_cer_d_201_0",
      "kind" : "function",
      "comment" : "\n",
      "line" : 201,
      "char" : 5,
      "storageClass" : [
       "@safe"
      ],
      "endline" : 227,
      "endchar" : 5
     },
     {
      "kind" : "template",
      "comment" : "        Decodes a signed integer.\n\n        Bytes are stored in big-endian order, where the bytes represent\n        the two's complement encoding of the integer.\n\n        Returns: any chosen signed integral type\n        Throws:\n            ASN1ValueTooBigException = if the value is too big to decode\n                to a signed integral type.\n",
      "line" : 228,
      "char" : 7,
      "name" : "integer",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "constraint" : "isIntegral!T && isSigned!T",
      "members" : [
       {
        "name" : "integer",
        "kind" : "function",
        "line" : 228,
        "char" : 7,
        "type" : "const @property @system T()",
        "endline" : 300,
        "endchar" : 5
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "        Encodes an integer.\n\n        Bytes are stored in big-endian order, where the bytes represent\n        the two's complement encoding of the integer.\n",
      "line" : 309,
      "char" : 10,
      "name" : "integer",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "constraint" : "isIntegral!T && isSigned!T",
      "members" : [
       {
        "name" : "integer",
        "kind" : "function",
        "line" : 309,
        "char" : 10,
        "type" : "nothrow @property @system void(in T value)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "T",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 366,
        "endchar" : 5
       }
      ]
     },
     {
      "name" : "__unittest___source_codecs_cer_d_370_0",
      "kind" : "function",
      "line" : 370,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 394,
      "endchar" : 5
     },
     {
      "name" : "__unittest___source_codecs_cer_d_395_0",
      "kind" : "function",
      "line" : 395,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 428,
      "endchar" : 5
     },
     {
      "name" : "bitString",
      "kind" : "function",
      "comment" : "        Decodes an array of $(D bool)s representing a string of bits.\n\n        In Canonical Encoding Rules (CER), the first byte is an unsigned\n        integral byte indicating the number of unused bits at the end of\n        the BIT STRING. The unused bits must be zeroed.\n\n        Returns: an array of booleans.\n        Throws:\n            ASN1ValueInvalidException = if the first byte has a value greater\n                than seven.\n",
      "line" : 429,
      "char" : 12,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZAb",
      "endline" : 615,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element.bitString"
      ],
      "in" : {
       "name" : "__require",
       "kind" : "function",
       "line" : 431,
       "char" : 5,
       "type" : "@system void()",
       "endline" : 431,
       "endchar" : 5
      }
     },
     {
      "name" : "bitString",
      "kind" : "function",
      "comment" : "        Encodes an array of $(D bool)s representing a string of bits.\n\n        In Canonical Encoding Rules, the first byte is an unsigned\n        integral byte indicating the number of unused bits at the end of\n        the BIT STRING. The unused bits must be zeroed.\n",
      "line" : 625,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxAbZv",
      "originalType" : "@property @system void(in bool[] value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAb"
       }
      ],
      "endline" : 672,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element.bitString"
      ],
      "out" : {
       "name" : "__ensure",
       "kind" : "function",
       "line" : 627,
       "char" : 5,
       "deco" : "FNaNbNiZv",
       "originalType" : "@system void()",
       "endline" : 627,
       "endchar" : 5
      }
     },
     {
      "name" : "__unittest___source_codecs_cer_d_675_0",
      "kind" : "function",
      "line" : 675,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 688,
      "endchar" : 5
     },
     {
      "name" : "__unittest___source_codecs_cer_d_689_0",
      "kind" : "function",
      "line" : 689,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 717,
      "endchar" : 5
     },
     {
      "name" : "__unittest___source_codecs_cer_d_718_0",
      "kind" : "function",
      "line" : 718,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 732,
      "endchar" : 5
     },
     {
      "name" : "__unittest___source_codecs_cer_d_733_0",
      "kind" : "function",
      "line" : 733,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 745,
      "endchar" : 5
     },
     {
      "name" : "octetString",
      "kind" : "function",
      "comment" : "        Decodes an OCTET STRING into an unsigned byte array.\n\n        Returns: an unsigned byte array.\n",
      "line" : 746,
      "char" : 13,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZAh",
      "endline" : 784,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element.octetString"
      ]
     },
     {
      "name" : "octetString",
      "kind" : "function",
      "comment" : "        Encodes an OCTET STRING from an unsigned byte array.\n",
      "line" : 790,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxAhZv",
      "originalType" : "@property @system void(in ubyte[] value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAh"
       }
      ],
      "endline" : 831,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element.octetString"
      ],
      "in" : {
       "name" : "__require",
       "kind" : "function",
       "line" : 792,
       "char" : 5,
       "type" : "@system void()",
       "endline" : 792,
       "endchar" : 5
      }
     },
     {
      "name" : "__unittest___source_codecs_cer_d_834_0",
      "kind" : "function",
      "line" : 834,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 882,
      "endchar" : 5
     },
     {
      "name" : "objectIdentifier",
      "kind" : "function",
      "comment" : "        Decodes an OBJECT IDENTIFIER.\n        See source/types/universal/objectidentifier.d for information about\n        the ObjectIdentifier class (aliased as \"OID\").\n\n        The encoded OBJECT IDENTIFIER's first byte contains the first number\n        of the OID multiplied by 40 and added to the second number of the OID.\n        The subsequent bytes have all the remaining number encoded in base-128\n        on the least significant 7 bits of each byte. For these bytes, the most\n        significant bit is set if the next byte continues the encoding of the\n        current OID number. In other words, the bytes encoding each number\n        always end with a byte whose most significant bit is cleared.\n\n        Throws:\n            ASN1ValueTooSmallException = if an attempt is made to decode\n                an Object Identifier from zero bytes.\n            ASN1ValueTooBigException = if a single OID number is too big to\n                decode to a size_t.\n        Standards:\n            $(LINK2 http://www.itu.int/rec/T-REC-X.660-201107-I/en, X.660)\n",
      "line" : 883,
      "char" : 9,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZC5types9universal16objectidentifier16ObjectIdentifier",
      "originalType" : "const @property @system OID()",
      "endline" : 987,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element.objectIdentifier"
      ],
      "out" : {
       "name" : "__ensure",
       "kind" : "function",
       "line" : 885,
       "char" : 5,
       "deco" : "FKxC5types9universal16objectidentifier16ObjectIdentifierZv",
       "originalType" : "@system void(ref const ObjectIdentifier value)",
       "parameters" : [
        {
         "name" : "value",
         "deco" : "xC5types9universal16objectidentifier16ObjectIdentifier",
         "storageClass" : [
          "ref"
         ]
        }
       ],
       "endline" : 885,
       "endchar" : 5
      }
     },
     {
      "name" : "objectIdentifier",
      "kind" : "function",
      "comment" : "        Encodes an OBJECT IDENTIFIER.\n        See source/types/universal/objectidentifier.d for information about\n        the ObjectIdentifier class (aliased as \"OID\").\n\n        The encoded OBJECT IDENTIFIER's first byte contains the first number\n        of the OID multiplied by 40 and added to the second number of the OID.\n        The subsequent bytes have all the remaining number encoded in base-128\n        on the least significant 7 bits of each byte. For these bytes, the most\n        significant bit is set if the next byte continues the encoding of the\n        current OID number. In other words, the bytes encoding each number\n        always end with a byte whose most significant bit is cleared.\n\n        Standards:\n            $(LINK2 http://www.itu.int/rec/T-REC-X.660-201107-I/en, X.660)\n",
      "line" : 1006,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxC5types9universal16objectidentifier16ObjectIdentifierZv",
      "originalType" : "@property @system void(in OID value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xC5types9universal16objectidentifier16ObjectIdentifier"
       }
      ],
      "endline" : 1049,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element.objectIdentifier"
      ],
      "in" : {
       "name" : "__require",
       "kind" : "function",
       "line" : 1008,
       "char" : 5,
       "type" : "@system void()",
       "endline" : 1008,
       "endchar" : 5
      },
      "out" : {
       "name" : "__ensure",
       "kind" : "function",
       "line" : 1017,
       "char" : 5,
       "deco" : "FNaNbNiZv",
       "originalType" : "@system void()",
       "endline" : 1017,
       "endchar" : 5
      }
     },
     {
      "name" : "__unittest___source_codecs_cer_d_1052_0",
      "kind" : "function",
      "line" : 1052,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 1071,
      "endchar" : 5
     },
     {
      "name" : "__unittest___source_codecs_cer_d_1072_0",
      "kind" : "function",
      "line" : 1072,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 1123,
      "endchar" : 5
     },
     {
      "name" : "objectDescriptor",
      "kind" : "function",
      "comment" : "        Decodes an ObjectDescriptor, which is a string consisting of only\n        graphical characters. In fact, ObjectDescriptor is actually implicitly\n        just a GraphicString! The formal specification for an ObjectDescriptor\n        is:\n\n        $(I ObjectDescriptor ::= [UNIVERSAL 7] IMPLICIT GraphicString)\n\n        GraphicString is just 0x20 to 0x7E, therefore ObjectDescriptor is just\n        0x20 to 0x7E.\n\n        Citations:\n            Dubuisson, Olivier. “Character String Types.” ASN.1:\n                Communication between Heterogeneous Systems, Morgan\n                Kaufmann, 2001, pp. 175-178.\n            $(LINK2 https://en.wikipedia.org/wiki/ISO/IEC_2022,\n                The Wikipedia Page on ISO 2022)\n            $(LINK2 https://www.iso.org/standard/22747.html, ISO 2022)\n\n        Returns: a string.\n        Throws:\n            ASN1ValueInvalidException = if the encoded value contains any bytes\n                outside of 0x20 to 0x7E.\n",
      "line" : 1124,
      "char" : 12,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZAya",
      "endline" : 1188,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element.objectDescriptor"
      ]
     },
     {
      "name" : "objectDescriptor",
      "kind" : "function",
      "comment" : "        Encodes an ObjectDescriptor, which is a string consisting of only\n        graphical characters. In fact, ObjectDescriptor is actually implicitly\n        just a GraphicString! The formal specification for an ObjectDescriptor\n        is:\n\n        $(I ObjectDescriptor ::= [UNIVERSAL 7] IMPLICIT GraphicString)\n\n        GraphicString is just 0x20 to 0x7E, therefore ObjectDescriptor is just\n        0x20 to 0x7E.\n\n        Citations:\n            Dubuisson, Olivier. “Character String Types.” ASN.1:\n                Communication between Heterogeneous Systems, Morgan\n                Kaufmann, 2001, pp. 175-178.\n            $(LINK2 https://en.wikipedia.org/wiki/ISO/IEC_2022,\n                The Wikipedia Page on ISO 2022)\n            $(LINK2 https://www.iso.org/standard/22747.html, ISO 2022)\n\n        Throws:\n            ASN1ValueInvalidException = if the string value contains any\n                character outside of 0x20 to 0x7E, which means any control\n                characters or DELETE.\n",
      "line" : 1215,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxAyaZv",
      "originalType" : "@property @system void(in string value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAya"
       }
      ],
      "endline" : 1261,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element.objectDescriptor"
      ]
     },
     {
      "name" : "__unittest___source_codecs_cer_d_1264_0",
      "kind" : "function",
      "line" : 1264,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 1328,
      "endchar" : 5
     },
     {
      "name" : "external",
      "kind" : "function",
      "comment" : "        Decodes an EXTERNAL, which is a constructed data type, defined in\n        the $(LINK2 https://www.itu.int,\n            International Telecommunications Union)'s\n        $(LINK2 https://www.itu.int/rec/T-REC-X.680/en, X.680).\n\n        The specification defines EXTERNAL as:\n\n        $(I\n            EXTERNAL := [UNIVERSAL 8] IMPLICIT SEQUENCE {\n                identification CHOICE {\n                    syntax OBJECT IDENTIFIER,\n                    presentation-context-id INTEGER,\n                    context-negotiation SEQUENCE {\n                        presentation-context-id INTEGER,\n                        transfer-syntax OBJECT IDENTIFIER } },\n                data-value-descriptor ObjectDescriptor OPTIONAL,\n                data-value OCTET STRING }\n        )\n\n        This assumes AUTOMATIC TAGS, so all of the identification choices\n        will be context-specific and numbered from 0 to 2.\n\n        Returns: an External, defined in types.universal.external.\n        Throws:\n            ASN1SizeException = if encoded EmbeddedPDV has too few or too many\n                elements, or if syntaxes or context-negotiation element has\n                too few or too many elements.\n            ASN1ValueTooBigException = if encoded INTEGER is too large to decode.\n            ASN1ValueInvalidException = if encoded ObjectDescriptor contains\n                invalid characters.\n            ASN1InvalidIndexException = if encoded value selects a choice for\n                identification or uses an unspecified index for an element in\n                syntaxes or context-negotiation, or if an unspecified element\n                of EMBEDDED PDV itself is referenced by an out-of-range\n                context-specific index. (See $(D_INLINECODE ASN1InvalidIndexException).)\n",
      "line" : 1329,
      "char" : 14,
      "storageClass" : [
       "deprecated",
       "override"
      ],
      "deco" : "xFNdZS5types9universal8external8External",
      "endline" : 1469,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element.external"
      ]
     },
     {
      "name" : "external",
      "kind" : "function",
      "comment" : "        Encodes an EXTERNAL, which is a constructed data type, defined in\n        the $(LINK2 https://www.itu.int,\n            International Telecommunications Union)'s\n        $(LINK2 https://www.itu.int/rec/T-REC-X.680/en, X.680).\n\n        The specification defines EXTERNAL as:\n\n        $(I\n            EXTERNAL := [UNIVERSAL 8] IMPLICIT SEQUENCE {\n                identification CHOICE {\n                    syntax OBJECT IDENTIFIER,\n                    presentation-context-id INTEGER,\n                    context-negotiation SEQUENCE {\n                        presentation-context-id INTEGER,\n                        transfer-syntax OBJECT IDENTIFIER } },\n                data-value-descriptor ObjectDescriptor OPTIONAL,\n                data-value OCTET STRING }\n        )\n\n        This assumes AUTOMATIC TAGS, so all of the identification choices\n        will be context-specific and numbered from 0 to 2.\n\n        Throws:\n            ASN1ValueTooBigException = if encoded INTEGER is too large to decode\n            ASN1ValueInvalidException = if encoded ObjectDescriptor contains\n                invalid characters.\n",
      "line" : 1500,
      "char" : 10,
      "storageClass" : [
       "deprecated",
       "override"
      ],
      "deco" : "FNdxS5types9universal8external8ExternalZv",
      "originalType" : "@property @system void(in External value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xS5types9universal8external8External"
       }
      ],
      "endline" : 1539,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element.external"
      ],
      "out" : {
       "name" : "__ensure",
       "kind" : "function",
       "line" : 1502,
       "char" : 5,
       "deco" : "FNaNbNiZv",
       "originalType" : "@system void()",
       "endline" : 1502,
       "endchar" : 5
      }
     },
     {
      "name" : "__unittest___source_codecs_cer_d_1547_0",
      "kind" : "function",
      "line" : 1547,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 1562,
      "endchar" : 5
     },
     {
      "name" : "__unittest___source_codecs_cer_d_1563_0",
      "kind" : "function",
      "line" : 1563,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 1591,
      "endchar" : 5
     },
     {
      "name" : "__unittest___source_codecs_cer_d_1592_0",
      "kind" : "function",
      "line" : 1592,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 1688,
      "endchar" : 5
     },
     {
      "kind" : "template",
      "comment" : "        Decodes a float or double. This can never decode directly to a\n        real type, because of the way it works.\n\n        For the CER-encoded REAL, a value of 0x40 means \"positive infinity,\"\n        a value of 0x41 means \"negative infinity.\" An empty value means\n        exactly zero. A value whose first byte starts with two cleared bits\n        encodes the real as a string of characters, where the latter nybble\n        takes on values of 0x1, 0x2, or 0x3 to indicate that the string\n        representation conforms to\n        $(LINK2 https://www.iso.org/standard/12285.html, ISO 6093)\n        Numeric Representation 1, 2, or 3 respectively.\n\n        If the first bit is set, then the first byte is an \"information block\"\n        that describes the binary encoding of the REAL on the subsequent bytes.\n        If bit 6 is set, the value is negative; if clear, the value is\n        positive. Bits 4 and 5 determine the base, with a value of 0 indicating\n        a base of 2, a value of 1 indicating a base of 8, and a value of 2\n        indicating a base of 16. Bits 2 and 3 indicates that the value should\n        be scaled by 1, 2, 4, or 8 for values of 1, 2, 3, or 4 respectively.\n        Bits 0 and 1 determine how the exponent is encoded, with 0 indicating\n        that the exponent is encoded as a signed byte on the second byte of\n        the value, with 1 indicating that the exponent is encoded as a signed\n        short on the subsequent two bytes, with 2 indicating that the exponent\n        is encoded as a three-byte signed integer on the subsequent three\n        bytes, and with 4 indicating that the subsequent byte encodes the\n        unsigned length of the exponent on the following bytes. The remaining\n        bytes encode an unsigned integer, N, such that mantissa is equal to\n        sign * N * 2^scale.\n\n        Note that this method assumes that your machine uses IEEE 754 floating\n        point format.\n\n        If you attempt to decode a REAL that is too big to fit into the selected\n        floating point type, the value of the real will quietly set to zero. This\n        cannot happen if the transmitted value is in base-2, but it can happen if\n        the transmitted value is in base-8 or base-16.\n\n        Throws:\n            ConvException = if character-encoding cannot be converted to\n                the selected floating-point type, T.\n            ConvOverflowException = if the character-encoding encodes a\n                number that is too big for the selected floating-point\n                type to express.\n            ASN1ValueTooSmallException = if the binary-encoding contains fewer\n                bytes than the information byte purports.\n            ASN1ValueTooBigException = if the binary-encoded mantissa is too\n                big to be expressed by an unsigned long integer.\n            ASN1ValueInvalidException = if both bits indicating the base in the\n                information byte of a binary-encoded REAL's information byte\n                are set, which would indicate an invalid base.\n\n        Citations:\n            Dubuisson, Olivier. “Canonical Encoding Rules (CER).” ASN.1:\n            Communication between Heterogeneous Systems, Morgan Kaufmann,\n            2001, pp. 400–402.\n",
      "line" : 1689,
      "char" : 7,
      "name" : "realNumber",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "constraint" : "isFloatingPoint!T",
      "members" : [
       {
        "name" : "realNumber",
        "kind" : "function",
        "line" : 1689,
        "char" : 7,
        "type" : "const @property @system T()",
        "endline" : 1985,
        "endchar" : 5
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "        Encodes a float or double. This can never decode directly to a\n        real type, because of the way it works.\n\n        This is admittedly a pretty slow function, so I would recommend\n        avoiding it, if possible. Also, because it is so complex, it is\n        highly likely to have bugs, so for that reason as well, I highly\n        recommand against encoding or decoding REALs if you do not have\n        to; try using INTEGER instead.\n\n        For the CER-encoded REAL, a value of 0x40 means \"positive infinity,\"\n        a value of 0x41 means \"negative infinity.\" An empty value means\n        exactly zero. A value whose first byte starts with two cleared bits\n        encodes the real as a string of characters, where the latter nybble\n        takes on values of 0x1, 0x2, or 0x3 to indicate that the string\n        representation conforms to\n        $(LINK2 , ISO 6093) Numeric Representation 1, 2, or 3 respectively.\n\n        If the first bit is set, then the first byte is an \"information block\"\n        that describes the binary encoding of the REAL on the subsequent bytes.\n        If bit 6 is set, the value is negative; if clear, the value is\n        positive. Bits 4 and 5 determine the base, with a value of 0 indicating\n        a base of 2, a value of 1 indicating a base of 8, and a value of 2\n        indicating a base of 16. Bits 2 and 3 indicates that the value should\n        be scaled by 1, 2, 4, or 8 for values of 1, 2, 3, or 4 respectively.\n        Bits 0 and 1 determine how the exponent is encoded, with 0 indicating\n        that the exponent is encoded as a signed byte on the second byte of\n        the value, with 1 indicating that the exponent is encoded as a signed\n        short on the subsequent two bytes, with 2 indicating that the exponent\n        is encoded as a three-byte signed integer on the subsequent three\n        bytes, and with 4 indicating that the subsequent byte encodes the\n        unsigned length of the exponent on the following bytes. The remaining\n        bytes encode an unsigned integer, N, such that mantissa is equal to\n        sign * N * 2^scale.\n\n        Note that this method assumes that your machine uses IEEE 754 floating\n        point format.\n\n        Throws:\n            ASN1ValueInvalidException = if an attempt to encode NaN is made.\n            ASN1ValueTooSmallException = if an attempt to encode would result\n                in an arithmetic underflow of a signed short.\n            ASN1ValueTooBigException = if an attempt to encode would result\n                in an arithmetic overflow of a signed short.\n\n        Citations:\n            Dubuisson, Olivier. “Canonical Encoding Rules (CER).” ASN.1:\n            Communication between Heterogeneous Systems, Morgan Kaufmann,\n            2001, pp. 400–402.\n",
      "line" : 2038,
      "char" : 10,
      "name" : "realNumber",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "constraint" : "isFloatingPoint!T",
      "members" : [
       {
        "name" : "realNumber",
        "kind" : "function",
        "line" : 2038,
        "char" : 10,
        "type" : "@property @system void(in T value)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "T",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 2208,
        "endchar" : 5
       }
      ]
     },
     {
      "name" : "__unittest___source_codecs_cer_d_2212_0",
      "kind" : "function",
      "line" : 2212,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 2255,
      "endchar" : 5
     },
     {
      "name" : "__unittest___source_codecs_cer_d_2256_0",
      "kind" : "function",
      "line" : 2256,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 2296,
      "endchar" : 5
     },
     {
      "kind" : "template",
      "comment" : "        Decodes an integer from an ENUMERATED type. In CER, an ENUMERATED\n        type is encoded the exact same way that an INTEGER is.\n\n        Returns: any chosen signed integral type\n        Throws:\n            ASN1ValueTooBigException = if the value is too big to decode\n                to a signed integral type.\n",
      "line" : 2297,
      "char" : 7,
      "name" : "enumerated",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "constraint" : "isIntegral!T && isSigned!T",
      "members" : [
       {
        "name" : "enumerated",
        "kind" : "function",
        "line" : 2297,
        "char" : 7,
        "type" : "const @property @system T()",
        "endline" : 2369,
        "endchar" : 5
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "        Encodes an ENUMERATED type from an integer. In CER, an ENUMERATED\n        type is encoded the exact same way that an INTEGER is.\n",
      "line" : 2376,
      "char" : 10,
      "name" : "enumerated",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "enumerated",
        "kind" : "function",
        "line" : 2376,
        "char" : 10,
        "type" : "nothrow @property @system void(in T value)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "T",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 2433,
        "endchar" : 5
       }
      ]
     },
     {
      "name" : "__unittest___source_codecs_cer_d_2437_0",
      "kind" : "function",
      "line" : 2437,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 2461,
      "endchar" : 5
     },
     {
      "name" : "__unittest___source_codecs_cer_d_2462_0",
      "kind" : "function",
      "line" : 2462,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 2543,
      "endchar" : 5
     },
     {
      "name" : "embeddedPresentationDataValue",
      "kind" : "function",
      "comment" : "\n        Decodes an EMBEDDED PDV, which is a constructed data type, defined in\n            the $(LINK2 https://www.itu.int,\n                International Telecommunications Union)'s\n            $(LINK2 https://www.itu.int/rec/T-REC-X.680/en, X.680).\n\n        The specification defines EMBEDDED PDV as:\n\n        $(I\n            EmbeddedPDV ::= [UNIVERSAL 11] IMPLICIT SEQUENCE {\n                identification CHOICE {\n                    syntaxes SEQUENCE {\n                        abstract OBJECT IDENTIFIER,\n                        transfer OBJECT IDENTIFIER },\n                    syntax OBJECT IDENTIFIER,\n                    presentation-context-id INTEGER,\n                    context-negotiation SEQUENCE {\n                        presentation-context-id INTEGER,\n                        transfer-syntax OBJECT IDENTIFIER },\n                    transfer-syntax OBJECT IDENTIFIER,\n                    fixed NULL },\n                data-value-descriptor ObjectDescriptor OPTIONAL,\n                data-value OCTET STRING }\n            (WITH COMPONENTS { ... , data-value-descriptor ABSENT })\n        )\n\n        This assumes AUTOMATIC TAGS, so all of the identification choices\n        will be context-specific and numbered from 0 to 5.\n\n        In Canonical Encoding Rules (CER), the identification CHOICE cannot be\n        presentation-context-id, nor context-negotiation. Also, the elements\n        must appear in the exact order of the specification. With these\n        constraints in mind, the specification effectively becomes:\n\n        $(I\n            EmbeddedPDV ::= [UNIVERSAL 11] IMPLICIT SEQUENCE {\n                identification [0] CHOICE {\n                    syntaxes [0] SEQUENCE {\n                        abstract [0] OBJECT IDENTIFIER,\n                        transfer [1] OBJECT IDENTIFIER },\n                    syntax [1] OBJECT IDENTIFIER,\n                    transfer-syntax [4] OBJECT IDENTIFIER,\n                    fixed [5] NULL },\n                data-value [2] OCTET STRING }\n        )\n\n        Throws:\n            ASN1SizeException = if encoded EmbeddedPDV has too few or too many\n                elements, or if syntaxes or context-negotiation element has\n                too few or too many elements.\n            ASN1ValueTooBigException = if encoded INTEGER is too large to decode.\n            ASN1ValueInvalidException = if encoded ObjectDescriptor contains\n                invalid characters.\n            ASN1InvalidIndexException = if encoded value selects a choice for\n                identification or uses an unspecified index for an element in\n                syntaxes or context-negotiation, or if an unspecified element\n                of EMBEDDED PDV itself is referenced by an out-of-range\n                context-specific index. (See $(D_INLINECODE ASN1InvalidIndexException).)\n",
      "line" : 2544,
      "char" : 17,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZS5types9universal11embeddedpdv29EmbeddedPresentationDataValue",
      "originalType" : "const @property @system EmbeddedPDV()",
      "endline" : 2687,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element.embeddedPresentationDataValue"
      ]
     },
     {
      "name" : "embeddedPresentationDataValue",
      "kind" : "function",
      "comment" : "        Encodes an EMBEDDED PDV, which is a constructed data type, defined in\n            the $(LINK2 https://www.itu.int,\n                International Telecommunications Union)'s\n            $(LINK2 https://www.itu.int/rec/T-REC-X.680/en, X.680).\n\n        The specification defines EMBEDDED PDV as:\n\n        $(I\n            EmbeddedPDV ::= [UNIVERSAL 11] IMPLICIT SEQUENCE {\n                identification CHOICE {\n                    syntaxes SEQUENCE {\n                        abstract OBJECT IDENTIFIER,\n                        transfer OBJECT IDENTIFIER },\n                    syntax OBJECT IDENTIFIER,\n                    presentation-context-id INTEGER,\n                    context-negotiation SEQUENCE {\n                        presentation-context-id INTEGER,\n                        transfer-syntax OBJECT IDENTIFIER },\n                    transfer-syntax OBJECT IDENTIFIER,\n                    fixed NULL },\n                data-value-descriptor ObjectDescriptor OPTIONAL,\n                data-value OCTET STRING }\n            (WITH COMPONENTS { ... , data-value-descriptor ABSENT })\n        )\n\n        This assumes AUTOMATIC TAGS, so all of the identification choices\n        will be context-specific and numbered from 0 to 5.\n\n        In Canonical Encoding Rules (CER), the identification CHOICE cannot be\n        presentation-context-id, nor context-negotiation. Also, the elements\n        must appear in the exact order of the specification. With these\n        constraints in mind, the specification effectively becomes:\n\n        $(I\n            EmbeddedPDV ::= [UNIVERSAL 11] IMPLICIT SEQUENCE {\n                identification [0] CHOICE {\n                    syntaxes [0] SEQUENCE {\n                        abstract [0] OBJECT IDENTIFIER,\n                        transfer [1] OBJECT IDENTIFIER },\n                    syntax [1] OBJECT IDENTIFIER,\n                    transfer-syntax [4] OBJECT IDENTIFIER,\n                    fixed [5] NULL },\n                data-value [2] OCTET STRING }\n        )\n\n        If the supplied identification for the EmbeddedPDV is a\n        presentation-context-id or a context-negotiation, no exception will be\n        thrown; the identification will be set to fixed silently.\n\n        This assumes AUTOMATIC TAGS, so all of the identification choices\n        will be context-specific and numbered from 0 to 5.\n\n        Throws:\n            ASN1ValueInvalidException = if encoded ObjectDescriptor contains\n                invalid characters.\n",
      "line" : 2747,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxS5types9universal11embeddedpdv29EmbeddedPresentationDataValueZv",
      "originalType" : "@property @system void(in EmbeddedPDV value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xS5types9universal11embeddedpdv29EmbeddedPresentationDataValue"
       }
      ],
      "endline" : 2800,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element.embeddedPresentationDataValue"
      ],
      "out" : {
       "name" : "__ensure",
       "kind" : "function",
       "line" : 2749,
       "char" : 5,
       "deco" : "FNaNbNiZv",
       "originalType" : "@system void()",
       "endline" : 2749,
       "endchar" : 5
      }
     },
     {
      "name" : "__unittest___source_codecs_cer_d_2811_0",
      "kind" : "function",
      "line" : 2811,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 2836,
      "endchar" : 5
     },
     {
      "name" : "__unittest___source_codecs_cer_d_2837_0",
      "kind" : "function",
      "line" : 2837,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 2858,
      "endchar" : 5
     },
     {
      "name" : "__unittest___source_codecs_cer_d_2859_0",
      "kind" : "function",
      "line" : 2859,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 2901,
      "endchar" : 5
     },
     {
      "name" : "unicodeTransformationFormat8String",
      "kind" : "function",
      "comment" : "        Decodes the value to UTF-8 characters.\n\n        Throws:\n            UTF8Exception if it does not decode correctly.\n",
      "line" : 2902,
      "char" : 12,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZAya",
      "endline" : 2940,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element.unicodeTransformationFormat8String"
      ]
     },
     {
      "name" : "unicodeTransformationFormat8String",
      "kind" : "function",
      "comment" : "        Encodes a UTF-8 string to bytes. No checks are performed.\n",
      "line" : 2946,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxAyaZv",
      "originalType" : "@property @system void(in string value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAya"
       }
      ],
      "endline" : 2978,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element.unicodeTransformationFormat8String"
      ]
     },
     {
      "name" : "__unittest___source_codecs_cer_d_2981_0",
      "kind" : "function",
      "line" : 2981,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 3022,
      "endchar" : 5
     },
     {
      "name" : "relativeObjectIdentifier",
      "kind" : "function",
      "comment" : "        Decodes a RELATIVE OBJECT IDENTIFIER.\n        See source/types/universal/objectidentifier.d for information about\n        the ObjectIdentifier class (aliased as \"OID\").\n\n        The RELATIVE OBJECT IDENTIFIER's numbers are encoded in base-128\n        on the least significant 7 bits of each byte. For these bytes, the most\n        significant bit is set if the next byte continues the encoding of the\n        current OID number. In other words, the bytes encoding each number\n        always end with a byte whose most significant bit is cleared.\n\n        Standards:\n            $(LINK2 http://www.itu.int/rec/T-REC-X.660-201107-I/en, X.660)\n",
      "line" : 3023,
      "char" : 15,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZAS5types7oidtype20ObjectIdentifierNode",
      "originalType" : "const @property @system OIDNode[]()",
      "endline" : 3095,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element.relativeObjectIdentifier"
      ]
     },
     {
      "name" : "relativeObjectIdentifier",
      "kind" : "function",
      "comment" : "        Encodes a RELATIVE OBJECT IDENTIFIER.\n        See source/types/universal/objectidentifier.d for information about\n        the ObjectIdentifier class (aliased as \"OID\").\n\n        The RELATIVE OBJECT IDENTIFIER's numbers are encoded in base-128\n        on the least significant 7 bits of each byte. For these bytes, the most\n        significant bit is set if the next byte continues the encoding of the\n        current OID number. In other words, the bytes encoding each number\n        always end with a byte whose most significant bit is cleared.\n\n        Standards:\n            $(LINK2 http://www.itu.int/rec/T-REC-X.660-201107-I/en, X.660)\n",
      "line" : 3112,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNbNdxAS5types7oidtype20ObjectIdentifierNodeZv",
      "originalType" : "nothrow @property @system void(in OIDNode[] value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAS5types7oidtype20ObjectIdentifierNode"
       }
      ],
      "endline" : 3137,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element.relativeObjectIdentifier"
      ]
     },
     {
      "name" : "__unittest___source_codecs_cer_d_3140_0",
      "kind" : "function",
      "line" : 3140,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 3159,
      "endchar" : 5
     },
     {
      "name" : "__unittest___source_codecs_cer_d_3160_0",
      "kind" : "function",
      "line" : 3160,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 3193,
      "endchar" : 5
     },
     {
      "name" : "sequence",
      "kind" : "function",
      "comment" : "        Decodes a sequence of CERElements.\n\n        Returns: an array of CERElements.\n        Throws:\n            ASN1ValueSizeException = if long definite-length is too big to be\n                decoded to an unsigned integral type.\n            ASN1ValueTooSmallException = if there are fewer value bytes than\n                indicated by the length tag.\n",
      "line" : 3194,
      "char" : 18,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZAC6codecs3cer29CanonicalEncodingRulesElement",
      "originalType" : "const @property @system CERElement[]()",
      "endline" : 3201,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element.sequence"
      ]
     },
     {
      "name" : "sequence",
      "kind" : "function",
      "comment" : "        Encodes a sequence of CERElements.\n",
      "line" : 3207,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxAC6codecs3cer29CanonicalEncodingRulesElementZv",
      "originalType" : "@property @system void(in CERElement[] value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAC6codecs3cer29CanonicalEncodingRulesElement"
       }
      ],
      "endline" : 3215,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element.sequence"
      ]
     },
     {
      "name" : "set",
      "kind" : "function",
      "comment" : "        Decodes a set of CERElements.\n\n        Returns: an array of CERElements.\n        Throws:\n            ASN1ValueSizeException = if long definite-length is too big to be\n                decoded to an unsigned integral type.\n            ASN1ValueTooSmallException = if there are fewer value bytes than\n                indicated by the length tag.\n",
      "line" : 3228,
      "char" : 18,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZAC6codecs3cer29CanonicalEncodingRulesElement",
      "originalType" : "const @property @system CERElement[]()",
      "endline" : 3235,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element.set"
      ]
     },
     {
      "name" : "set",
      "kind" : "function",
      "comment" : "        Encodes a set of CERElements.\n",
      "line" : 3241,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxAC6codecs3cer29CanonicalEncodingRulesElementZv",
      "originalType" : "@property @system void(in CERElement[] value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAC6codecs3cer29CanonicalEncodingRulesElement"
       }
      ],
      "endline" : 3249,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element.set"
      ]
     },
     {
      "name" : "numericString",
      "kind" : "function",
      "comment" : "        Decodes a string, where the characters of the string are limited to\n        0 - 9 and space.\n\n        Returns: a string.\n        Throws:\n            ASN1ValueInvalidException = if any character other than 0-9 or\n                space is encoded.\n",
      "line" : 3261,
      "char" : 12,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZAya",
      "endline" : 3323,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element.numericString"
      ]
     },
     {
      "name" : "numericString",
      "kind" : "function",
      "comment" : "        Encodes a string, where the characters of the string are limited to\n        0 - 9 and space.\n\n        Throws:\n            ASN1ValueInvalidException = if any character other than 0-9 or\n                space is supplied.\n",
      "line" : 3334,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxAyaZv",
      "originalType" : "@property @system void(in string value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAya"
       }
      ],
      "endline" : 3379,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element.numericString"
      ]
     },
     {
      "name" : "__unittest___source_codecs_cer_d_3382_0",
      "kind" : "function",
      "line" : 3382,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 3421,
      "endchar" : 5
     },
     {
      "name" : "printableString",
      "kind" : "function",
      "comment" : "        Decodes a string that will only contain characters a-z, A-Z, 0-9,\n        space, apostrophe, parentheses, comma, minus, plus, period,\n        forward slash, colon, equals, and question mark.\n\n        Returns: a string.\n        Throws:\n            ASN1ValueInvalidException = if any character other than a-z, A-Z,\n                0-9, space, apostrophe, parentheses, comma, minus, plus,\n                period, forward slash, colon, equals, or question mark are\n                encoded.\n",
      "line" : 3422,
      "char" : 12,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZAya",
      "endline" : 3489,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element.printableString"
      ]
     },
     {
      "name" : "printableString",
      "kind" : "function",
      "comment" : "        Encodes a string that may only contain characters a-z, A-Z, 0-9,\n        space, apostrophe, parentheses, comma, minus, plus, period,\n        forward slash, colon, equals, and question mark.\n\n        Throws:\n            ASN1ValueInvalidException = if any character other than a-z, A-Z,\n                0-9, space, apostrophe, parentheses, comma, minus, plus,\n                period, forward slash, colon, equals, or question mark are\n                supplied.\n",
      "line" : 3503,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxAyaZv",
      "originalType" : "@property @system void(in string value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAya"
       }
      ],
      "endline" : 3549,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element.printableString"
      ]
     },
     {
      "name" : "__unittest___source_codecs_cer_d_3552_0",
      "kind" : "function",
      "line" : 3552,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 3584,
      "endchar" : 5
     },
     {
      "name" : "teletexString",
      "kind" : "function",
      "comment" : "        Literally just returns the value bytes.\n\n        Returns: an unsigned byte array, where each byte is a T.61 character.\n",
      "line" : 3585,
      "char" : 13,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZAh",
      "endline" : 3624,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element.teletexString"
      ]
     },
     {
      "name" : "teletexString",
      "kind" : "function",
      "comment" : "        Literally just sets the value bytes.\n",
      "line" : 3630,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxAhZv",
      "originalType" : "@property @system void(in ubyte[] value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAh"
       }
      ],
      "endline" : 3663,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element.teletexString"
      ]
     },
     {
      "name" : "__unittest___source_codecs_cer_d_3666_0",
      "kind" : "function",
      "line" : 3666,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 3698,
      "endchar" : 5
     },
     {
      "name" : "videotexString",
      "kind" : "function",
      "comment" : "        Literally just returns the value bytes.\n\n        Returns: an unsigned byte array.\n",
      "line" : 3699,
      "char" : 13,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZAh",
      "endline" : 3738,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element.videotexString"
      ]
     },
     {
      "name" : "videotexString",
      "kind" : "function",
      "comment" : "        Literally just sets the value bytes.\n",
      "line" : 3744,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxAhZv",
      "originalType" : "@property @system void(in ubyte[] value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAh"
       }
      ],
      "endline" : 3777,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element.videotexString"
      ]
     },
     {
      "name" : "__unittest___source_codecs_cer_d_3780_0",
      "kind" : "function",
      "line" : 3780,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 3831,
      "endchar" : 5
     },
     {
      "name" : "internationalAlphabetNumber5String",
      "kind" : "function",
      "comment" : "        Decodes a string that only contains ASCII characters.\n\n        IA5String differs from ASCII ever so slightly: IA5 is international,\n        leaving 10 characters up to be locale-specific:\n\n        $(TABLE\n            $(TR $(TH Byte) $(TH ASCII Character))\n            $(TR $(TD 0x40) $(TD @))\n            $(TR $(TD 0x5B) $(TD [))\n            $(TR $(TD 0x5C) $(TD \\))\n            $(TR $(TD 0x5D) $(TD ]))\n            $(TR $(TD 0x5E) $(TD ^))\n            $(TR $(TD 0x60) $(TD `))\n            $(TR $(TD 0x7B) $(TD {))\n            $(TR $(TD 0x7C) $(TD /))\n            $(TR $(TD 0x7D) $(TD }))\n            $(TR $(TD 0x7E) $(TD ~))\n        )\n\n        Returns: a string.\n        Throws:\n            ASN1ValueInvalidException = if any enecoded character is not ASCII.\n",
      "line" : 3832,
      "char" : 12,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZAya",
      "endline" : 3895,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element.internationalAlphabetNumber5String"
      ]
     },
     {
      "name" : "internationalAlphabetNumber5String",
      "kind" : "function",
      "comment" : "        Encodes a string that may only contain ASCII characters.\n\n        IA5String differs from ASCII ever so slightly: IA5 is international,\n        leaving 10 characters up to be locale-specific:\n\n        $(TABLE\n            $(TR $(TH Byte) $(TH ASCII Character))\n            $(TR $(TD 0x40) $(TD @))\n            $(TR $(TD 0x5B) $(TD [))\n            $(TR $(TD 0x5C) $(TD \\))\n            $(TR $(TD 0x5D) $(TD ]))\n            $(TR $(TD 0x5E) $(TD ^))\n            $(TR $(TD 0x60) $(TD `))\n            $(TR $(TD 0x7B) $(TD {))\n            $(TR $(TD 0x7C) $(TD /))\n            $(TR $(TD 0x7D) $(TD }))\n            $(TR $(TD 0x7E) $(TD ~))\n        )\n\n        Throws:\n            ASN1ValueInvalidException = if any enecoded character is not ASCII.\n",
      "line" : 3921,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxAyaZv",
      "originalType" : "@property @system void(in string value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAya"
       }
      ],
      "endline" : 3965,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element.internationalAlphabetNumber5String"
      ]
     },
     {
      "name" : "__unittest___source_codecs_cer_d_3968_0",
      "kind" : "function",
      "line" : 3968,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 4019,
      "endchar" : 5
     },
     {
      "name" : "coordinatedUniversalTime",
      "kind" : "function",
      "comment" : "        Decodes a DateTime.\n\n        The CER-encoded value is just the ASCII character representation of\n        the UTC-formatted timestamp.\n\n        An UTC Timestamp looks like:\n        $(UL\n            $(LI 9912312359Z)\n            $(LI 991231235959+0200)\n        )\n\n        If the first digit of the two-digit year is 7, 6, 5, 4, 3, 2, 1, or 0,\n        meaning that the date refers to the first 80 years of the century, this\n        assumes we are talking about the 21st century and prepend '20' when\n        creating the ISO Date String. Otherwise, it assumes we are talking\n        about the 20th century, and prepend '19' when creating the string.\n\n        See_Also:\n            $(LINK2 https://www.obj-sys.com/asn1tutorial/node15.html, UTCTime)\n\n        Throws:\n            DateTimeException = if string cannot be decoded to a DateTime\n",
      "line" : 4020,
      "char" : 14,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZS3std8datetime4date8DateTime",
      "endline" : 4044,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element.coordinatedUniversalTime"
      ]
     },
     {
      "name" : "coordinatedUniversalTime",
      "kind" : "function",
      "comment" : "        Encodes a DateTime.\n\n        The CER-encoded value is just the ASCII character representation of\n        the UTC-formatted timestamp.\n\n        An UTC Timestamp looks like:\n        $(UL\n            $(LI 9912312359Z)\n            $(LI 991231235959+0200)\n        )\n\n        See_Also:\n            $(LINK2 https://www.obj-sys.com/asn1tutorial/node15.html, UTCTime)\n",
      "line" : 4062,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxS3std8datetime4date8DateTimeZv",
      "originalType" : "@property @system void(in DateTime value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xS3std8datetime4date8DateTime"
       }
      ],
      "endline" : 4072,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element.coordinatedUniversalTime"
      ],
      "out" : {
       "name" : "__ensure",
       "kind" : "function",
       "line" : 4064,
       "char" : 5,
       "deco" : "FNaNbNiZv",
       "originalType" : "@system void()",
       "endline" : 4064,
       "endchar" : 5
      }
     },
     {
      "name" : "generalizedTime",
      "kind" : "function",
      "comment" : "        Decodes a DateTime.\n\n        The CER-encoded value is just the ASCII character representation of\n        the $(LINK2 https://www.iso.org/iso-8601-date-and-time-format.html,\n        ISO 8601)-formatted timestamp.\n\n        An ISO-8601 Timestamp looks like:\n        $(UL\n            $(LI 19851106210627.3)\n            $(LI 19851106210627.3Z)\n            $(LI 19851106210627.3-0500)\n        )\n\n        Throws:\n            DateTimeException = if string cannot be decoded to a DateTime\n",
      "line" : 4092,
      "char" : 14,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZS3std8datetime4date8DateTime",
      "endline" : 4116,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element.generalizedTime"
      ]
     },
     {
      "name" : "generalizedTime",
      "kind" : "function",
      "comment" : "        Encodes a DateTime.\n\n        The CER-encoded value is just the ASCII character representation of\n        the $(LINK2 https://www.iso.org/iso-8601-date-and-time-format.html,\n        ISO 8601)-formatted timestamp.\n\n        An ISO-8601 Timestamp looks like:\n        $(UL\n            $(LI 19851106210627.3)\n            $(LI 19851106210627.3Z)\n            $(LI 19851106210627.3-0500)\n        )\n",
      "line" : 4133,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxS3std8datetime4date8DateTimeZv",
      "originalType" : "@property @system void(in DateTime value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xS3std8datetime4date8DateTime"
       }
      ],
      "endline" : 4143,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element.generalizedTime"
      ],
      "out" : {
       "name" : "__ensure",
       "kind" : "function",
       "line" : 4135,
       "char" : 5,
       "deco" : "FNaNbNiZv",
       "originalType" : "@system void()",
       "endline" : 4135,
       "endchar" : 5
      }
     },
     {
      "name" : "graphicString",
      "kind" : "function",
      "comment" : "        Decodes an ASCII string that contains only characters between and\n        including 0x20 and 0x75.\n\n        Deprecated, according to page 182 of the Dubuisson book.\n\n        Citations:\n            Dubuisson, Olivier. “Character String Types.” ASN.1:\n                Communication between Heterogeneous Systems, Morgan\n                Kaufmann, 2001, pp. 175-178.\n            $(LINK2 https://en.wikipedia.org/wiki/ISO/IEC_2022,\n                The Wikipedia Page on ISO 2022)\n            $(LINK2 https://www.iso.org/standard/22747.html, ISO 2022)\n\n        Returns: a string.\n        Throws:\n            ASN1ValueInvalidException = if any non-graphical character\n                (including space) is encoded.\n",
      "line" : 4165,
      "char" : 12,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZAya",
      "endline" : 4230,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element.graphicString"
      ]
     },
     {
      "name" : "graphicString",
      "kind" : "function",
      "comment" : "        Encodes an ASCII string that may contain only characters between and\n        including 0x20 and 0x75.\n\n        Deprecated, according to page 182 of the Dubuisson book.\n\n        Citations:\n            Dubuisson, Olivier. “Character String Types.” ASN.1:\n                Communication between Heterogeneous Systems, Morgan\n                Kaufmann, 2001, pp. 175-178.\n            $(LINK2 https://en.wikipedia.org/wiki/ISO/IEC_2022,\n                The Wikipedia Page on ISO 2022)\n            $(LINK2 https://www.iso.org/standard/22747.html, ISO 2022)\n\n        Throws:\n            ASN1ValueInvalidException = if any non-graphical character\n                (including space) is supplied.\n",
      "line" : 4251,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxAyaZv",
      "originalType" : "@property @system void(in string value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAya"
       }
      ],
      "endline" : 4297,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element.graphicString"
      ]
     },
     {
      "name" : "__unittest___source_codecs_cer_d_4300_0",
      "kind" : "function",
      "line" : 4300,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 4337,
      "endchar" : 5
     },
     {
      "name" : "visibleString",
      "kind" : "function",
      "comment" : "        Decodes a string that only contains characters between and including\n        0x20 and 0x7E. (Honestly, I don't know how this differs from\n        GraphicalString.)\n\n        Returns: a string.\n        Throws:\n            ASN1ValueInvalidException = if any non-graphical character\n                (including space) is encoded.\n",
      "line" : 4338,
      "char" : 12,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZAya",
      "endline" : 4403,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element.visibleString"
      ]
     },
     {
      "name" : "visibleString",
      "kind" : "function",
      "comment" : "        Encodes a string that only contains characters between and including\n        0x20 and 0x7E. (Honestly, I don't know how this differs from\n        GraphicalString.)\n\n        Throws:\n            ASN1ValueInvalidException = if any non-graphical character\n                (including space) is supplied.\n",
      "line" : 4415,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxAyaZv",
      "originalType" : "@property @system void(in string value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAya"
       }
      ],
      "endline" : 4461,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element.visibleString"
      ]
     },
     {
      "name" : "__unittest___source_codecs_cer_d_4464_0",
      "kind" : "function",
      "line" : 4464,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 4505,
      "endchar" : 5
     },
     {
      "name" : "generalString",
      "kind" : "function",
      "comment" : "        Decodes a string containing only ASCII characters.\n\n        Deprecated, according to page 182 of the Dubuisson book.\n\n        Returns: a string.\n        Throws:\n            ASN1ValueInvalidException = if any enecoded character is not ASCII.\n\n        Citations:\n            Dubuisson, Olivier. “Canonical Encoding Rules (CER).” ASN.1:\n            Communication between Heterogeneous Systems, Morgan Kaufmann,\n            2001, p. 182.\n",
      "line" : 4506,
      "char" : 12,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZAya",
      "endline" : 4569,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element.generalString"
      ]
     },
     {
      "name" : "generalString",
      "kind" : "function",
      "comment" : "        Encodes a string containing only ASCII characters.\n\n        Deprecated, according to page 182 of the Dubuisson book.\n\n        Throws:\n            ASN1ValueInvalidException = if any enecoded character is not ASCII.\n\n        Citations:\n            Dubuisson, Olivier. “Canonical Encoding Rules (CER).” ASN.1:\n            Communication between Heterogeneous Systems, Morgan Kaufmann,\n            2001, p. 182.\n",
      "line" : 4585,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxAyaZv",
      "originalType" : "@property @system void(in string value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAya"
       }
      ],
      "endline" : 4629,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element.generalString"
      ]
     },
     {
      "name" : "__unittest___source_codecs_cer_d_4632_0",
      "kind" : "function",
      "line" : 4632,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 4667,
      "endchar" : 5
     },
     {
      "name" : "universalString",
      "kind" : "function",
      "comment" : "        Decodes a dstring of UTF-32 characters.\n\n        Returns: a string of UTF-32 characters.\n        Throws:\n            ASN1ValueInvalidException = if the encoded bytes is not evenly\n                divisible by four.\n",
      "line" : 4668,
      "char" : 13,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZAyw",
      "endline" : 4773,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element.universalString"
      ]
     },
     {
      "name" : "universalString",
      "kind" : "function",
      "comment" : "        Encodes a dstring of UTF-32 characters.\n",
      "line" : 4779,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxAywZv",
      "originalType" : "@property @system void(in dstring value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAyw"
       }
      ],
      "endline" : 4859,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element.universalString"
      ]
     },
     {
      "name" : "__unittest___source_codecs_cer_d_4862_0",
      "kind" : "function",
      "line" : 4862,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 4928,
      "endchar" : 5
     },
     {
      "name" : "characterString",
      "kind" : "function",
      "comment" : "        Decodes a CHARACTER STRING, which is a constructed data type, defined\n        in the $(LINK2 https://www.itu.int,\n                International Telecommunications Union)'s\n            $(LINK2 https://www.itu.int/rec/T-REC-X.680/en, X.680).\n\n        The specification defines CHARACTER as:\n\n        $(I\n            CHARACTER STRING ::= [UNIVERSAL 29] SEQUENCE {\n                identification CHOICE {\n                    syntaxes SEQUENCE {\n                        abstract OBJECT IDENTIFIER,\n                        transfer OBJECT IDENTIFIER },\n                    syntax OBJECT IDENTIFIER,\n                    presentation-context-id INTEGER,\n                    context-negotiation SEQUENCE {\n                        presentation-context-id INTEGER,\n                        transfer-syntax OBJECT IDENTIFIER },\n                    transfer-syntax OBJECT IDENTIFIER,\n                    fixed NULL },\n                string-value OCTET STRING }\n        )\n\n        This assumes AUTOMATIC TAGS, so all of the identification choices\n        will be context-specific and numbered from 0 to 5.\n\n        Returns: an instance of types.universal.CharacterString.\n        Throws:\n            ASN1SizeException = if encoded CharacterString has too few or too many\n                elements, or if syntaxes or context-negotiation element has\n                too few or too many elements.\n            ASN1ValueTooBigException = if encoded INTEGER is too large to decode.\n            ASN1InvalidIndexException = if encoded value selects a choice for\n                identification or uses an unspecified index for an element in\n                syntaxes or context-negotiation, or if an unspecified element\n                of CharacterString itself is referenced by an out-of-range\n                context-specific index. (See $(D_INLINECODE ASN1InvalidIndexException).)\n",
      "line" : 4929,
      "char" : 21,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZS5types9universal15characterstring15CharacterString",
      "endline" : 5072,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element.characterString"
      ]
     },
     {
      "name" : "characterString",
      "kind" : "function",
      "comment" : "        Encodes a CHARACTER STRING, which is a constructed data type, defined\n        in the $(LINK2 https://www.itu.int,\n                International Telecommunications Union)'s\n            $(LINK2 https://www.itu.int/rec/T-REC-X.680/en, X.680).\n\n        The specification defines CHARACTER as:\n\n        $(I\n            CHARACTER STRING ::= [UNIVERSAL 29] SEQUENCE {\n                identification CHOICE {\n                    syntaxes SEQUENCE {\n                        abstract OBJECT IDENTIFIER,\n                        transfer OBJECT IDENTIFIER },\n                    syntax OBJECT IDENTIFIER,\n                    presentation-context-id INTEGER,\n                    context-negotiation SEQUENCE {\n                        presentation-context-id INTEGER,\n                        transfer-syntax OBJECT IDENTIFIER },\n                    transfer-syntax OBJECT IDENTIFIER,\n                    fixed NULL },\n                string-value OCTET STRING }\n        )\n\n        This assumes AUTOMATIC TAGS, so all of the identification choices\n        will be context-specific and numbered from 0 to 5.\n",
      "line" : 5102,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxS5types9universal15characterstring15CharacterStringZv",
      "originalType" : "@property @system void(in CharacterString value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xS5types9universal15characterstring15CharacterString"
       }
      ],
      "endline" : 5155,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element.characterString"
      ],
      "out" : {
       "name" : "__ensure",
       "kind" : "function",
       "line" : 5104,
       "char" : 5,
       "deco" : "FNaNbNiZv",
       "originalType" : "@system void()",
       "endline" : 5104,
       "endchar" : 5
      }
     },
     {
      "name" : "__unittest___source_codecs_cer_d_5166_0",
      "kind" : "function",
      "line" : 5166,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 5187,
      "endchar" : 5
     },
     {
      "name" : "__unittest___source_codecs_cer_d_5188_0",
      "kind" : "function",
      "line" : 5188,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 5232,
      "endchar" : 5
     },
     {
      "name" : "basicMultilingualPlaneString",
      "kind" : "function",
      "comment" : "        Decodes a wstring of UTF-16 characters.\n\n        Returns: an immutable array of UTF-16 characters.\n        Throws:\n            ASN1ValueInvalidException = if the encoded bytes is not evenly\n                divisible by two.\n",
      "line" : 5233,
      "char" : 13,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZAyu",
      "endline" : 5334,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element.basicMultilingualPlaneString"
      ]
     },
     {
      "name" : "basicMultilingualPlaneString",
      "kind" : "function",
      "comment" : "        Encodes a wstring of UTF-16 characters.\n",
      "line" : 5340,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxAyuZv",
      "originalType" : "@property @system void(in wstring value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAyu"
       }
      ],
      "endline" : 5420,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(CanonicalEncodingRulesElement).AbstractSyntaxNotation1Element.basicMultilingualPlaneString"
      ]
     },
     {
      "name" : "__unittest___source_codecs_cer_d_5423_0",
      "kind" : "function",
      "line" : 5423,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 5453,
      "endchar" : 5
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "        Creates an EndOfContent CER Value.\n",
      "line" : 5454,
      "char" : 5,
      "deco" : "FNbNiNfZC6codecs3cer29CanonicalEncodingRulesElement",
      "originalType" : "nothrow @nogc @safe ()",
      "endline" : 5458,
      "endchar" : 5
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "        Creates a CERElement from the supplied bytes, inferring that the first\n        byte is the type tag. The supplied ubyte[] array is \"chomped\" by\n        reference, so the original array will grow shorter as CERElements are\n        generated.\n\n        Throws:\n            ASN1ValueTooSmallException = if the bytes supplied are fewer than\n                two (one or zero, in other words), such that no valid CERElement\n                can be decoded, or if the length is encoded in indefinite\n                form, but the END OF CONTENT octets (two consecutive null\n                octets) cannot be found, or if the value is encoded in fewer\n                octets than indicated by the length byte.\n            ASN1InvalidLengthException = if the length byte is set to 0xFF,\n                which is reserved.\n            ASN1ValueTooBigException = if the length cannot be represented by\n                the largest unsigned integer.\n\n        Example:\n        ---\n        // Decoding looks like:\n        CERElement[] result;\n        while (bytes.length > 0)\n            result ~= new CERElement(bytes);\n\n        // Encoding looks like:\n        ubyte[] result;\n        foreach (cv; bervalues)\n        {\n            result ~= cast(ubyte[]) cv;\n        }\n        ---\n",
      "line" : 5494,
      "char" : 5,
      "deco" : "FKAhZC6codecs3cer29CanonicalEncodingRulesElement",
      "originalType" : "@system (ref ubyte[] bytes)",
      "parameters" : [
       {
        "name" : "bytes",
        "deco" : "Ah",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 5498,
      "endchar" : 5
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "        Creates a CERElement from the supplied bytes, inferring that the first\n        byte is the type tag. The supplied ubyte[] array is read, starting\n        from the index specified by $(D bytesRead), and increments\n        $(D bytesRead) by the number of bytes read.\n\n        Throws:\n            ASN1ValueTooSmallException = if the bytes supplied are fewer than\n                two (one or zero, in other words), such that no valid CERElement\n                can be decoded, or if the length is encoded in indefinite\n                form, but the END OF CONTENT octets (two consecutive null\n                octets) cannot be found, or if the value is encoded in fewer\n                octets than indicated by the length byte.\n            ASN1InvalidLengthException = if the length byte is set to 0xFF,\n                which is reserved.\n            ASN1ValueTooBigException = if the length cannot be represented by\n                the largest unsigned integer.\n\n        Example:\n        ---\n        // Decoding looks like:\n        CERElement[] result;\n        size_t i = 0u;\n        while (i < bytes.length)\n            result ~= new CERElement(i, bytes);\n\n        // Encoding looks like:\n        ubyte[] result;\n        foreach (cv; bervalues)\n        {\n            result ~= cast(ubyte[]) cv;\n        }\n        ---\n",
      "line" : 5535,
      "char" : 5,
      "deco" : "FKmxAhZC6codecs3cer29CanonicalEncodingRulesElement",
      "originalType" : "@system (ref size_t bytesRead, in ubyte[] bytes)",
      "parameters" : [
       {
        "name" : "bytesRead",
        "deco" : "m",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "bytes",
        "deco" : "xAh"
       }
      ],
      "endline" : 5538,
      "endchar" : 5
     },
     {
      "name" : "fromBytes",
      "kind" : "function",
      "line" : 5542,
      "char" : 12,
      "deco" : "FxAhZm",
      "originalType" : "size_t(in ubyte[] bytes)",
      "parameters" : [
       {
        "name" : "bytes",
        "deco" : "xAh"
       }
      ],
      "endline" : 5843,
      "endchar" : 5,
      "overrides" : [
       "interfaces.Byteable.fromBytes"
      ]
     },
     {
      "name" : "toBytes",
      "kind" : "function",
      "comment" : "        This differs from $(D_INLINECODE this.value) in that\n        $(D_INLINECODE this.value) only returns the value octets, whereas\n        $(D_INLINECODE this.toBytes) returns the type tag, length tag / octets,\n        and the value octets, all concatenated.\n\n        This is the exact same as $(D_INLINECODE this.opCast!(ubyte[])()).\n\n        Returns: type tag, length tag, and value, all concatenated as a ubyte array.\n",
      "line" : 5856,
      "char" : 13,
      "deco" : "xFNbNdZAh",
      "endline" : 5935,
      "endchar" : 5,
      "overrides" : [
       "interfaces.Byteable.toBytes"
      ]
     },
     {
      "kind" : "template",
      "comment" : "        This differs from $(D_INLINECODE this.value) in that\n        $(D_INLINECODE this.value) only returns the value octets, whereas\n        $(D_INLINECODE this.toBytes) returns the type tag, length tag / octets,\n        and the value octets, all concatenated.\n\n        This is the exact same as $(D_INLINECODE this.toBytes()).\n\n        Returns: type tag, length tag, and value, all concatenated as a ubyte array.\n",
      "line" : 5948,
      "char" : 13,
      "name" : "opCast",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type",
        "default" : "ubyte[]"
       }
      ],
      "members" : [
       {
        "name" : "opCast",
        "kind" : "function",
        "line" : 5948,
        "char" : 13,
        "type" : "nothrow @system ubyte[]()",
        "endline" : 5951,
        "endchar" : 5
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittest___source_codecs_cer_d_5957_37",
    "kind" : "function",
    "line" : 5957,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 6109,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_cer_d_6110_38",
    "kind" : "function",
    "line" : 6110,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 6151,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_cer_d_6152_39",
    "kind" : "function",
    "line" : 6152,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 6195,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_cer_d_6196_40",
    "kind" : "function",
    "line" : 6196,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 6208,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_cer_d_6209_41",
    "kind" : "function",
    "line" : 6209,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 6222,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_cer_d_6223_42",
    "kind" : "function",
    "line" : 6223,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 6234,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_cer_d_6235_43",
    "kind" : "function",
    "line" : 6235,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 6245,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_cer_d_6246_44",
    "kind" : "function",
    "line" : 6246,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 6256,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_cer_d_6257_45",
    "kind" : "function",
    "line" : 6257,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 6267,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_cer_d_6268_46",
    "kind" : "function",
    "line" : 6268,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 6286,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_cer_d_6287_47",
    "kind" : "function",
    "line" : 6287,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 6310,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_cer_d_6311_48",
    "kind" : "function",
    "line" : 6311,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 6328,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_cer_d_6329_49",
    "kind" : "function",
    "line" : 6329,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 6343,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_cer_d_6344_50",
    "kind" : "function",
    "line" : 6344,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 6353,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_cer_d_6354_51",
    "kind" : "function",
    "line" : 6354,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 6361,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_cer_d_6362_52",
    "kind" : "function",
    "line" : 6362,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 6369,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_cer_d_6370_53",
    "kind" : "function",
    "line" : 6370,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 6377,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_cer_d_6378_54",
    "kind" : "function",
    "line" : 6378,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 6389,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_cer_d_6390_55",
    "kind" : "function",
    "line" : 6390,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 6401,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_cer_d_6402_56",
    "kind" : "function",
    "line" : 6402,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 6410,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_cer_d_6411_57",
    "kind" : "function",
    "line" : 6411,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 6419,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_cer_d_6420_58",
    "kind" : "function",
    "line" : 6420,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 6428,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_cer_d_6429_59",
    "kind" : "function",
    "line" : 6429,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 6454,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_cer_d_6455_60",
    "kind" : "function",
    "line" : 6455,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 6471,
    "endchar" : 2
   }
  ]
 },
 {
  "name" : "codecs.der",
  "kind" : "module",
  "file" : "./source/codecs/der.d",
  "comment" : "    Distinguished Encoding Rules (DER) is a standard for encoding ASN.1 data.\n    DER is often used for cryptgraphically-signed data, such as X.509\n    certificates, because DER's defining feature is that there is only one way\n    to encode each data type, which means that two encodings of the same data\n    could not have different cryptographic signatures. For this reason, DER\n    is generally regarded as the most secure encoding standard for ASN.1.\n    Like Basic Encoding Rules (BER), Canonical Encoding Rules (CER), and\n    Packed Encoding Rules (PER), Distinguished Encoding Rules (DER) is a\n    specification created by the\n    $(LINK2 http://www.itu.int/en/pages/default.aspx,\n        International Telecommunications Union),\n    and specified in\n    $(LINK2 http://www.itu.int/rec/T-REC-X.690/en, X.690 - ASN.1 encoding rules)\n\n    Author:\n        $(LINK2 http://jonathan.wilbur.space, Jonathan M. Wilbur)\n            $(LINK2 mailto:jonathan@wilbur.space, jonathan@wilbur.space)\n    License: $(LINK2 https://mit-license.org/, MIT License)\n    Standards:\n        $(LINK2 https://www.itu.int/rec/T-REC-X.680/en, X.680 - Abstract Syntax Notation One (ASN.1))\n        $(LINK2 http://www.itu.int/rec/T-REC-X.690/en, X.690 - ASN.1 encoding rules)\n    See_Also:\n        $(LINK2 https://en.wikipedia.org/wiki/Abstract_Syntax_Notation_One, The Wikipedia Page on ASN.1)\n        $(LINK2 https://en.wikipedia.org/wiki/X.690, The Wikipedia Page on X.690)\n        $(LINK2 https://www.strozhevsky.com/free_docs/asn1_in_simple_words.pdf, ASN.1 By Simple Words)\n        $(LINK2 http://www.oss.com/asn1/resources/books-whitepapers-pubs/dubuisson-asn1-book.PDF, ASN.1: Communication Between Heterogeneous Systems)\n",
  "members" : [
   {
    "name" : "codec",
    "kind" : "import",
    "line" : 30,
    "char" : 15
   },
   {
    "name" : "interfaces",
    "kind" : "import",
    "line" : 31,
    "char" : 15,
    "selective" : [
     "Byteable"
    ]
   },
   {
    "name" : "types.identification",
    "kind" : "import",
    "line" : 32,
    "char" : 15
   },
   {
    "name" : "derOID",
    "kind" : "alias",
    "comment" : "\n",
    "line" : 35,
    "char" : 8
   },
   {
    "name" : "derObjectID",
    "kind" : "alias",
    "comment" : "\n",
    "line" : 37,
    "char" : 8
   },
   {
    "name" : "derObjectIdentifier",
    "kind" : "alias",
    "comment" : "\n",
    "line" : 39,
    "char" : 8
   },
   {
    "name" : "distinguishedEncodingRulesObjectIdentifier",
    "kind" : "variable",
    "comment" : "    The object identifier assigned to the Distinguished Encoding Rules (DER), per the\n    $(LINK2 http://www.itu.int/en/pages/default.aspx,\n        International Telecommunications Union)'s,\n    $(LINK2 http://www.itu.int/rec/T-REC-X.690/en, X.690 - ASN.1 encoding rules)\n\n    $(I {joint-iso-itu-t asn1(1) ber-derived(2) distinguished-encoding(1)} )\n",
    "line" : 48,
    "char" : 22,
    "storageClass" : [
     "immutable"
    ],
    "deco" : "yC5types9universal16objectidentifier16ObjectIdentifier",
    "originalType" : "OID",
    "init" : "ObjectIdentifier([ObjectIdentifierNode(2LU, \"\"), ObjectIdentifierNode(1LU, \"\"), ObjectIdentifierNode(2LU, \"\"), ObjectIdentifierNode(1LU, \"\")])"
   },
   {
    "name" : "DERElement",
    "kind" : "alias",
    "comment" : "\n",
    "line" : 51,
    "char" : 8,
    "deco" : "C6codecs3der33DistinguishedEncodingRulesElement"
   },
   {
    "name" : "DistinguishedEncodingRulesElement",
    "kind" : "class",
    "comment" : "    The unit of encoding and decoding for Distinguished Encoding Rules (DER).\n\n    There are three parts to an element encoded according to the Distinguished\n    Encoding Rules (DER):\n\n    $(UL\n        $(LI A Type Tag, which specifies what data type is encoded)\n        $(LI A Length Tag, which specifies how many subsequent bytes encode the data)\n        $(LI The Encoded Value)\n    )\n\n    They appear in the binary encoding in that order, and as such, the encoding\n    scheme is sometimes described as \"TLV,\" which stands for Type-Length-Value.\n\n    This class provides a properties for getting and setting bit fields of\n    the type tag, but most of it is functionality for encoding data per\n    the specification.\n\n    As an example, this is what encoding a simple INTEGER looks like:\n\n    ---\n    DERElement dv = new DERElement();\n    dv.tagNumber = 0x02u; // \"2\" means this is an INTEGER\n    dv.integer = 1433; // Now the data is encoded.\n    transmit(cast(ubyte[]) dv); // transmit() is a made-up function.\n    ---\n\n    And this is what decoding looks like:\n\n    ---\n    ubyte[] data = receive(); // receive() is a made-up function.\n    DERElement dv2 = new DERElement(data);\n\n    long x;\n    if (dv.tagNumber == 0x02u) // it is an INTEGER\n    {\n        x = dv.integer;\n    }\n    // Now x is 1433!\n    ---\n",
    "line" : 104,
    "char" : 1,
    "base" : "codec.ASN1Element!(codecs.der.DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element",
    "interfaces" : [
     "interfaces.Byteable"
    ],
    "members" : [
     {
      "name" : "__unittest___source_codecs_der_d_107_0",
      "kind" : "function",
      "line" : 107,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 113,
      "endchar" : 5
     },
     {
      "name" : "realEncodingBase",
      "kind" : "variable",
      "comment" : "The base of encoded REALs. May be 2, 8, 10, or 16.\n",
      "line" : 113,
      "char" : 40,
      "storageClass" : [
       "static"
      ],
      "deco" : "E4asn139AbstractSyntaxNotation1RealEncodingBase",
      "originalType" : "ASN1RealEncodingBase",
      "init" : "cast(AbstractSyntaxNotation1RealEncodingBase)cast(ubyte)2u"
     },
     {
      "name" : "tagClass",
      "kind" : "variable",
      "line" : 115,
      "char" : 25,
      "deco" : "E4asn131AbstractSyntaxNotation1TagClass",
      "originalType" : "ASN1TagClass",
      "offset" : 144
     },
     {
      "name" : "construction",
      "kind" : "variable",
      "line" : 116,
      "char" : 29,
      "deco" : "E4asn135AbstractSyntaxNotation1Construction",
      "originalType" : "ASN1Construction",
      "offset" : 145
     },
     {
      "name" : "tagNumber",
      "kind" : "variable",
      "line" : 117,
      "char" : 19,
      "deco" : "m",
      "originalType" : "size_t",
      "offset" : 152
     },
     {
      "name" : "length",
      "kind" : "function",
      "comment" : "The length of the value in octets\n",
      "line" : 121,
      "char" : 12,
      "storageClass" : [
       "final"
      ],
      "deco" : "xFNbNdNfZm",
      "originalType" : "const nothrow @property @safe size_t()",
      "endline" : 124,
      "endchar" : 5
     },
     {
      "name" : "value",
      "kind" : "variable",
      "comment" : "The octets of the encoded value.\n",
      "line" : 127,
      "char" : 20,
      "deco" : "Ah",
      "offset" : 160
     },
     {
      "name" : "boolean",
      "kind" : "function",
      "comment" : "        Decodes a boolean.\n\n        Any non-zero value will be interpreted as TRUE. Only zero will be\n        interpreted as FALSE.\n\n        Returns: a boolean\n        Throws:\n            ASN1ValueSizeException = if the encoded value is anything other\n                than exactly 1 byte in size.\n            ASN1ValueInvalidException = if the encoded byte is not 0xFF or 0x00\n",
      "line" : 142,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdNfZb",
      "endline" : 174,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element.boolean"
      ]
     },
     {
      "name" : "boolean",
      "kind" : "function",
      "comment" : "        Encodes a boolean.\n\n        Any non-zero value will be interpreted as TRUE. Only zero will be\n        interpreted as FALSE.\n",
      "line" : 183,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNbNdNfxbZv",
      "originalType" : "nothrow @property @safe void(in bool value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xb"
       }
      ],
      "endline" : 191,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element.boolean"
      ],
      "out" : {
       "name" : "__ensure",
       "kind" : "function",
       "line" : 185,
       "char" : 5,
       "deco" : "FNaNbNiNfZv",
       "originalType" : "nothrow @safe void()",
       "endline" : 185,
       "endchar" : 5
      }
     },
     {
      "name" : "__unittest___source_codecs_der_d_195_0",
      "kind" : "function",
      "comment" : "\n",
      "line" : 195,
      "char" : 5,
      "storageClass" : [
       "@safe"
      ],
      "endline" : 221,
      "endchar" : 5
     },
     {
      "kind" : "template",
      "comment" : "        Decodes a signed integer.\n\n        The integer is encoded big endian in two's complement form on the\n        smallest number of bytes that can encode it.\n\n        Returns: any chosen signed integral type\n        Throws:\n            ASN1ValueTooBigException = if the value is too big to decode\n                to a signed integral type.\n",
      "line" : 222,
      "char" : 7,
      "name" : "integer",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "constraint" : "isIntegral!T && isSigned!T",
      "members" : [
       {
        "name" : "integer",
        "kind" : "function",
        "line" : 222,
        "char" : 7,
        "type" : "const @property @system T()",
        "endline" : 294,
        "endchar" : 5
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "        Encodes an integer.\n\n        The integer is encoded big endian in two's complement form on the\n        smallest number of bytes that can encode it.\n",
      "line" : 303,
      "char" : 10,
      "name" : "integer",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "constraint" : "isIntegral!T && isSigned!T",
      "members" : [
       {
        "name" : "integer",
        "kind" : "function",
        "line" : 303,
        "char" : 10,
        "type" : "nothrow @property @system void(in T value)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "T",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 360,
        "endchar" : 5
       }
      ]
     },
     {
      "name" : "__unittest___source_codecs_der_d_364_0",
      "kind" : "function",
      "line" : 364,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 388,
      "endchar" : 5
     },
     {
      "name" : "__unittest___source_codecs_der_d_389_0",
      "kind" : "function",
      "line" : 389,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 422,
      "endchar" : 5
     },
     {
      "name" : "bitString",
      "kind" : "function",
      "comment" : "        Decodes an array of $(D bool)s representing a string of bits.\n\n        In Distinguished Encoding Rules (DER), the first byte is an unsigned\n        integral byte indicating the number of unused bits at the end of\n        the BIT STRING. The unused bits must be zeroed.\n\n        Returns: an array of booleans.\n        Throws:\n            ASN1ValueInvalidException = if the first byte has a value greater\n                than seven.\n",
      "line" : 423,
      "char" : 12,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZAb",
      "endline" : 504,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element.bitString"
      ]
     },
     {
      "name" : "bitString",
      "kind" : "function",
      "comment" : "        Encodes an array of $(D bool)s representing a string of bits.\n\n        In Distinguished Encoding Rules (DER), the first byte is an unsigned\n        integral byte indicating the number of unused bits at the end of\n        the BIT STRING. The unused bits must be zeroed.\n",
      "line" : 514,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxAbZv",
      "originalType" : "@property void(in bool[] value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAb"
       }
      ],
      "endline" : 530,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element.bitString"
      ],
      "out" : {
       "name" : "__ensure",
       "kind" : "function",
       "line" : 516,
       "char" : 5,
       "deco" : "FNaNbNiNfZv",
       "originalType" : "void()",
       "endline" : 516,
       "endchar" : 5
      }
     },
     {
      "name" : "__unittest___source_codecs_der_d_534_0",
      "kind" : "function",
      "line" : 534,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 548,
      "endchar" : 5
     },
     {
      "name" : "__unittest___source_codecs_der_d_549_0",
      "kind" : "function",
      "line" : 549,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 561,
      "endchar" : 5
     },
     {
      "name" : "octetString",
      "kind" : "function",
      "comment" : "        Decodes an OCTET STRING into an unsigned byte array.\n\n        Returns: an unsigned byte array.\n",
      "line" : 562,
      "char" : 13,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdNfZAh",
      "endline" : 565,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element.octetString"
      ]
     },
     {
      "name" : "octetString",
      "kind" : "function",
      "comment" : "        Encodes an OCTET STRING from an unsigned byte array.\n",
      "line" : 571,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdNfxAhZv",
      "originalType" : "@property @safe void(in ubyte[] value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAh"
       }
      ],
      "endline" : 574,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element.octetString"
      ]
     },
     {
      "name" : "objectIdentifier",
      "kind" : "function",
      "comment" : "        Decodes an OBJECT IDENTIFIER.\n        See source/types/universal/objectidentifier.d for information about\n        the ObjectIdentifier class (aliased as \"OID\").\n\n        The encoded OBJECT IDENTIFIER's first byte contains the first number\n        of the OID multiplied by 40 and added to the second number of the OID.\n        The subsequent bytes have all the remaining number encoded in base-128\n        on the least significant 7 bits of each byte. For these bytes, the most\n        significant bit is set if the next byte continues the encoding of the\n        current OID number. In other words, the bytes encoding each number\n        always end with a byte whose most significant bit is cleared.\n\n        Throws:\n            ASN1ValueTooSmallException = if an attempt is made to decode\n                an Object Identifier from zero bytes.\n            ASN1ValueTooBigException = if a single OID number is too big to\n                decode to a size_t.\n        Standards:\n            $(LINK2 http://www.itu.int/rec/T-REC-X.660-201107-I/en, X.660)\n",
      "line" : 598,
      "char" : 9,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZC5types9universal16objectidentifier16ObjectIdentifier",
      "originalType" : "const @property @system OID()",
      "endline" : 702,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element.objectIdentifier"
      ],
      "out" : {
       "name" : "__ensure",
       "kind" : "function",
       "line" : 600,
       "char" : 5,
       "deco" : "FKxC5types9universal16objectidentifier16ObjectIdentifierZv",
       "originalType" : "@system void(ref const ObjectIdentifier value)",
       "parameters" : [
        {
         "name" : "value",
         "deco" : "xC5types9universal16objectidentifier16ObjectIdentifier",
         "storageClass" : [
          "ref"
         ]
        }
       ],
       "endline" : 600,
       "endchar" : 5
      }
     },
     {
      "name" : "objectIdentifier",
      "kind" : "function",
      "comment" : "        Encodes an OBJECT IDENTIFIER.\n        See source/types/universal/objectidentifier.d for information about\n        the ObjectIdentifier class (aliased as \"OID\").\n\n        The encoded OBJECT IDENTIFIER's first byte contains the first number\n        of the OID multiplied by 40 and added to the second number of the OID.\n        The subsequent bytes have all the remaining number encoded in base-128\n        on the least significant 7 bits of each byte. For these bytes, the most\n        significant bit is set if the next byte continues the encoding of the\n        current OID number. In other words, the bytes encoding each number\n        always end with a byte whose most significant bit is cleared.\n\n        Standards:\n            $(LINK2 http://www.itu.int/rec/T-REC-X.660-201107-I/en, X.660)\n",
      "line" : 721,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxC5types9universal16objectidentifier16ObjectIdentifierZv",
      "originalType" : "@property @system void(in OID value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xC5types9universal16objectidentifier16ObjectIdentifier"
       }
      ],
      "endline" : 764,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element.objectIdentifier"
      ],
      "in" : {
       "name" : "__require",
       "kind" : "function",
       "line" : 723,
       "char" : 5,
       "type" : "@system void()",
       "endline" : 723,
       "endchar" : 5
      },
      "out" : {
       "name" : "__ensure",
       "kind" : "function",
       "line" : 732,
       "char" : 5,
       "deco" : "FNaNbNiZv",
       "originalType" : "@system void()",
       "endline" : 732,
       "endchar" : 5
      }
     },
     {
      "name" : "__unittest___source_codecs_der_d_767_0",
      "kind" : "function",
      "line" : 767,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 786,
      "endchar" : 5
     },
     {
      "name" : "__unittest___source_codecs_der_d_787_0",
      "kind" : "function",
      "line" : 787,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 838,
      "endchar" : 5
     },
     {
      "name" : "objectDescriptor",
      "kind" : "function",
      "comment" : "        Decodes an ObjectDescriptor, which is a string consisting of only\n        graphical characters. In fact, ObjectDescriptor is actually implicitly\n        just a GraphicString! The formal specification for an ObjectDescriptor\n        is:\n\n        $(I ObjectDescriptor ::= [UNIVERSAL 7] IMPLICIT GraphicString)\n\n        GraphicString is just 0x20 to 0x7E, therefore ObjectDescriptor is just\n        0x20 to 0x7E.\n\n        Citations:\n            Dubuisson, Olivier. “Character String Types.” ASN.1:\n                Communication between Heterogeneous Systems, Morgan\n                Kaufmann, 2001, pp. 175-178.\n            $(LINK2 https://en.wikipedia.org/wiki/ISO/IEC_2022,\n                The Wikipedia Page on ISO 2022)\n            $(LINK2 https://www.iso.org/standard/22747.html, ISO 2022)\n\n        Returns: a string.\n        Throws:\n            ASN1ValueInvalidException = if the encoded value contains any bytes\n                outside of 0x20 to 0x7E.\n",
      "line" : 839,
      "char" : 12,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZAya",
      "endline" : 857,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element.objectDescriptor"
      ]
     },
     {
      "name" : "objectDescriptor",
      "kind" : "function",
      "comment" : "        Encodes an ObjectDescriptor, which is a string consisting of only\n        graphical characters. In fact, ObjectDescriptor is actually implicitly\n        just a GraphicString! The formal specification for an ObjectDescriptor\n        is:\n\n        $(I ObjectDescriptor ::= [UNIVERSAL 7] IMPLICIT GraphicString)\n\n        GraphicString is just 0x20 to 0x7E, therefore ObjectDescriptor is just\n        0x20 to 0x7E.\n\n        Citations:\n            Dubuisson, Olivier. “Character String Types.” ASN.1:\n                Communication between Heterogeneous Systems, Morgan\n                Kaufmann, 2001, pp. 175-178.\n            $(LINK2 https://en.wikipedia.org/wiki/ISO/IEC_2022,\n                The Wikipedia Page on ISO 2022)\n            $(LINK2 https://www.iso.org/standard/22747.html, ISO 2022)\n\n        Throws:\n            ASN1ValueInvalidException = if the string value contains any\n                character outside of 0x20 to 0x7E, which means any control\n                characters or DELETE.\n",
      "line" : 884,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxAyaZv",
      "originalType" : "@property @system void(in string value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAya"
       }
      ],
      "endline" : 902,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element.objectDescriptor"
      ]
     },
     {
      "name" : "external",
      "kind" : "function",
      "comment" : "        Decodes an EXTERNAL, which is a constructed data type, defined in\n        the $(LINK2 https://www.itu.int,\n            International Telecommunications Union)'s\n        $(LINK2 https://www.itu.int/rec/T-REC-X.680/en, X.680).\n\n        According to the\n        $(LINK2 http://www.itu.int/en/pages/default.aspx,\n            International Telecommunications Union)'s\n        $(LINK2 https://www.itu.int/rec/T-REC-X.680/en,\n            X.680 - Abstract Syntax Notation One (ASN.1)),\n        the abstract definition for an EXTERNAL, after removing the comments in the\n        specification, is as follows:\n\n        $(I\n            EXTERNAL ::= [UNIVERSAL 8] SEQUENCE {\n                identification CHOICE {\n                    syntaxes SEQUENCE {\n                        abstract OBJECT IDENTIFIER,\n                        transfer OBJECT IDENTIFIER },\n                    syntax OBJECT IDENTIFIER,\n                    presentation-context-id INTEGER,\n                    context-negotiation SEQUENCE {\n                        presentation-context-id INTEGER,\n                        transfer-syntax OBJECT IDENTIFIER },\n                    transfer-syntax OBJECT IDENTIFIER,\n                    fixed NULL },\n                data-value-descriptor ObjectDescriptor OPTIONAL,\n                data-value OCTET STRING }\n                    ( WITH COMPONENTS {\n                        ... ,\n                        identification ( WITH COMPONENTS {\n                            ... ,\n                            syntaxes ABSENT,\n                            transfer-syntax ABSENT,\n                            fixed ABSENT } ) } )\n        )\n\n        Note that the abstract syntax resembles that of EMBEDDED PDV and\n        CharacterString, except with a WITH COMPONENTS constraint that removes some\n        of our choices of identification.\n        As can be seen on page 303 of Olivier Dubuisson's\n        $(I $(LINK2 http://www.oss.com/asn1/resources/books-whitepapers-pubs/dubuisson-asn1-book.PDF,\n            ASN.1: Communication Between Heterogeneous Systems)),\n        after applying the WITH COMPONENTS constraint, our reduced syntax becomes:\n\n        $(I\n            EXTERNAL ::= [UNIVERSAL 8] IMPLICIT SEQUENCE {\n                identification CHOICE {\n                    syntax OBJECT IDENTIFIER,\n                    presentation-context-id INTEGER,\n                    context-negotiation SEQUENCE {\n                        presentation-context-id INTEGER,\n                        transfer-syntax OBJECT IDENTIFIER } },\n                data-value-descriptor ObjectDescriptor OPTIONAL,\n                data-value OCTET STRING }\n        )\n\n        But, according to the\n        $(LINK2 http://www.itu.int/en/pages/default.aspx,\n        International Telecommunications Union)'s\n        $(LINK2 http://www.itu.int/rec/T-REC-X.690/en, X.690 - ASN.1 encoding rules),\n        section 8.18, when encoded using Basic Encoding Rules (BER), is encoded as\n        follows, for compatibility reasons:\n\n        $(I\n            EXTERNAL ::= [UNIVERSAL 8] IMPLICIT SEQUENCE {\n                direct-reference  OBJECT IDENTIFIER OPTIONAL,\n                indirect-reference  INTEGER OPTIONAL,\n                data-value-descriptor  ObjectDescriptor  OPTIONAL,\n                encoding  CHOICE {\n                    single-ASN1-type  [0] ANY,\n                    octet-aligned     [1] IMPLICIT OCTET STRING,\n                    arbitrary         [2] IMPLICIT BIT STRING } }\n        )\n\n        The definition above is the pre-1994 definition of EXTERNAL. The syntax\n        field of the post-1994 definition maps to the direct-reference field of\n        the pre-1994 definition. The presentation-context-id field of the post-1994\n        definition maps to the indirect-reference field of the pre-1994 definition.\n        If context-negotiation is used, per the abstract syntax, then the\n        presentation-context-id field of the context-negotiation SEQUENCE in the\n        post-1994 definition maps to the indirect-reference field of the pre-1994\n        definition, and the transfer-syntax field of the context-negotiation\n        SEQUENCE maps to the direct-reference field of the pre-1994 definition.\n\n        The following additional constraints are applied to the abstract syntax\n        when using Canonical Encoding Rules (CER) or Distinguished Encoding Rules (DER),\n        which are also defined in the\n        $(LINK2 http://www.itu.int/en/pages/default.aspx,\n        International Telecommunications Union)'s\n        $(LINK2 http://www.itu.int/rec/T-REC-X.690/en, X.690 - ASN.1 encoding rules):\n\n        $(I\n            EXTERNAL ( WITH COMPONENTS {\n                ... ,\n                identification ( WITH COMPONENTS {\n                    ... ,\n                    presentation-context-id ABSENT,\n                    context-negotiation ABSENT } ) } )\n        )\n\n        The stated purpose of the constraints shown above is to restrict the use of\n        the presentation-context-id, either by itself or within the\n        context-negotiation, which makes the following the effective abstract\n        syntax of EXTERNAL when using Canonical Encoding Rules (CER) or\n        Distinguished Encoding Rules (DER):\n\n        $(I\n            EXTERNAL ::= [UNIVERSAL 8] SEQUENCE {\n                identification CHOICE {\n                    syntaxes SEQUENCE {\n                        abstract OBJECT IDENTIFIER,\n                        transfer OBJECT IDENTIFIER },\n                    syntax OBJECT IDENTIFIER,\n                    presentation-context-id INTEGER,\n                    context-negotiation SEQUENCE {\n                        presentation-context-id INTEGER,\n                        transfer-syntax OBJECT IDENTIFIER },\n                    transfer-syntax OBJECT IDENTIFIER,\n                    fixed NULL },\n                data-value-descriptor ObjectDescriptor OPTIONAL,\n                data-value OCTET STRING }\n                    ( WITH COMPONENTS {\n                        ... ,\n                        identification ( WITH COMPONENTS {\n                            ... ,\n                            syntaxes ABSENT,\n                            presentation-context-id ABSENT,\n                            context-negotiation ABSENT,\n                            transfer-syntax ABSENT,\n                            fixed ABSENT } ) } )\n        )\n\n        With the constraints applied, the abstract syntax for EXTERNALs encoded\n        using Canonical Encoding Rules (CER) or Distinguished Encoding Rules (DER) becomes:\n\n        $(I\n            EXTERNAL ::= [UNIVERSAL 8] SEQUENCE {\n                identification CHOICE {\n                    syntax OBJECT IDENTIFIER },\n                data-value-descriptor ObjectDescriptor OPTIONAL,\n                data-value OCTET STRING }\n        )\n\n        Upon removing the CHOICE tag (since you have no choice but to use syntax\n        at this point), the encoding definition when using\n        Canonical Encoding Rules (CER) or Distinguished Encoding Rules (DER):\n\n        $(I\n            EXTERNAL ::= [UNIVERSAL 8] SEQUENCE {\n                syntax OBJECT IDENTIFIER,\n                data-value-descriptor ObjectDescriptor OPTIONAL,\n                data-value OCTET STRING }\n        )\n\n        Which, using the pre-1994 definition, becomes:\n\n        $(I\n            EXTERNAL ::= [UNIVERSAL 8] IMPLICIT SEQUENCE {\n                direct-reference  OBJECT IDENTIFIER,\n                data-value-descriptor  ObjectDescriptor  OPTIONAL,\n                encoding  CHOICE {\n                    single-ASN1-type  [0] ANY,\n                    octet-aligned     [1] IMPLICIT OCTET STRING,\n                    arbitrary         [2] IMPLICIT BIT STRING } }\n        )\n\n        For all encoding rules defined in the\n        $(LINK2 http://www.itu.int/en/pages/default.aspx,\n        International Telecommunications Union)'s\n        $(LINK2 http://www.itu.int/rec/T-REC-X.690/en, X.690 - ASN.1 encoding rules)\n        (meaning Basic Encoding Rules (BER), Canonical Encoding Rules (CER), and\n        Distinguished Encoding Rules (DER)), EXPLICIT tagging must be used when encoding\n        the EXTERNAL type. Unlike the other Context-Switching Types, automatic\n        tagging is NOT used when encoding with Basic Encoding Rules (BER),\n        Canonical Encoding Rules (CER), or Distinguished Encoding Rules (DER).\n\n        Returns: an External, defined in types.universal.external.\n        Throws:\n            ASN1SizeException = if encoded EmbeddedPDV has too few or too many\n                elements, or if syntaxes or context-negotiation element has\n                too few or too many elements.\n            ASN1ValueTooBigException = if encoded INTEGER is too large to decode.\n            ASN1ValueInvalidException = if encoded ObjectDescriptor contains\n                invalid characters.\n            ASN1InvalidIndexException = if encoded value selects a choice for\n                identification or uses an unspecified index for an element in\n                syntaxes or context-negotiation, or if an unspecified element\n                of EMBEDDED PDV itself is referenced by an out-of-range\n                context-specific index. (See $(D_INLINECODE ASN1InvalidIndexException).)\n",
      "line" : 1097,
      "char" : 14,
      "storageClass" : [
       "deprecated",
       "override"
      ],
      "deco" : "xFNdZS5types9universal8external8External",
      "endline" : 1237,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element.external"
      ]
     },
     {
      "name" : "external",
      "kind" : "function",
      "comment" : "        Encodes an EXTERNAL, which is a constructed data type, defined in\n        the $(LINK2 https://www.itu.int,\n            International Telecommunications Union)'s\n        $(LINK2 https://www.itu.int/rec/T-REC-X.680/en, X.680).\n\n        The specification defines EXTERNAL as:\n\n        $(I\n            EXTERNAL := [UNIVERSAL 8] IMPLICIT SEQUENCE {\n                identification CHOICE {\n                    syntax OBJECT IDENTIFIER,\n                    presentation-context-id INTEGER,\n                    context-negotiation SEQUENCE {\n                        presentation-context-id INTEGER,\n                        transfer-syntax OBJECT IDENTIFIER } },\n                data-value-descriptor ObjectDescriptor OPTIONAL,\n                data-value OCTET STRING }\n        )\n\n        This assumes AUTOMATIC TAGS, so all of the identification choices\n        will be context-specific and numbered from 0 to 2.\n\n        Throws:\n            ASN1ValueTooBigException = if encoded INTEGER is too large to decode\n            ASN1ValueInvalidException = if encoded ObjectDescriptor contains\n                invalid characters.\n",
      "line" : 1268,
      "char" : 10,
      "storageClass" : [
       "deprecated",
       "override"
      ],
      "deco" : "FNdxS5types9universal8external8ExternalZv",
      "originalType" : "@property @system void(in External value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xS5types9universal8external8External"
       }
      ],
      "endline" : 1307,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element.external"
      ],
      "out" : {
       "name" : "__ensure",
       "kind" : "function",
       "line" : 1270,
       "char" : 5,
       "deco" : "FNaNbNiZv",
       "originalType" : "@system void()",
       "endline" : 1270,
       "endchar" : 5
      }
     },
     {
      "name" : "__unittest___source_codecs_der_d_1315_0",
      "kind" : "function",
      "line" : 1315,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 1330,
      "endchar" : 5
     },
     {
      "name" : "__unittest___source_codecs_der_d_1331_0",
      "kind" : "function",
      "line" : 1331,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 1359,
      "endchar" : 5
     },
     {
      "name" : "__unittest___source_codecs_der_d_1360_0",
      "kind" : "function",
      "line" : 1360,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 1456,
      "endchar" : 5
     },
     {
      "kind" : "template",
      "comment" : "        Decodes a float or double. This can never decode directly to a\n        real type, because of the way it works.\n\n        For the DER-encoded REAL, a value of 0x40 means \"positive infinity,\"\n        a value of 0x41 means \"negative infinity.\" An empty value means\n        exactly zero. A value whose first byte starts with two cleared bits\n        encodes the real as a string of characters, where the latter nybble\n        takes on values of 0x1, 0x2, or 0x3 to indicate that the string\n        representation conforms to\n        $(LINK2 https://www.iso.org/standard/12285.html, ISO 6093)\n        Numeric Representation 1, 2, or 3 respectively.\n\n        If the first bit is set, then the first byte is an \"information block\"\n        that describes the binary encoding of the REAL on the subsequent bytes.\n        If bit 6 is set, the value is negative; if clear, the value is\n        positive. Bits 4 and 5 determine the base, with a value of 0 indicating\n        a base of 2, a value of 1 indicating a base of 8, and a value of 2\n        indicating a base of 16. Bits 2 and 3 indicates that the value should\n        be scaled by 1, 2, 4, or 8 for values of 1, 2, 3, or 4 respectively.\n        Bits 0 and 1 determine how the exponent is encoded, with 0 indicating\n        that the exponent is encoded as a signed byte on the second byte of\n        the value, with 1 indicating that the exponent is encoded as a signed\n        short on the subsequent two bytes, with 2 indicating that the exponent\n        is encoded as a three-byte signed integer on the subsequent three\n        bytes, and with 4 indicating that the subsequent byte encodes the\n        unsigned length of the exponent on the following bytes. The remaining\n        bytes encode an unsigned integer, N, such that mantissa is equal to\n        sign * N * 2^scale.\n\n        Note that this method assumes that your machine uses IEEE 754 floating\n        point format.\n\n        If you attempt to decode a REAL that is too big to fit into the selected\n        floating point type, the value of the real will quietly set to zero. This\n        cannot happen if the transmitted value is in base-2, but it can happen if\n        the transmitted value is in base-8 or base-16.\n\n        Throws:\n            ConvException = if character-encoding cannot be converted to\n                the selected floating-point type, T.\n            ConvOverflowException = if the character-encoding encodes a\n                number that is too big for the selected floating-point\n                type to express.\n            ASN1ValueTooSmallException = if the binary-encoding contains fewer\n                bytes than the information byte purports.\n            ASN1ValueTooBigException = if the binary-encoded mantissa is too\n                big to be expressed by an unsigned long integer.\n            ASN1ValueInvalidException = if both bits indicating the base in the\n                information byte of a binary-encoded REAL's information byte\n                are set, which would indicate an invalid base.\n\n        Citations:\n            Dubuisson, Olivier. “Distinguished Encoding Rules (DER).” ASN.1:\n            Communication between Heterogeneous Systems, Morgan Kaufmann,\n            2001, pp. 400–402.\n",
      "line" : 1457,
      "char" : 7,
      "name" : "realNumber",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "constraint" : "isFloatingPoint!T",
      "members" : [
       {
        "name" : "realNumber",
        "kind" : "function",
        "line" : 1457,
        "char" : 7,
        "type" : "const @property @system T()",
        "endline" : 1752,
        "endchar" : 5
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "        Encodes a float or double. This can never decode directly to a\n        real type, because of the way it works.\n\n        This is admittedly a pretty slow function, so I would recommend\n        avoiding it, if possible. Also, because it is so complex, it is\n        highly likely to have bugs, so for that reason as well, I highly\n        recommand against encoding or decoding REALs if you do not have\n        to; try using INTEGER instead.\n\n        For the DER-encoded REAL, a value of 0x40 means \"positive infinity,\"\n        a value of 0x41 means \"negative infinity.\" An empty value means\n        exactly zero. A value whose first byte starts with two cleared bits\n        encodes the real as a string of characters, where the latter nybble\n        takes on values of 0x1, 0x2, or 0x3 to indicate that the string\n        representation conforms to\n        $(LINK2 , ISO 6093) Numeric Representation 1, 2, or 3 respectively.\n\n        If the first bit is set, then the first byte is an \"information block\"\n        that describes the binary encoding of the REAL on the subsequent bytes.\n        If bit 6 is set, the value is negative; if clear, the value is\n        positive. Bits 4 and 5 determine the base, with a value of 0 indicating\n        a base of 2, a value of 1 indicating a base of 8, and a value of 2\n        indicating a base of 16. Bits 2 and 3 indicates that the value should\n        be scaled by 1, 2, 4, or 8 for values of 1, 2, 3, or 4 respectively.\n        Bits 0 and 1 determine how the exponent is encoded, with 0 indicating\n        that the exponent is encoded as a signed byte on the second byte of\n        the value, with 1 indicating that the exponent is encoded as a signed\n        short on the subsequent two bytes, with 2 indicating that the exponent\n        is encoded as a three-byte signed integer on the subsequent three\n        bytes, and with 4 indicating that the subsequent byte encodes the\n        unsigned length of the exponent on the following bytes. The remaining\n        bytes encode an unsigned integer, N, such that mantissa is equal to\n        sign * N * 2^scale.\n\n        Note that this method assumes that your machine uses IEEE 754 floating\n        point format.\n\n        Throws:\n            ASN1ValueInvalidException = if an attempt to encode NaN is made.\n            ASN1ValueTooSmallException = if an attempt to encode would result\n                in an arithmetic underflow of a signed short.\n            ASN1ValueTooBigException = if an attempt to encode would result\n                in an arithmetic overflow of a signed short.\n\n        Citations:\n            Dubuisson, Olivier. “Distinguished Encoding Rules (DER).” ASN.1:\n            Communication between Heterogeneous Systems, Morgan Kaufmann,\n            2001, pp. 400–402.\n",
      "line" : 1805,
      "char" : 10,
      "name" : "realNumber",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "constraint" : "isFloatingPoint!T",
      "members" : [
       {
        "name" : "realNumber",
        "kind" : "function",
        "line" : 1805,
        "char" : 10,
        "type" : "@property @system void(in T value)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "T",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 1975,
        "endchar" : 5
       }
      ]
     },
     {
      "name" : "__unittest___source_codecs_der_d_1979_0",
      "kind" : "function",
      "line" : 1979,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 2022,
      "endchar" : 5
     },
     {
      "name" : "__unittest___source_codecs_der_d_2023_0",
      "kind" : "function",
      "line" : 2023,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 2090,
      "endchar" : 5
     },
     {
      "kind" : "template",
      "comment" : "        Decodes an integer from an ENUMERATED type. In DER, an ENUMERATED\n        type is encoded the exact same way that an INTEGER is.\n\n        Returns: any chosen signed integral type\n        Throws:\n            ASN1ValueTooBigException = if the value is too big to decode\n                to a signed integral type.\n",
      "line" : 2091,
      "char" : 7,
      "name" : "enumerated",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "constraint" : "isIntegral!T && isSigned!T",
      "members" : [
       {
        "name" : "enumerated",
        "kind" : "function",
        "line" : 2091,
        "char" : 7,
        "type" : "const @property @system T()",
        "endline" : 2163,
        "endchar" : 5
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "        Encodes an ENUMERATED type from an integer. In DER, an ENUMERATED\n        type is encoded the exact same way that an INTEGER is.\n",
      "line" : 2170,
      "char" : 10,
      "name" : "enumerated",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "enumerated",
        "kind" : "function",
        "line" : 2170,
        "char" : 10,
        "type" : "nothrow @property @system void(in T value)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "T",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 2227,
        "endchar" : 5
       }
      ]
     },
     {
      "name" : "__unittest___source_codecs_der_d_2231_0",
      "kind" : "function",
      "line" : 2231,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 2255,
      "endchar" : 5
     },
     {
      "name" : "__unittest___source_codecs_der_d_2256_0",
      "kind" : "function",
      "line" : 2256,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 2337,
      "endchar" : 5
     },
     {
      "name" : "embeddedPresentationDataValue",
      "kind" : "function",
      "comment" : "\n        Decodes an EMBEDDED PDV, which is a constructed data type, defined in\n            the $(LINK2 https://www.itu.int,\n                International Telecommunications Union)'s\n            $(LINK2 https://www.itu.int/rec/T-REC-X.680/en, X.680).\n\n        The specification defines EMBEDDED PDV as:\n\n        $(I\n            EmbeddedPDV ::= [UNIVERSAL 11] IMPLICIT SEQUENCE {\n                identification CHOICE {\n                    syntaxes SEQUENCE {\n                        abstract OBJECT IDENTIFIER,\n                        transfer OBJECT IDENTIFIER },\n                    syntax OBJECT IDENTIFIER,\n                    presentation-context-id INTEGER,\n                    context-negotiation SEQUENCE {\n                        presentation-context-id INTEGER,\n                        transfer-syntax OBJECT IDENTIFIER },\n                    transfer-syntax OBJECT IDENTIFIER,\n                    fixed NULL },\n                data-value-descriptor ObjectDescriptor OPTIONAL,\n                data-value OCTET STRING }\n            (WITH COMPONENTS { ... , data-value-descriptor ABSENT })\n        )\n\n        This assumes AUTOMATIC TAGS, so all of the identification choices\n        will be context-specific and numbered from 0 to 5.\n\n        In Distinguished Encoding Rules, the identification CHOICE cannot be\n        presentation-context-id, nor context-negotiation. Also, the elements\n        must appear in the exact order of the specification. With these\n        constraints in mind, the specification effectively becomes:\n\n        $(I\n            EmbeddedPDV ::= [UNIVERSAL 11] IMPLICIT SEQUENCE {\n                identification [0] CHOICE {\n                    syntaxes [0] SEQUENCE {\n                        abstract [0] OBJECT IDENTIFIER,\n                        transfer [1] OBJECT IDENTIFIER },\n                    syntax [1] OBJECT IDENTIFIER,\n                    transfer-syntax [4] OBJECT IDENTIFIER,\n                    fixed [5] NULL },\n                data-value [2] OCTET STRING }\n        )\n\n        Throws:\n            ASN1SizeException = if encoded EmbeddedPDV has too few or too many\n                elements, or if syntaxes or context-negotiation element has\n                too few or too many elements.\n            ASN1ValueTooBigException = if encoded INTEGER is too large to decode.\n            ASN1ValueInvalidException = if encoded ObjectDescriptor contains\n                invalid characters.\n            ASN1InvalidIndexException = if encoded value selects a choice for\n                identification or uses an unspecified index for an element in\n                syntaxes or context-negotiation, or if an unspecified element\n                of EMBEDDED PDV itself is referenced by an out-of-range\n                context-specific index. (See $(D_INLINECODE ASN1InvalidIndexException).)\n",
      "line" : 2338,
      "char" : 17,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZS5types9universal11embeddedpdv29EmbeddedPresentationDataValue",
      "originalType" : "const @property @system EmbeddedPDV()",
      "endline" : 2481,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element.embeddedPresentationDataValue"
      ]
     },
     {
      "name" : "embeddedPresentationDataValue",
      "kind" : "function",
      "comment" : "        Encodes an EMBEDDED PDV, which is a constructed data type, defined in\n            the $(LINK2 https://www.itu.int,\n                International Telecommunications Union)'s\n            $(LINK2 https://www.itu.int/rec/T-REC-X.680/en, X.680).\n\n        The specification defines EMBEDDED PDV as:\n\n        $(I\n            EmbeddedPDV ::= [UNIVERSAL 11] IMPLICIT SEQUENCE {\n                identification CHOICE {\n                    syntaxes SEQUENCE {\n                        abstract OBJECT IDENTIFIER,\n                        transfer OBJECT IDENTIFIER },\n                    syntax OBJECT IDENTIFIER,\n                    presentation-context-id INTEGER,\n                    context-negotiation SEQUENCE {\n                        presentation-context-id INTEGER,\n                        transfer-syntax OBJECT IDENTIFIER },\n                    transfer-syntax OBJECT IDENTIFIER,\n                    fixed NULL },\n                data-value-descriptor ObjectDescriptor OPTIONAL,\n                data-value OCTET STRING }\n            (WITH COMPONENTS { ... , data-value-descriptor ABSENT })\n        )\n\n        This assumes AUTOMATIC TAGS, so all of the identification choices\n        will be context-specific and numbered from 0 to 5.\n\n        In Distinguished Encoding Rules, the identification CHOICE cannot be\n        presentation-context-id, nor context-negotiation. Also, the elements\n        must appear in the exact order of the specification. With these\n        constraints in mind, the specification effectively becomes:\n\n        $(I\n            EmbeddedPDV ::= [UNIVERSAL 11] IMPLICIT SEQUENCE {\n                identification [0] CHOICE {\n                    syntaxes [0] SEQUENCE {\n                        abstract [0] OBJECT IDENTIFIER,\n                        transfer [1] OBJECT IDENTIFIER },\n                    syntax [1] OBJECT IDENTIFIER,\n                    transfer-syntax [4] OBJECT IDENTIFIER,\n                    fixed [5] NULL },\n                data-value [2] OCTET STRING }\n        )\n\n        If the supplied identification for the EmbeddedPDV is a\n        presentation-context-id or a context-negotiation, no exception will be\n        thrown; the identification will be set to fixed silently.\n\n        This assumes AUTOMATIC TAGS, so all of the identification choices\n        will be context-specific and numbered from 0 to 5.\n\n        Throws:\n            ASN1ValueInvalidException = if encoded ObjectDescriptor contains\n                invalid characters.\n",
      "line" : 2541,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxS5types9universal11embeddedpdv29EmbeddedPresentationDataValueZv",
      "originalType" : "@property @system void(in EmbeddedPDV value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xS5types9universal11embeddedpdv29EmbeddedPresentationDataValue"
       }
      ],
      "endline" : 2594,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element.embeddedPresentationDataValue"
      ],
      "out" : {
       "name" : "__ensure",
       "kind" : "function",
       "line" : 2543,
       "char" : 5,
       "deco" : "FNaNbNiZv",
       "originalType" : "@system void()",
       "endline" : 2543,
       "endchar" : 5
      }
     },
     {
      "name" : "__unittest___source_codecs_der_d_2605_0",
      "kind" : "function",
      "line" : 2605,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 2630,
      "endchar" : 5
     },
     {
      "name" : "__unittest___source_codecs_der_d_2631_0",
      "kind" : "function",
      "line" : 2631,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 2652,
      "endchar" : 5
     },
     {
      "name" : "__unittest___source_codecs_der_d_2653_0",
      "kind" : "function",
      "line" : 2653,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 2695,
      "endchar" : 5
     },
     {
      "name" : "unicodeTransformationFormat8String",
      "kind" : "function",
      "comment" : "        Decodes the value to UTF-8 characters.\n\n        Throws:\n            UTF8Exception if it does not decode correctly.\n",
      "line" : 2696,
      "char" : 12,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZAya",
      "endline" : 2699,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element.unicodeTransformationFormat8String"
      ]
     },
     {
      "name" : "unicodeTransformationFormat8String",
      "kind" : "function",
      "comment" : "        Encodes a UTF-8 string to bytes. No checks are performed.\n",
      "line" : 2705,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNbNdxAyaZv",
      "originalType" : "nothrow @property @system void(in string value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAya"
       }
      ],
      "endline" : 2708,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element.unicodeTransformationFormat8String"
      ]
     },
     {
      "name" : "relativeObjectIdentifier",
      "kind" : "function",
      "comment" : "        Decodes a RELATIVE OBJECT IDENTIFIER.\n        See source/types/universal/objectidentifier.d for information about\n        the ObjectIdentifier class (aliased as \"OID\").\n\n        The RELATIVE OBJECT IDENTIFIER's numbers are encoded in base-128\n        on the least significant 7 bits of each byte. For these bytes, the most\n        significant bit is set if the next byte continues the encoding of the\n        current OID number. In other words, the bytes encoding each number\n        always end with a byte whose most significant bit is cleared.\n\n        Standards:\n            $(LINK2 http://www.itu.int/rec/T-REC-X.660-201107-I/en, X.660)\n",
      "line" : 2725,
      "char" : 15,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZAS5types7oidtype20ObjectIdentifierNode",
      "originalType" : "const @property @system OIDNode[]()",
      "endline" : 2797,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element.relativeObjectIdentifier"
      ]
     },
     {
      "name" : "relativeObjectIdentifier",
      "kind" : "function",
      "comment" : "        Encodes a RELATIVE OBJECT IDENTIFIER.\n        See source/types/universal/objectidentifier.d for information about\n        the ObjectIdentifier class (aliased as \"OID\").\n\n        The RELATIVE OBJECT IDENTIFIER's numbers are encoded in base-128\n        on the least significant 7 bits of each byte. For these bytes, the most\n        significant bit is set if the next byte continues the encoding of the\n        current OID number. In other words, the bytes encoding each number\n        always end with a byte whose most significant bit is cleared.\n\n        Standards:\n            $(LINK2 http://www.itu.int/rec/T-REC-X.660-201107-I/en, X.660)\n",
      "line" : 2814,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNbNdxAS5types7oidtype20ObjectIdentifierNodeZv",
      "originalType" : "nothrow @property @system void(in OIDNode[] value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAS5types7oidtype20ObjectIdentifierNode"
       }
      ],
      "endline" : 2839,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element.relativeObjectIdentifier"
      ]
     },
     {
      "name" : "__unittest___source_codecs_der_d_2842_0",
      "kind" : "function",
      "line" : 2842,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 2861,
      "endchar" : 5
     },
     {
      "name" : "__unittest___source_codecs_der_d_2862_0",
      "kind" : "function",
      "line" : 2862,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 2895,
      "endchar" : 5
     },
     {
      "name" : "sequence",
      "kind" : "function",
      "comment" : "        Decodes a sequence of DERElements.\n\n        Returns: an array of DERElements.\n        Throws:\n            ASN1ValueSizeException = if long definite-length is too big to be\n                decoded to an unsigned integral type.\n            ASN1ValueTooSmallException = if there are fewer value bytes than\n                indicated by the length tag.\n",
      "line" : 2896,
      "char" : 18,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZAC6codecs3der33DistinguishedEncodingRulesElement",
      "originalType" : "const @property @system DERElement[]()",
      "endline" : 2903,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element.sequence"
      ]
     },
     {
      "name" : "sequence",
      "kind" : "function",
      "comment" : "        Encodes a sequence of DERElements.\n",
      "line" : 2909,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxAC6codecs3der33DistinguishedEncodingRulesElementZv",
      "originalType" : "@property @system void(in DERElement[] value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAC6codecs3der33DistinguishedEncodingRulesElement"
       }
      ],
      "endline" : 2917,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element.sequence"
      ]
     },
     {
      "name" : "set",
      "kind" : "function",
      "comment" : "        Decodes a set of DERElements.\n\n        Returns: an array of DERElements.\n        Throws:\n            ASN1ValueSizeException = if long definite-length is too big to be\n                decoded to an unsigned integral type.\n            ASN1ValueTooSmallException = if there are fewer value bytes than\n                indicated by the length tag.\n",
      "line" : 2930,
      "char" : 18,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZAC6codecs3der33DistinguishedEncodingRulesElement",
      "originalType" : "const @property @system DERElement[]()",
      "endline" : 2937,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element.set"
      ]
     },
     {
      "name" : "set",
      "kind" : "function",
      "comment" : "        Encodes a set of DERElements.\n",
      "line" : 2943,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxAC6codecs3der33DistinguishedEncodingRulesElementZv",
      "originalType" : "@property @system void(in DERElement[] value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAC6codecs3der33DistinguishedEncodingRulesElement"
       }
      ],
      "endline" : 2951,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element.set"
      ]
     },
     {
      "name" : "numericString",
      "kind" : "function",
      "comment" : "        Decodes a string, where the characters of the string are limited to\n        0 - 9 and space.\n\n        Returns: a string.\n        Throws:\n            ASN1ValueInvalidException = if any character other than 0-9 or\n                space is encoded.\n",
      "line" : 2963,
      "char" : 12,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZAya",
      "endline" : 2978,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element.numericString"
      ]
     },
     {
      "name" : "numericString",
      "kind" : "function",
      "comment" : "        Encodes a string, where the characters of the string are limited to\n        0 - 9 and space.\n\n        Throws:\n            ASN1ValueInvalidException = if any character other than 0-9 or\n                space is supplied.\n",
      "line" : 2989,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxAyaZv",
      "originalType" : "@property @system void(in string value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAya"
       }
      ],
      "endline" : 3004,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element.numericString"
      ]
     },
     {
      "name" : "printableString",
      "kind" : "function",
      "comment" : "        Decodes a string that will only contain characters a-z, A-Z, 0-9,\n        space, apostrophe, parentheses, comma, minus, plus, period,\n        forward slash, colon, equals, and question mark.\n\n        Returns: a string.\n        Throws:\n            ASN1ValueInvalidException = if any character other than a-z, A-Z,\n                0-9, space, apostrophe, parentheses, comma, minus, plus,\n                period, forward slash, colon, equals, or question mark are\n                encoded.\n",
      "line" : 3019,
      "char" : 12,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZAya",
      "endline" : 3036,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element.printableString"
      ]
     },
     {
      "name" : "printableString",
      "kind" : "function",
      "comment" : "        Encodes a string that may only contain characters a-z, A-Z, 0-9,\n        space, apostrophe, parentheses, comma, minus, plus, period,\n        forward slash, colon, equals, and question mark.\n\n        Throws:\n            ASN1ValueInvalidException = if any character other than a-z, A-Z,\n                0-9, space, apostrophe, parentheses, comma, minus, plus,\n                period, forward slash, colon, equals, or question mark are\n                supplied.\n",
      "line" : 3050,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxAyaZv",
      "originalType" : "@property @system void(in string value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAya"
       }
      ],
      "endline" : 3066,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element.printableString"
      ]
     },
     {
      "name" : "teletexString",
      "kind" : "function",
      "comment" : "        Literally just returns the value bytes.\n\n        Returns: an unsigned byte array, where each byte is a T.61 character.\n",
      "line" : 3074,
      "char" : 13,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNbNdNfZAh",
      "endline" : 3078,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element.teletexString"
      ]
     },
     {
      "name" : "teletexString",
      "kind" : "function",
      "comment" : "        Literally just sets the value bytes.\n",
      "line" : 3084,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNbNdNfxAhZv",
      "originalType" : "nothrow @property @safe void(in ubyte[] value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAh"
       }
      ],
      "endline" : 3088,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element.teletexString"
      ]
     },
     {
      "name" : "videotexString",
      "kind" : "function",
      "comment" : "        Literally just returns the value bytes.\n\n        Returns: an unsigned byte array.\n",
      "line" : 3096,
      "char" : 13,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNbNdNfZAh",
      "endline" : 3100,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element.videotexString"
      ]
     },
     {
      "name" : "videotexString",
      "kind" : "function",
      "comment" : "        Literally just sets the value bytes.\n",
      "line" : 3106,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNbNdNfxAhZv",
      "originalType" : "nothrow @property @safe void(in ubyte[] value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAh"
       }
      ],
      "endline" : 3110,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element.videotexString"
      ]
     },
     {
      "name" : "internationalAlphabetNumber5String",
      "kind" : "function",
      "comment" : "        Decodes a string that only contains ASCII characters.\n\n        IA5String differs from ASCII ever so slightly: IA5 is international,\n        leaving 10 characters up to be locale-specific:\n\n        $(TABLE\n            $(TR $(TH Byte) $(TH ASCII Character))\n            $(TR $(TD 0x40) $(TD @))\n            $(TR $(TD 0x5B) $(TD [))\n            $(TR $(TD 0x5C) $(TD \\))\n            $(TR $(TD 0x5D) $(TD ]))\n            $(TR $(TD 0x5E) $(TD ^))\n            $(TR $(TD 0x60) $(TD `))\n            $(TR $(TD 0x7B) $(TD {))\n            $(TR $(TD 0x7C) $(TD /))\n            $(TR $(TD 0x7D) $(TD }))\n            $(TR $(TD 0x7E) $(TD ~))\n        )\n\n        Returns: a string.\n        Throws:\n            ASN1ValueInvalidException = if any enecoded character is not ASCII.\n",
      "line" : 3137,
      "char" : 12,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZAya",
      "endline" : 3153,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element.internationalAlphabetNumber5String"
      ]
     },
     {
      "name" : "internationalAlphabetNumber5String",
      "kind" : "function",
      "comment" : "        Encodes a string that may only contain ASCII characters.\n\n        IA5String differs from ASCII ever so slightly: IA5 is international,\n        leaving 10 characters up to be locale-specific:\n\n        $(TABLE\n            $(TR $(TH Byte) $(TH ASCII Character))\n            $(TR $(TD 0x40) $(TD @))\n            $(TR $(TD 0x5B) $(TD [))\n            $(TR $(TD 0x5C) $(TD \\))\n            $(TR $(TD 0x5D) $(TD ]))\n            $(TR $(TD 0x5E) $(TD ^))\n            $(TR $(TD 0x60) $(TD `))\n            $(TR $(TD 0x7B) $(TD {))\n            $(TR $(TD 0x7C) $(TD /))\n            $(TR $(TD 0x7D) $(TD }))\n            $(TR $(TD 0x7E) $(TD ~))\n        )\n\n        Throws:\n            ASN1ValueInvalidException = if any enecoded character is not ASCII.\n",
      "line" : 3179,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxAyaZv",
      "originalType" : "@property @system void(in string value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAya"
       }
      ],
      "endline" : 3193,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element.internationalAlphabetNumber5String"
      ]
     },
     {
      "name" : "coordinatedUniversalTime",
      "kind" : "function",
      "comment" : "        Decodes a DateTime.\n\n        The DER-encoded value is just the ASCII character representation of\n        the UTC-formatted timestamp.\n\n        An UTC Timestamp looks like:\n        $(UL\n            $(LI 9912312359Z)\n            $(LI 991231235959+0200)\n        )\n\n        If the first digit of the two-digit year is 7, 6, 5, 4, 3, 2, 1, or 0,\n        meaning that the date refers to the first 80 years of the century, this\n        assumes we are talking about the 21st century and prepend '20' when\n        creating the ISO Date String. Otherwise, it assumes we are talking\n        about the 20th century, and prepend '19' when creating the string.\n\n        See_Also:\n            $(LINK2 https://www.obj-sys.com/asn1tutorial/node15.html, UTCTime)\n\n        Throws:\n            DateTimeException = if string cannot be decoded to a DateTime\n",
      "line" : 3220,
      "char" : 14,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZS3std8datetime4date8DateTime",
      "endline" : 3244,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element.coordinatedUniversalTime"
      ]
     },
     {
      "name" : "coordinatedUniversalTime",
      "kind" : "function",
      "comment" : "        Encodes a DateTime.\n\n        The DER-encoded value is just the ASCII character representation of\n        the UTC-formatted timestamp.\n\n        An UTC Timestamp looks like:\n        $(UL\n            $(LI 9912312359Z)\n            $(LI 991231235959+0200)\n        )\n\n        See_Also:\n            $(LINK2 https://www.obj-sys.com/asn1tutorial/node15.html, UTCTime)\n",
      "line" : 3262,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxS3std8datetime4date8DateTimeZv",
      "originalType" : "@property @system void(in DateTime value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xS3std8datetime4date8DateTime"
       }
      ],
      "endline" : 3272,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element.coordinatedUniversalTime"
      ],
      "out" : {
       "name" : "__ensure",
       "kind" : "function",
       "line" : 3264,
       "char" : 5,
       "deco" : "FNaNbNiZv",
       "originalType" : "@system void()",
       "endline" : 3264,
       "endchar" : 5
      }
     },
     {
      "name" : "generalizedTime",
      "kind" : "function",
      "comment" : "        Decodes a DateTime.\n\n        The DER-encoded value is just the ASCII character representation of\n        the $(LINK2 https://www.iso.org/iso-8601-date-and-time-format.html,\n        ISO 8601)-formatted timestamp.\n\n        An ISO-8601 Timestamp looks like:\n        $(UL\n            $(LI 19851106210627.3)\n            $(LI 19851106210627.3Z)\n            $(LI 19851106210627.3-0500)\n        )\n\n        Throws:\n            DateTimeException = if string cannot be decoded to a DateTime\n",
      "line" : 3292,
      "char" : 14,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZS3std8datetime4date8DateTime",
      "endline" : 3316,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element.generalizedTime"
      ]
     },
     {
      "name" : "generalizedTime",
      "kind" : "function",
      "comment" : "        Encodes a DateTime.\n\n        The DER-encoded value is just the ASCII character representation of\n        the $(LINK2 https://www.iso.org/iso-8601-date-and-time-format.html,\n        ISO 8601)-formatted timestamp.\n\n        An ISO-8601 Timestamp looks like:\n        $(UL\n            $(LI 19851106210627.3)\n            $(LI 19851106210627.3Z)\n            $(LI 19851106210627.3-0500)\n        )\n",
      "line" : 3333,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxS3std8datetime4date8DateTimeZv",
      "originalType" : "@property @system void(in DateTime value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xS3std8datetime4date8DateTime"
       }
      ],
      "endline" : 3343,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element.generalizedTime"
      ],
      "out" : {
       "name" : "__ensure",
       "kind" : "function",
       "line" : 3335,
       "char" : 5,
       "deco" : "FNaNbNiZv",
       "originalType" : "@system void()",
       "endline" : 3335,
       "endchar" : 5
      }
     },
     {
      "name" : "graphicString",
      "kind" : "function",
      "comment" : "        Decodes an ASCII string that contains only characters between and\n        including 0x20 and 0x75.\n\n        Deprecated, according to page 182 of the Dubuisson book.\n\n        Citations:\n            Dubuisson, Olivier. “Character String Types.” ASN.1:\n                Communication between Heterogeneous Systems, Morgan\n                Kaufmann, 2001, pp. 175-178.\n            $(LINK2 https://en.wikipedia.org/wiki/ISO/IEC_2022,\n                The Wikipedia Page on ISO 2022)\n            $(LINK2 https://www.iso.org/standard/22747.html, ISO 2022)\n\n        Returns: a string.\n        Throws:\n            ASN1ValueInvalidException = if any non-graphical character\n                (including space) is encoded.\n",
      "line" : 3365,
      "char" : 12,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZAya",
      "endline" : 3382,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element.graphicString"
      ]
     },
     {
      "name" : "graphicString",
      "kind" : "function",
      "comment" : "        Encodes an ASCII string that may contain only characters between and\n        including 0x20 and 0x75.\n\n        Deprecated, according to page 182 of the Dubuisson book.\n\n        Citations:\n            Dubuisson, Olivier. “Character String Types.” ASN.1:\n                Communication between Heterogeneous Systems, Morgan\n                Kaufmann, 2001, pp. 175-178.\n            $(LINK2 https://en.wikipedia.org/wiki/ISO/IEC_2022,\n                The Wikipedia Page on ISO 2022)\n            $(LINK2 https://www.iso.org/standard/22747.html, ISO 2022)\n\n        Throws:\n            ASN1ValueInvalidException = if any non-graphical character\n                (including space) is supplied.\n",
      "line" : 3403,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxAyaZv",
      "originalType" : "@property @system void(in string value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAya"
       }
      ],
      "endline" : 3419,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element.graphicString"
      ]
     },
     {
      "name" : "visibleString",
      "kind" : "function",
      "comment" : "        Decodes a string that only contains characters between and including\n        0x20 and 0x7E. (Honestly, I don't know how this differs from\n        GraphicalString.)\n\n        Returns: a string.\n        Throws:\n            ASN1ValueInvalidException = if any non-graphical character\n                (including space) is encoded.\n",
      "line" : 3432,
      "char" : 12,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZAya",
      "endline" : 3449,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element.visibleString"
      ]
     },
     {
      "name" : "visibleString",
      "kind" : "function",
      "comment" : "        Encodes a string that only contains characters between and including\n        0x20 and 0x7E. (Honestly, I don't know how this differs from\n        GraphicalString.)\n\n        Throws:\n            ASN1ValueInvalidException = if any non-graphical character\n                (including space) is supplied.\n",
      "line" : 3461,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxAyaZv",
      "originalType" : "@property @system void(in string value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAya"
       }
      ],
      "endline" : 3477,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element.visibleString"
      ]
     },
     {
      "name" : "generalString",
      "kind" : "function",
      "comment" : "        Decodes a string containing only ASCII characters.\n\n        Deprecated, according to page 182 of the Dubuisson book.\n\n        Returns: a string.\n        Throws:\n            ASN1ValueInvalidException = if any enecoded character is not ASCII.\n\n        Citations:\n            Dubuisson, Olivier. “Distinguished Encoding Rules (DER).” ASN.1:\n            Communication between Heterogeneous Systems, Morgan Kaufmann,\n            2001, p. 182.\n",
      "line" : 3494,
      "char" : 12,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZAya",
      "endline" : 3510,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element.generalString"
      ]
     },
     {
      "name" : "generalString",
      "kind" : "function",
      "comment" : "        Encodes a string containing only ASCII characters.\n\n        Deprecated, according to page 182 of the Dubuisson book.\n\n        Throws:\n            ASN1ValueInvalidException = if any enecoded character is not ASCII.\n\n        Citations:\n            Dubuisson, Olivier. “Distinguished Encoding Rules (DER).” ASN.1:\n            Communication between Heterogeneous Systems, Morgan Kaufmann,\n            2001, p. 182.\n",
      "line" : 3526,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxAyaZv",
      "originalType" : "@property @system void(in string value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAya"
       }
      ],
      "endline" : 3540,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element.generalString"
      ]
     },
     {
      "name" : "universalString",
      "kind" : "function",
      "comment" : "        Decodes a dstring of UTF-32 characters.\n\n        Returns: a string of UTF-32 characters.\n        Throws:\n            ASN1ValueInvalidException = if the encoded bytes is not evenly\n                divisible by four.\n",
      "line" : 3551,
      "char" : 13,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZAyw",
      "endline" : 3588,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element.universalString"
      ]
     },
     {
      "name" : "universalString",
      "kind" : "function",
      "comment" : "        Encodes a dstring of UTF-32 characters.\n",
      "line" : 3594,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxAywZv",
      "originalType" : "@property @system void(in dstring value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAyw"
       }
      ],
      "endline" : 3613,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element.universalString"
      ]
     },
     {
      "name" : "characterString",
      "kind" : "function",
      "comment" : "        Decodes a CHARACTER STRING, which is a constructed data type, defined\n        in the $(LINK2 https://www.itu.int,\n                International Telecommunications Union)'s\n            $(LINK2 https://www.itu.int/rec/T-REC-X.680/en, X.680).\n\n        The specification defines CHARACTER as:\n\n        $(I\n            CHARACTER STRING ::= [UNIVERSAL 29] SEQUENCE {\n                identification CHOICE {\n                    syntaxes SEQUENCE {\n                        abstract OBJECT IDENTIFIER,\n                        transfer OBJECT IDENTIFIER },\n                    syntax OBJECT IDENTIFIER,\n                    presentation-context-id INTEGER,\n                    context-negotiation SEQUENCE {\n                        presentation-context-id INTEGER,\n                        transfer-syntax OBJECT IDENTIFIER },\n                    transfer-syntax OBJECT IDENTIFIER,\n                    fixed NULL },\n                string-value OCTET STRING }\n        )\n\n        This assumes AUTOMATIC TAGS, so all of the identification choices\n        will be context-specific and numbered from 0 to 5.\n\n        Returns: an instance of types.universal.CharacterString.\n        Throws:\n            ASN1SizeException = if encoded CharacterString has too few or too many\n                elements, or if syntaxes or context-negotiation element has\n                too few or too many elements.\n            ASN1ValueTooBigException = if encoded INTEGER is too large to decode.\n            ASN1InvalidIndexException = if encoded value selects a choice for\n                identification or uses an unspecified index for an element in\n                syntaxes or context-negotiation, or if an unspecified element\n                of CharacterString itself is referenced by an out-of-range\n                context-specific index. (See $(D_INLINECODE ASN1InvalidIndexException).)\n",
      "line" : 3655,
      "char" : 21,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZS5types9universal15characterstring15CharacterString",
      "endline" : 3798,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element.characterString"
      ]
     },
     {
      "name" : "characterString",
      "kind" : "function",
      "comment" : "        Encodes a CHARACTER STRING, which is a constructed data type, defined\n        in the $(LINK2 https://www.itu.int,\n                International Telecommunications Union)'s\n            $(LINK2 https://www.itu.int/rec/T-REC-X.680/en, X.680).\n\n        The specification defines CHARACTER as:\n\n        $(I\n            CHARACTER STRING ::= [UNIVERSAL 29] SEQUENCE {\n                identification CHOICE {\n                    syntaxes SEQUENCE {\n                        abstract OBJECT IDENTIFIER,\n                        transfer OBJECT IDENTIFIER },\n                    syntax OBJECT IDENTIFIER,\n                    presentation-context-id INTEGER,\n                    context-negotiation SEQUENCE {\n                        presentation-context-id INTEGER,\n                        transfer-syntax OBJECT IDENTIFIER },\n                    transfer-syntax OBJECT IDENTIFIER,\n                    fixed NULL },\n                string-value OCTET STRING }\n        )\n\n        This assumes AUTOMATIC TAGS, so all of the identification choices\n        will be context-specific and numbered from 0 to 5.\n",
      "line" : 3828,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxS5types9universal15characterstring15CharacterStringZv",
      "originalType" : "@property @system void(in CharacterString value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xS5types9universal15characterstring15CharacterString"
       }
      ],
      "endline" : 3881,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element.characterString"
      ],
      "out" : {
       "name" : "__ensure",
       "kind" : "function",
       "line" : 3830,
       "char" : 5,
       "deco" : "FNaNbNiZv",
       "originalType" : "@system void()",
       "endline" : 3830,
       "endchar" : 5
      }
     },
     {
      "name" : "__unittest___source_codecs_der_d_3892_0",
      "kind" : "function",
      "line" : 3892,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 3913,
      "endchar" : 5
     },
     {
      "name" : "__unittest___source_codecs_der_d_3914_0",
      "kind" : "function",
      "line" : 3914,
      "char" : 5,
      "storageClass" : [
       "@system"
      ],
      "endline" : 3958,
      "endchar" : 5
     },
     {
      "name" : "basicMultilingualPlaneString",
      "kind" : "function",
      "comment" : "        Decodes a wstring of UTF-16 characters.\n\n        Returns: an immutable array of UTF-16 characters.\n        Throws:\n            ASN1ValueInvalidException = if the encoded bytes is not evenly\n                divisible by two.\n",
      "line" : 3959,
      "char" : 13,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNdZAyu",
      "endline" : 3994,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element.basicMultilingualPlaneString"
      ]
     },
     {
      "name" : "basicMultilingualPlaneString",
      "kind" : "function",
      "comment" : "        Encodes a wstring of UTF-16 characters.\n",
      "line" : 4000,
      "char" : 10,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNdxAyuZv",
      "originalType" : "@property @system void(in wstring value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "xAyu"
       }
      ],
      "endline" : 4019,
      "endchar" : 5,
      "overrides" : [
       "codec.ASN1Element!(DistinguishedEncodingRulesElement).AbstractSyntaxNotation1Element.basicMultilingualPlaneString"
      ]
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "        Creates an EndOfContent DER Value.\n",
      "line" : 4025,
      "char" : 5,
      "deco" : "FNbNiNfZC6codecs3der33DistinguishedEncodingRulesElement",
      "originalType" : "nothrow @nogc @safe ()",
      "endline" : 4029,
      "endchar" : 5
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "        Creates a DERElement from the supplied bytes, inferring that the first\n        byte is the type tag. The supplied ubyte[] array is \"chomped\" by\n        reference, so the original array will grow shorter as DERElements are\n        generated.\n\n        Throws:\n            ASN1ValueTooSmallException = if the bytes supplied are fewer than\n                two (one or zero, in other words), such that no valid DERElement\n                can be decoded, or if the length is encoded in indefinite\n                form, but the END OF CONTENT octets (two consecutive null\n                octets) cannot be found, or if the value is encoded in fewer\n                octets than indicated by the length byte.\n            ASN1InvalidLengthException = if the length byte is set to 0xFF,\n                which is reserved.\n            ASN1ValueTooBigException = if the length cannot be represented by\n                the largest unsigned integer.\n\n        Example:\n        ---\n        // Decoding looks like:\n        DERElement[] result;\n        while (bytes.length > 0)\n            result ~= new DERElement(bytes);\n\n        // Encoding looks like:\n        ubyte[] result;\n        foreach (dv; bervalues)\n        {\n            result ~= cast(ubyte[]) dv;\n        }\n        ---\n",
      "line" : 4065,
      "char" : 5,
      "deco" : "FKAhZC6codecs3der33DistinguishedEncodingRulesElement",
      "originalType" : "@system (ref ubyte[] bytes)",
      "parameters" : [
       {
        "name" : "bytes",
        "deco" : "Ah",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 4069,
      "endchar" : 5
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "        Creates a DERElement from the supplied bytes, inferring that the first\n        byte is the type tag. The supplied ubyte[] array is read, starting\n        from the index specified by $(D bytesRead), and increments\n        $(D bytesRead) by the number of bytes read.\n\n        Throws:\n            ASN1ValueTooSmallException = if the bytes supplied are fewer than\n                two (one or zero, in other words), such that no valid DERElement\n                can be decoded, or if the length is encoded in indefinite\n                form, but the END OF CONTENT octets (two consecutive null\n                octets) cannot be found, or if the value is encoded in fewer\n                octets than indicated by the length byte.\n            ASN1InvalidLengthException = if the length byte is set to 0xFF,\n                which is reserved.\n            ASN1ValueTooBigException = if the length cannot be represented by\n                the largest unsigned integer.\n\n        Example:\n        ---\n        // Decoding looks like:\n        DERElement[] result;\n        size_t i = 0u;\n        while (i < bytes.length)\n            result ~= new DERElement(i, bytes);\n\n        // Encoding looks like:\n        ubyte[] result;\n        foreach (dv; bervalues)\n        {\n            result ~= cast(ubyte[]) dv;\n        }\n        ---\n",
      "line" : 4106,
      "char" : 5,
      "deco" : "FKmxAhZC6codecs3der33DistinguishedEncodingRulesElement",
      "originalType" : "@system (ref size_t bytesRead, in ubyte[] bytes)",
      "parameters" : [
       {
        "name" : "bytesRead",
        "deco" : "m",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "bytes",
        "deco" : "xAh"
       }
      ],
      "endline" : 4109,
      "endchar" : 5
     },
     {
      "name" : "fromBytes",
      "kind" : "function",
      "line" : 4113,
      "char" : 12,
      "deco" : "FxAhZm",
      "originalType" : "size_t(in ubyte[] bytes)",
      "parameters" : [
       {
        "name" : "bytes",
        "deco" : "xAh"
       }
      ],
      "endline" : 4359,
      "endchar" : 5,
      "overrides" : [
       "interfaces.Byteable.fromBytes"
      ]
     },
     {
      "name" : "toBytes",
      "kind" : "function",
      "comment" : "        This differs from $(D_INLINECODE this.value) in that\n        $(D_INLINECODE this.value) only returns the value octets, whereas\n        $(D_INLINECODE this.toBytes) returns the type tag, length tag / octets,\n        and the value octets, all concatenated.\n\n        This is the exact same as $(D_INLINECODE this.opCast!(ubyte[])()).\n\n        Returns: type tag, length tag, and value, all concatenated as a ubyte array.\n",
      "line" : 4372,
      "char" : 13,
      "deco" : "xFNbNdZAh",
      "endline" : 4431,
      "endchar" : 5,
      "overrides" : [
       "interfaces.Byteable.toBytes"
      ]
     },
     {
      "kind" : "template",
      "comment" : "        This differs from $(D_INLINECODE this.value) in that\n        $(D_INLINECODE this.value) only returns the value octets, whereas\n        $(D_INLINECODE this.toBytes) returns the type tag, length tag / octets,\n        and the value octets, all concatenated.\n\n        This is the exact same as $(D_INLINECODE this.toBytes()).\n\n        Returns: type tag, length tag, and value, all concatenated as a ubyte array.\n",
      "line" : 4444,
      "char" : 13,
      "name" : "opCast",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type",
        "default" : "ubyte[]"
       }
      ],
      "members" : [
       {
        "name" : "opCast",
        "kind" : "function",
        "line" : 4444,
        "char" : 13,
        "type" : "nothrow @system ubyte[]()",
        "endline" : 4447,
        "endchar" : 5
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittest___source_codecs_der_d_4453_22",
    "kind" : "function",
    "line" : 4453,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 4605,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_der_d_4606_23",
    "kind" : "function",
    "line" : 4606,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 4647,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_der_d_4648_24",
    "kind" : "function",
    "line" : 4648,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 4683,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_der_d_4684_25",
    "kind" : "function",
    "line" : 4684,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 4707,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_der_d_4708_26",
    "kind" : "function",
    "line" : 4708,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 4725,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_der_d_4726_27",
    "kind" : "function",
    "line" : 4726,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 4740,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_der_d_4741_28",
    "kind" : "function",
    "line" : 4741,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 4750,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_der_d_4751_29",
    "kind" : "function",
    "line" : 4751,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 4758,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_der_d_4759_30",
    "kind" : "function",
    "line" : 4759,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 4766,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_der_d_4767_31",
    "kind" : "function",
    "line" : 4767,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 4774,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_der_d_4775_32",
    "kind" : "function",
    "line" : 4775,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 4786,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_der_d_4787_33",
    "kind" : "function",
    "line" : 4787,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 4798,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_der_d_4799_34",
    "kind" : "function",
    "line" : 4799,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 4807,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_der_d_4808_35",
    "kind" : "function",
    "line" : 4808,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 4833,
    "endchar" : 1
   },
   {
    "name" : "__unittest___source_codecs_der_d_4834_36",
    "kind" : "function",
    "line" : 4834,
    "char" : 1,
    "storageClass" : [
     "@system"
    ],
    "endline" : 4850,
    "endchar" : 2
   }
  ]
 }
]